[
  {
    "input": "Perform Ridge regression for multi-class classification. X = [[1,2], [2,3], [3,4]], y = [0, 1, 2], \u03b1=1.",
    "output": "from sklearn.linear_model import RidgeClassifier\nimport numpy as np\n\nX = np.array([[1,2], [2,3], [3,4]])\ny = np.array([0,1,2])\nmodel = RidgeClassifier(alpha=1)\nmodel.fit(X, y)\nprint(\"Ridge Classifier Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply Ridge regression to predict house prices with multiple features: X = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], y = [100000, 200000, 300000], \u03b1=0.2.",
    "output": "from sklearn.linear_model import Ridge\nimport numpy as np\n\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\ny = np.array([100000, 200000, 300000])\nmodel = Ridge(alpha=0.2)\nmodel.fit(X, y)\nprint(\"House Price Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply ElasticNet to a simple dataset: X = [[1], [2], [3]], y = [1, 2, 3], \u03b1=0.1, l1_ratio=0.5.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 3])\nmodel = ElasticNet(alpha=0.1, l1_ratio=0.5)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit ElasticNet to a dataset with two features: X = [[1, 2], [3, 4], [5, 6]], y = [1, 2, 3], \u03b1=0.2, l1_ratio=0.4.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1, 2], [3, 4], [5, 6]])\ny = np.array([1, 2, 3])\nmodel = ElasticNet(alpha=0.2, l1_ratio=0.4)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use ElasticNet to predict with noisy data: X = [[1], [2], [3]], y = [2.1, 4.2, 6.3], \u03b1=0.1, l1_ratio=0.7.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1], [2], [3]])\ny = np.array([2.1, 4.2, 6.3])\nmodel = ElasticNet(alpha=0.1, l1_ratio=0.7)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use ElasticNet for higher-dimensional data: X = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], y = [1, 2, 3], \u03b1=0.3, l1_ratio=0.5.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\ny = np.array([1, 2, 3])\nmodel = ElasticNet(alpha=0.3, l1_ratio=0.5)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit ElasticNet with multiple features: X = [[1, 2], [2, 3], [3, 4]], y = [5, 6, 7], \u03b1=0.5, l1_ratio=0.6.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1, 2], [2, 3], [3, 4]])\ny = np.array([5, 6, 7])\nmodel = ElasticNet(alpha=0.5, l1_ratio=0.6)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit ElasticNet to high-dimensional data: X = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], y = [1, 2, 3, 4], \u03b1=0.4, l1_ratio=0.8.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\ny = np.array([1, 2, 3, 4])\nmodel = ElasticNet(alpha=0.4, l1_ratio=0.8)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit ElasticNet with smaller alpha value to avoid overfitting: X = [[1], [2], [3]], y = [1, 2, 3], \u03b1=0.05, l1_ratio=0.9.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 3])\nmodel = ElasticNet(alpha=0.05, l1_ratio=0.9)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Perform ElasticNet regression with high regularization: X = [[1, 2], [3, 4], [5, 6]], y = [100, 200, 300], \u03b1=10, l1_ratio=0.7.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1, 2], [3, 4], [5, 6]])\ny = np.array([100, 200, 300])\nmodel = ElasticNet(alpha=10, l1_ratio=0.7)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Perform ElasticNet on a dataset with outliers: X = [[1, 1], [2, 2], [100, 100]], y = [1, 2, 100], \u03b1=0.5, l1_ratio=0.5.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1, 1], [2, 2], [100, 100]])\ny = np.array([1, 2, 100])\nmodel = ElasticNet(alpha=0.5, l1_ratio=0.5)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use ElasticNet regression for classification with multi-class targets: X = [[1, 2], [3, 4], [5, 6]], y = [0, 1, 2], \u03b1=0.1, l1_ratio=0.5.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1, 2], [3, 4], [5, 6]])\ny = np.array([0, 1, 2])\nmodel = ElasticNet(alpha=0.1, l1_ratio=0.5)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit ElasticNet with data scaling: X = [[1], [2], [3]], y = [2.1, 4.2, 6.3], \u03b1=0.3, l1_ratio=0.4.",
    "output": "from sklearn.linear_model import ElasticNet\nfrom sklearn.preprocessing import StandardScaler\nimport numpy as np\n\nX = np.array([[1], [2], [3]])\ny = np.array([2.1, 4.2, 6.3])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = ElasticNet(alpha=0.3, l1_ratio=0.4)\nmodel.fit(X_scaled, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply ElasticNet with different alpha values: X = [[1, 2], [2, 3], [3, 4]], y = [1, 2, 3], \u03b1=0.6, l1_ratio=0.2.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1,2], [2,3], [3,4]])\ny = np.array([1,2,3])\nmodel = ElasticNet(alpha=0.6, l1_ratio=0.2)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply ElasticNet to a non-linear problem: X = [[1], [2], [3]], y = [1, 4, 9], \u03b1=0.1, l1_ratio=0.5.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[1], [2], [3]])\ny = np.array([1, 4, 9])\nmodel = ElasticNet(alpha=0.1, l1_ratio=0.5)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Perform ElasticNet regression with a large dataset: X = [[i] for i in range(1, 101)], y = [i*2 for i in range(1, 101)], \u03b1=0.2, l1_ratio=0.8.",
    "output": "from sklearn.linear_model import ElasticNet\nimport numpy as np\n\nX = np.array([[i] for i in range(1, 101)])\ny = np.array([i*2 for i in range(1, 101)])\nmodel = ElasticNet(alpha=0.2, l1_ratio=0.8)\nmodel.fit(X, y)\nprint(\"ElasticNet Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a polynomial regression model (degree 2) to X = [1, 2, 3], y = [1, 4, 9].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3]])\ny = np.array([1, 4, 9])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply degree 3 polynomial regression on X = [0, 1, 2], y = [1, 3, 27].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[0], [1], [2]])\ny = np.array([1, 3, 27])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a quadratic model to data: X = [[1], [2], [3], [4]], y = [2.1, 4.8, 9.1, 16.2].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([2.1, 4.8, 9.1, 16.2])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use polynomial regression to fit a cubic model: X = [1, 2, 3], y = [2, 6, 20].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[1], [2], [3]])\ny = np.array([2, 6, 20])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Cubic Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Model non-linear relation with degree 4 polynomial: X = [1, 2, 3, 4], y = [3, 5, 15, 33].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([3, 5, 15, 33])\npoly = PolynomialFeatures(degree=4)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Coefficients (degree 4):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a polynomial model to sales data: X = [5, 10, 15], y = [100, 150, 300], degree = 2.",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[5], [10], [15]])\ny = np.array([100, 150, 300])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Sales Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Quadratic regression on price data: X = [1, 2, 3, 4], y = [50, 70, 100, 140].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([50, 70, 100, 140])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Price Trend Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Model temperature trend using polynomial degree 3: X = [1, 2, 3, 4], y = [30, 33, 45, 65].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([30, 33, 45, 65])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Temperature Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict growth using 4th-degree polynomial: X = [1,2,3,4,5], y = [2, 8, 18, 32, 50].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([2, 8, 18, 32, 50])\npoly = PolynomialFeatures(degree=4)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Growth Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit polynomial regression (degree 5) to increasing trend data: X = [0, 1, 2, 3, 4], y = [1, 3, 7, 13, 21].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[0], [1], [2], [3], [4]])\ny = np.array([1, 3, 7, 13, 21])\npoly = PolynomialFeatures(degree=5)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Degree 5 Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Model electricity demand using a quadratic fit. X = [1, 2, 3, 4, 5], y = [100, 150, 220, 310, 420].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([100, 150, 220, 310, 420])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Electricity Demand Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a polynomial model (degree 3) to traffic flow data: X = [0, 1, 2, 3], y = [50, 80, 130, 210].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[0], [1], [2], [3]])\ny = np.array([50, 80, 130, 210])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Traffic Flow Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Model pollution levels using a cubic polynomial. X = [1, 3, 5, 7], y = [20, 30, 80, 150].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[1], [3], [5], [7]])\ny = np.array([20, 30, 80, 150])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Pollution Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply polynomial regression degree 2 on X = [10, 20, 30, 40], y = [100, 250, 500, 800].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[10], [20], [30], [40]])\ny = np.array([100, 250, 500, 800])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Degree 2 Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Model rainfall data with polynomial regression (degree 3): X = [5, 10, 15, 20], y = [3, 7, 18, 40].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[5], [10], [15], [20]])\ny = np.array([3, 7, 18, 40])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Rainfall Polynomial Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use polynomial regression (degree 4) to model economic index: X = [1, 2, 3, 4], y = [10, 30, 70, 130].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([10, 30, 70, 130])\npoly = PolynomialFeatures(degree=4)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Economic Index Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a polynomial model to stock price movement (degree 3): X = [1, 2, 3, 4], y = [100, 120, 160, 220].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([100, 120, 160, 220])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Stock Price Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a degree 2 polynomial to model plant growth: X = [1, 2, 3, 4], y = [2, 6, 14, 26].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([2, 6, 14, 26])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Plant Growth Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Model academic score trend using degree 3 polynomial. X = [1, 2, 3, 4, 5], y = [65, 68, 75, 85, 98].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([65, 68, 75, 85, 98])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Score Trend Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use degree 4 polynomial to model traffic delays: X = [1, 2, 3, 4], y = [3, 6, 20, 60].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([3, 6, 20, 60])\npoly = PolynomialFeatures(degree=4)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Traffic Delay Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a polynomial regression of degree 3 to demand data: X = [1, 2, 3, 4], y = [10, 40, 90, 160].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([10, 40, 90, 160])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Demand Curve Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply polynomial regression (degree 2) to fuel efficiency: X = [10, 20, 30, 40], y = [35, 32, 28, 25].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[10], [20], [30], [40]])\ny = np.array([35, 32, 28, 25])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Fuel Efficiency Model:\")\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Model disease spread using polynomial regression of degree 3. X = [1, 2, 3, 4], y = [3, 10, 25, 55].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([3, 10, 25, 55])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Disease Spread Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a 2nd degree polynomial to model speed vs distance. X = [1, 2, 3, 4], y = [5, 20, 45, 80].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([5, 20, 45, 80])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Speed-Distance Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use polynomial regression (degree 3) for predicting delivery times: X = [1, 2, 3, 4], y = [5, 10, 25, 50].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3], [4]])\ny = np.array([5, 10, 25, 50])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression()\nmodel.fit(X_poly, y)\nprint(\"Delivery Time Model Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a polynomial regression of degree 3 to the data X = [1, 2, 3, 4], y = [3, 6, 19, 44].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([1, 2, 3, 4]).reshape(-1, 1)\ny = np.array([3, 6, 19, 44])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)\nprint(\"Model: y = {:.2f} + {:.2f}x + {:.2f}x^2 + {:.2f}x^3\".format(\n      model.intercept_, *model.coef_[1:]))"
  },
  {
    "input": "Model the interaction between advertising and pricing on sales: X = [[10, 5], [15, 3], [20, 1], [25, 0]], y = [100, 130, 160, 180].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[10, 5], [15, 3], [20, 1], [25, 0]])\ninteraction = X[:, 0] * X[:, 1]\nX_aug = np.column_stack([X, interaction])\ny = np.array([100, 130, 160, 180])\nmodel = LinearRegression().fit(X_aug, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)\nprint(\"Model includes interaction term: Ad * Price\")"
  },
  {
    "input": "Symbolically solve for the least squares solution of X = [[1, 1], [1, 2], [1, 3]], y = [2, 2.5, 3].",
    "output": "import sympy as sp\n\nX = sp.Matrix([[1, 1], [1, 2], [1, 3]])\ny = sp.Matrix([2, 2.5, 3])\nbeta = (X.T * X).inv() * X.T * y\nsp.pprint(beta, use_unicode=True)"
  },
  {
    "input": "Use numpy to solve constrained least squares: X = [[1,1],[1,2]], y = [2,3], with constraint x1 + x2 = 1.",
    "output": "import numpy as np\nfrom scipy.optimize import minimize\n\nX = np.array([[1, 1], [1, 2]])\ny = np.array([2, 3])\n\nobj = lambda beta: np.sum((X @ beta - y)**2)\ncon = {'type': 'eq', 'fun': lambda beta: np.sum(beta) - 1}\nres = minimize(obj, np.zeros(2), constraints=con)\nprint(\"Optimal coefficients with constraint x1 + x2 = 1:\", res.x)"
  },
  {
    "input": "Generate a model where the independent variable is transformed logarithmically. X = [1, 10, 100, 1000], y = [0, 1, 2, 3].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.log10(np.array([1, 10, 100, 1000]).reshape(-1, 1))\ny = np.array([0, 1, 2, 3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f}*log10(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Fit a linear model where one feature is squared. X = [[1], [2], [3]], y = [1, 4, 9].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([1, 2, 3]).reshape(-1, 1)\nX_squared = X**2\ny = np.array([1, 4, 9])\nmodel = LinearRegression().fit(X_squared, y)\nprint(\"Model: y = {:.2f}x^2 + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Fit a model using orthogonal polynomials up to degree 2. X = [0, 1, 2], y = [1, 3, 7].",
    "output": "import numpy as np\nfrom numpy.polynomial.legendre import legvander\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([0, 1, 2])\ny = np.array([1, 3, 7])\nX_leg = legvander(X, 2)\nmodel = LinearRegression().fit(X_leg, y)\nprint(\"Coefficients (Legendre basis):\", model.coef_)"
  },
  {
    "input": "Predict a target using sinusoidal transformation. X = [0, \u03c0/2, \u03c0], y = [0, 1, 0].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([0, np.pi/2, np.pi]).reshape(-1, 1)\nX_sin = np.sin(X)\ny = np.array([0, 1, 0])\nmodel = LinearRegression().fit(X_sin, y)\nprint(\"Model: y = {:.2f}sin(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Use symbolic matrices to derive the normal equation for least squares given arbitrary X and y.",
    "output": "import sympy as sp\n\nX = sp.MatrixSymbol('X', 3, 2)\ny = sp.MatrixSymbol('y', 3, 1)\nbeta = (X.T * X).inv() * X.T * y\nsp.pprint(beta, use_unicode=True)"
  },
  {
    "input": "Perform a fit on multi-dimensional polynomial data: X = [[1,1], [2,1], [3,2]], y = [4, 7, 13].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1,1], [2,1], [3,2]])\ny = np.array([4, 7, 13])\npoly = PolynomialFeatures(degree=2, include_bias=False)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Generate a fit using Chebyshev polynomial basis. X = [-1, 0, 1], y = [2, 1, 2].",
    "output": "import numpy as np\nfrom numpy.polynomial.chebyshev import chebvander\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([-1, 0, 1])\ny = np.array([2, 1, 2])\nX_cheb = chebvander(X, 2)\nmodel = LinearRegression().fit(X_cheb, y)\nprint(\"Coefficients (Chebyshev basis):\", model.coef_)"
  },
  {
    "input": "Use a dummy variable to include a categorical variable in the regression. Data: day = ['weekday', 'weekend'], sales = [100, 150].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[0], [1]])  # 0 = weekday, 1 = weekend\ny = np.array([100, 150])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f}*is_weekend + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Perform a fit with ridge-like penalty manually via pseudo-inverse: X = [[1, 2], [3, 4]], y = [1, 2].",
    "output": "import numpy as np\n\nX = np.array([[1, 2], [3, 4]])\ny = np.array([1, 2])\nlambda_ = 0.1\nI = np.eye(X.shape[1])\nbeta = np.linalg.inv(X.T @ X + lambda_ * I) @ X.T @ y\nprint(\"Coefficients with manual regularization:\", beta)"
  },
  {
    "input": "Create a linear model with exponential feature transformation. X = [0, 1, 2], y = [1, 2.7, 7.4].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([0, 1, 2]).reshape(-1, 1)\nX_exp = np.exp(X)\ny = np.array([1, 2.7, 7.4])\nmodel = LinearRegression().fit(X_exp, y)\nprint(\"Model: y = {:.2f} * exp(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Fit a regression model with interaction between binary and continuous variables. X = [[0, 10], [1, 10], [0, 20], [1, 20]], y = [100, 150, 200, 300].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[0, 10], [1, 10], [0, 20], [1, 20]])\ninteraction = X[:, 0] * X[:, 1]\nX_aug = np.column_stack([X, interaction])\ny = np.array([100, 150, 200, 300])\nmodel = LinearRegression().fit(X_aug, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)\nprint(\"Interaction term (binary * continuous) included\")"
  },
  {
    "input": "Use polynomial regression with unevenly spaced X: X = [0.5, 2.3, 3.8], y = [1, 5, 9].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([0.5, 2.3, 3.8]).reshape(-1, 1)\ny = np.array([1, 5, 9])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Create a symbolic least squares estimator using sympy for a 2x2 X matrix.",
    "output": "import sympy as sp\n\nx11, x12, x21, x22, y1, y2 = sp.symbols('x11 x12 x21 x22 y1 y2')\nX = sp.Matrix([[x11, x12], [x21, x22]])\ny = sp.Matrix([y1, y2])\nbeta = (X.T * X).inv() * X.T * y\nsp.pprint(beta, use_unicode=True)"
  },
  {
    "input": "Fit a model with centered features to avoid multicollinearity. X = [[1, 1], [2, 2], [3, 3]], y = [2, 4, 6].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1, 1], [2, 2], [3, 3]])\nX_centered = X - X.mean(axis=0)\ny = np.array([2, 4, 6])\nmodel = LinearRegression().fit(X_centered, y)\nprint(\"Coefficients (with centered features):\", model.coef_)"
  },
  {
    "input": "Fit a piecewise linear model manually with a breakpoint at x = 2. X = [1, 2, 3], y = [1, 2, 5].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([1, 2, 3])\nX1 = (X <= 2).astype(int) * X\nX2 = (X > 2).astype(int) * (X - 2)\nX_aug = np.column_stack([X1, X2])\ny = np.array([1, 2, 5])\nmodel = LinearRegression().fit(X_aug, y)\nprint(\"Piecewise model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use PCA-transformed features for linear regression. X = [[2, 0], [0, 2], [1, 1]], y = [3, 3, 4].",
    "output": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[2, 0], [0, 2], [1, 1]])\ny = np.array([3, 3, 4])\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\nmodel = LinearRegression().fit(X_pca, y)\nprint(\"Coefficients on PCA features:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model with log-transformed target: X = [[1], [2], [3]], y = [2.7, 7.4, 20.1].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3]])\ny = np.log(np.array([2.7, 7.4, 20.1]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Model (log-transformed y): log(y) = {:.2f}x + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Use sklearn\u2019s PolynomialFeatures to fit a cubic model to X = [1, 2, 3, 4], y = [2, 8, 18, 32].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([1, 2, 3, 4]).reshape(-1, 1)\ny = np.array([2, 8, 18, 32])\npoly = PolynomialFeatures(degree=3)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Cubic model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model where the feature is reciprocal-transformed. X = [1, 2, 4], y = [4, 2, 1].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = 1 / np.array([1, 2, 4]).reshape(-1, 1)\ny = np.array([4, 2, 1])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f}(1/x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Fit a 2D quadratic surface to X = [[1,1], [2,1], [1,2], [2,2]], y = [3, 5, 5, 7].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1,1], [2,1], [1,2], [2,2]])\ny = np.array([3, 5, 5, 7])\npoly = PolynomialFeatures(degree=2, include_bias=False)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"2D quadratic model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model using squared features: X = [[1], [2], [3]], y = [2, 5, 10].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3]])\nX_sq = X ** 2\ny = np.array([2, 5, 10])\nmodel = LinearRegression().fit(X_sq, y)\nprint(\"Model: y = {:.2f} * x^2 + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Perform linear regression after normalizing the features. X = [[10], [20], [30]], y = [100, 200, 300].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\n\nX = np.array([[10], [20], [30]])\ny = np.array([100, 200, 300])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use interaction term for features: X = [[1, 2], [2, 3], [3, 4]], y = [5, 11, 19].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1, 2], [2, 3], [3, 4]])\ninteraction = (X[:, 0] * X[:, 1]).reshape(-1, 1)\nX_aug = np.hstack([X, interaction])\ny = np.array([5, 11, 19])\nmodel = LinearRegression().fit(X_aug, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model to log-transformed features: X = [[1], [10], [100]], y = [1, 2, 3].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.log(np.array([[1], [10], [100]]))\ny = np.array([1, 2, 3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f} * log(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Fit a model to predict energy consumption from temperature and humidity. X = [[30, 60], [25, 55], [20, 50]], y = [500, 400, 300].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[30, 60], [25, 55], [20, 50]])\ny = np.array([500, 400, 300])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use ridge-like penalty manually with regularized normal equation. X = [[1], [2], [3]], y = [1, 2, 3].",
    "output": "import numpy as np\n\nX = np.array([[1], [2], [3]])\ny = np.array([1, 2, 3])\nX_aug = np.hstack([X, np.ones((3, 1))])\nlambda_reg = 0.1\nI = np.eye(X_aug.shape[1])\nI[-1, -1] = 0  # Do not regularize intercept\nparams = np.linalg.inv(X_aug.T @ X_aug + lambda_reg * I) @ X_aug.T @ y\nprint(\"Regularized coefficients:\", params)"
  },
  {
    "input": "Fit a linear model where inputs are sine of time. X = [[0], [1], [2]], y = [0, 0.84, 0.91].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.sin(np.array([[0], [1], [2]]))\ny = np.array([0, 0.84, 0.91])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f} * sin(t) + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Predict weight from height and age. X = [[160, 25], [170, 30], [180, 35]], y = [60, 70, 80].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[160, 25], [170, 30], [180, 35]])\ny = np.array([60, 70, 80])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (Height, Age):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply a log-log model: X = [1, 10, 100], y = [10, 100, 1000].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.log(np.array([1, 10, 100]).reshape(-1, 1))\ny = np.log(np.array([10, 100, 1000]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: log(y) = {:.2f} * log(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Fit a model with categorical variables using one-hot encoding. X = ['red', 'blue', 'green'], y = [1, 2, 3].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import OneHotEncoder\n\nX = np.array(['red', 'blue', 'green']).reshape(-1, 1)\ny = np.array([1, 2, 3])\nencoder = OneHotEncoder(sparse_output=False)\nX_encoded = encoder.fit_transform(X)\nmodel = LinearRegression().fit(X_encoded, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a linear regression on the first differences of a time series. y = [100, 105, 110, 120].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\ny = np.array([100, 105, 110, 120])\nX = np.arange(len(y) - 1).reshape(-1, 1)\ny_diff = np.diff(y)\nmodel = LinearRegression().fit(X, y_diff)\nprint(\"Rate of change (slope):\", model.coef_[0])"
  },
  {
    "input": "Use feature scaling and fit model: X = [[5], [15], [25]], y = [50, 150, 250].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[5], [15], [25]])\ny = np.array([50, 150, 250])\nscaler = MinMaxScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Estimate regression weights symbolically for X = [[1, x]], y = [y1, y2].",
    "output": "import sympy as sp\n\nx, y1, y2 = sp.symbols('x y1 y2')\nX = sp.Matrix([[1, 1], [1, x]])\ny = sp.Matrix([y1, y2])\nbeta = (X.T * X).inv() * X.T * y\nsp.pprint(beta)"
  },
  {
    "input": "Fit linear regression with dropped constant feature. X = [[1, 5], [1, 10], [1, 15]], y = [10, 20, 30].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1, 5], [1, 10], [1, 15]])\nX_dropped = X[:, 1].reshape(-1, 1)\ny = np.array([10, 20, 30])\nmodel = LinearRegression().fit(X_dropped, y)\nprint(\"Model without constant feature: y = {:.2f}x + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Fit a model to polynomial transformed data: X = [[1], [2], [3]], y = [3, 12, 27].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3]])\ny = np.array([3, 12, 27])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a linear model to predict salary from years of experience: X = [[1], [3], [5]], y = [40, 60, 80].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [3], [5]])\ny = np.array([40, 60, 80])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f}x + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Apply standardization before regression: X = [[5, 100], [10, 200], [15, 300]], y = [1, 2, 3].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\n\nX = np.array([[5, 100], [10, 200], [15, 300]])\ny = np.array([1, 2, 3])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model using square root transformed features: X = [[1], [4], [9]], y = [1, 2, 3].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.sqrt(np.array([[1], [4], [9]]))\ny = np.array([1, 2, 3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f} * sqrt(x) + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Fit a model on time-indexed data: X = [[1], [2], [3]], y = [10, 12, 15].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3]])\ny = np.array([10, 12, 15])\nmodel = LinearRegression().fit(X, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict house price from area and number of bedrooms: X = [[1000, 2], [1500, 3], [2000, 4]], y = [100, 150, 200].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1000, 2], [1500, 3], [2000, 4]])\ny = np.array([100, 150, 200])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (area, bedrooms):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use linear regression on distance traveled over time: X = [[1], [2], [3]], y = [30, 60, 90].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3]])\ny = np.array([30, 60, 90])\nmodel = LinearRegression().fit(X, y)\nprint(\"Speed (slope):\", model.coef_[0])\nprint(\"Initial offset:\", model.intercept_)"
  },
  {
    "input": "Apply mean normalization before regression: X = [[50], [100], [150]], y = [5, 10, 15].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[50], [100], [150]])\ny = np.array([5, 10, 15])\nX_norm = (X - X.mean()) / (X.max() - X.min())\nmodel = LinearRegression().fit(X_norm, y)\nprint(\"Model: y = {:.2f}x_norm + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Predict crop yield using soil quality and irrigation. X = [[7, 3], [8, 4], [9, 5]], y = [2.5, 3.0, 3.5].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[7, 3], [8, 4], [9, 5]])\ny = np.array([2.5, 3.0, 3.5])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit linear regression on hours studied vs score: X = [[1], [2], [4]], y = [50, 60, 80].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [4]])\ny = np.array([50, 60, 80])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f} * hours + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Fit a regression model using interaction terms: X = [[1, 2], [2, 3], [3, 4]], y = [5, 9, 15].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1, 2], [2, 3], [3, 4]])\ny = np.array([5, 9, 15])\npoly = PolynomialFeatures(degree=2, interaction_only=True, include_bias=False)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict energy consumption from temperature, humidity, and wind speed. X = [[30, 60, 10], [25, 70, 12], [20, 80, 15]], y = [400, 350, 300].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[30, 60, 10], [25, 70, 12], [20, 80, 15]])\ny = np.array([400, 350, 300])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Perform linear regression after normalizing features: X = [[10, 20], [20, 30], [30, 40]], y = [100, 150, 200].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[10, 20], [20, 30], [30, 40]])\ny = np.array([100, 150, 200])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a regression model with log-transformed features: X = [[1], [10], [100]], y = [2, 5, 9].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.log(np.array([[1], [10], [100]]))\ny = np.array([2, 5, 9])\nmodel = LinearRegression().fit(X, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply a square transformation to the features before regression: X = [[2], [3], [4]], y = [4, 9, 16].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.square(np.array([[2], [3], [4]]))\ny = np.array([4, 9, 16])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model: y = {:.2f}x^2 + {:.2f}\".format(model.coef_[0], model.intercept_))"
  },
  {
    "input": "Use polynomial regression to fit nonlinear data: X = [[1], [2], [3]], y = [2, 8, 18].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[1], [2], [3]])\ny = np.array([2, 8, 18])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict crop yield from rainfall and soil pH using standardized features. X = [[100, 5.5], [200, 6.0], [300, 6.5]], y = [2.0, 2.8, 3.5].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[100, 5.5], [200, 6.0], [300, 6.5]])\ny = np.array([2.0, 2.8, 3.5])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a linear model to log-scaled inputs and outputs. X = [[10], [100], [1000]], y = [100, 1000, 10000].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.log10(np.array([[10], [100], [1000]]))\ny = np.log10(np.array([100, 1000, 10000]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict car mileage from engine size and weight: X = [[1.2, 1000], [1.6, 1200], [2.0, 1400]], y = [20, 18, 15].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1.2, 1000], [1.6, 1200], [2.0, 1400]])\ny = np.array([20, 18, 15])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (engine, weight):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Perform regression using mean-centered features. X = [[2], [4], [6]], y = [3, 7, 11].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[2], [4], [6]])\ny = np.array([3, 7, 11])\nX_centered = X - X.mean()\nmodel = LinearRegression().fit(X_centered, y)\nprint(\"Coefficient:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model to predict blood pressure from age and weight. X = [[25, 150], [35, 160], [45, 170]], y = [120, 130, 140].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[25, 150], [35, 160], [45, 170]])\ny = np.array([120, 130, 140])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (age, weight):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use polynomial regression to predict house prices from square footage: X = [[1000], [1500], [2000]], y = [200000, 300000, 450000].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1000], [1500], [2000]])\ny = np.array([200000, 300000, 450000])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict exam scores based on study time and hours of sleep: X = [[2, 6], [4, 7], [6, 8]], y = [60, 75, 85].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[2, 6], [4, 7], [6, 8]])\ny = np.array([60, 75, 85])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (study, sleep):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply a log transformation to y values before regression. X = [[1], [2], [3]], y = [2.7, 7.4, 20.1].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3]])\ny = np.log(np.array([2.7, 7.4, 20.1]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict battery life from usage hours and screen brightness. X = [[2, 50], [4, 70], [6, 90]], y = [10, 6, 3].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[2, 50], [4, 70], [6, 90]])\ny = np.array([10, 6, 3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (hours, brightness):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use standardized features to fit a model predicting delivery time from distance and traffic index: X = [[5, 30], [10, 40], [15, 50]], y = [15, 25, 35].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\n\nX = np.array([[5, 30], [10, 40], [15, 50]])\ny = np.array([15, 25, 35])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Perform regression using a square root transformation on features. X = [[1], [4], [9]], y = [2, 4, 6].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.sqrt(np.array([[1], [4], [9]]))\ny = np.array([2, 4, 6])\nmodel = LinearRegression().fit(X, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict product sales using ad spend and influencer score. X = [[100, 80], [200, 90], [300, 100]], y = [1000, 2000, 3100].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[100, 80], [200, 90], [300, 100]])\ny = np.array([1000, 2000, 3100])\nmodel = LinearRegression().fit(X, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use polynomial regression (degree=2) to model relationship between ad clicks and revenue. X = [[10], [20], [30]], y = [50, 150, 300].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[10], [20], [30]])\ny = np.array([50, 150, 300])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model to log-transformed house prices using number of bedrooms and bathrooms. X = [[2, 1], [3, 2], [4, 3]], y = [200000, 300000, 500000].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[2, 1], [3, 2], [4, 3]])\ny = np.log(np.array([200000, 300000, 500000]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict gas usage based on temperature and usage time. X = [[30, 1], [25, 2], [20, 3]], y = [10, 15, 20].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[30, 1], [25, 2], [20, 3]])\ny = np.array([10, 15, 20])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (temp, time):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply z-score normalization and fit a linear model: X = [[3, 6], [4, 8], [5, 10]], y = [12, 16, 20].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\n\nX = np.array([[3, 6], [4, 8], [5, 10]])\ny = np.array([12, 16, 20])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Model coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model with feature interaction for predicting yield. X = [[100, 5], [150, 6], [200, 7]], y = [3, 4.5, 6.5].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[100, 5], [150, 6], [200, 7]])\ny = np.array([3, 4.5, 6.5])\npoly = PolynomialFeatures(degree=2, interaction_only=True, include_bias=False)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict machine failure probability based on age and usage. X = [[1, 100], [2, 200], [3, 300]], y = [0.1, 0.3, 0.6].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1, 100], [2, 200], [3, 300]])\ny = np.array([0.1, 0.3, 0.6])\nmodel = LinearRegression().fit(X, y)\nprint(\"Coefficients (age, usage):\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use log(x1 * x2) transformation and predict outcomes. X = [[1, 2], [2, 4], [3, 6]], y = [1, 2, 3].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX_raw = np.array([[1, 2], [2, 4], [3, 6]])\nX_trans = np.log(np.prod(X_raw, axis=1)).reshape(-1, 1)\ny = np.array([1, 2, 3])\nmodel = LinearRegression().fit(X_trans, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Model sales as a function of advertising on TV and radio. X = [[100, 20], [200, 30], [300, 40]], y = [400, 800, 1200].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[100, 20], [200, 30], [300, 40]])\ny = np.array([400, 800, 1200])\nmodel = LinearRegression().fit(X, y)\nprint(\"TV coef:\", model.coef_[0])\nprint(\"Radio coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict crop yield using fertilizer and rainfall with polynomial regression (degree=2). X = [[100, 20], [150, 30], [200, 40]], y = [2, 3.5, 5.5].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[100, 20], [150, 30], [200, 40]])\ny = np.array([2, 3.5, 5.5])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Standardize inputs before fitting model to predict grades from study hours and sleep. X = [[2, 6], [4, 7], [6, 8]], y = [65, 75, 85].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\n\nX = np.array([[2, 6], [4, 7], [6, 8]])\ny = np.array([65, 75, 85])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model with square root transformation on both predictors. X = [[1, 4], [4, 16], [9, 36]], y = [1.5, 3.0, 4.5].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.sqrt(np.array([[1, 4], [4, 16], [9, 36]]))\ny = np.array([1.5, 3.0, 4.5])\nmodel = LinearRegression().fit(X, y)\nprint(\"Square-root transformed coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply log-log regression: log(y) vs log(x). X = [[10], [100], [1000]], y = [2, 20, 200].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.log(np.array([[10], [100], [1000]]))\ny = np.log(np.array([2, 20, 200]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Log-log slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict fuel efficiency from engine size and weight using interaction terms. X = [[2.0, 1000], [3.0, 1500], [4.0, 2000]], y = [35, 28, 22].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[2.0, 1000], [3.0, 1500], [4.0, 2000]])\ny = np.array([35, 28, 22])\npoly = PolynomialFeatures(interaction_only=True, include_bias=False)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Interaction coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use mean-normalized features to predict test scores from hours studied. X = [[1], [2], [3]], y = [50, 65, 80].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1], [2], [3]])\ny = np.array([50, 65, 80])\nX_centered = X - np.mean(X, axis=0)\nmodel = LinearRegression().fit(X_centered, y)\nprint(\"Slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict reaction time from caffeine intake (mg) and sleep (hrs). X = [[50, 6], [100, 5], [200, 4]], y = [1.2, 1.0, 0.8].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[50, 6], [100, 5], [200, 4]])\ny = np.array([1.2, 1.0, 0.8])\nmodel = LinearRegression().fit(X, y)\nprint(\"Caffeine coef:\", model.coef_[0])\nprint(\"Sleep coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Model log(yield) from fertilizer amount using log(fertilizer). X = [[10], [20], [40]], y = [1, 3, 6].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.log(np.array([[10], [20], [40]]))\ny = np.log(np.array([1, 3, 6]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Log-log slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use linear regression on binary features: is_smoker, drinks_coffee to predict productivity. X = [[1, 1], [1, 0], [0, 1], [0, 0]], y = [50, 55, 60, 70].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1, 1], [1, 0], [0, 1], [0, 0]])\ny = np.array([50, 55, 60, 70])\nmodel = LinearRegression().fit(X, y)\nprint(\"Smoker coef:\", model.coef_[0])\nprint(\"Coffee coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Standardize a single feature and fit a regression: X = [[1], [2], [3]], y = [10, 20, 30].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\n\nX = np.array([[1], [2], [3]])\ny = np.array([10, 20, 30])\nscaler = StandardScaler()\nX_std = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_std, y)\nprint(\"Standardized coef:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit regression to predict weight from height and age. X = [[160, 25], [170, 30], [180, 35]], y = [60, 70, 80].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[160, 25], [170, 30], [180, 35]])\ny = np.array([60, 70, 80])\nmodel = LinearRegression().fit(X, y)\nprint(\"Height coef:\", model.coef_[0])\nprint(\"Age coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use transformed feature 1/x to model decay rate. X = [[1], [2], [4]], y = [0.9, 0.6, 0.3].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = 1 / np.array([[1], [2], [4]])\ny = np.array([0.9, 0.6, 0.3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Decay slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict battery life using screen-on time and number of apps open. X = [[3, 10], [5, 15], [7, 20]], y = [10, 7, 4].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[3, 10], [5, 15], [7, 20]])\ny = np.array([10, 7, 4])\nmodel = LinearRegression().fit(X, y)\nprint(\"Screen time coef:\", model.coef_[0])\nprint(\"Apps coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model to predict final grade based on assignments, quizzes, and midterm scores. X = [[80, 70, 75], [85, 80, 78], [90, 85, 82]], y = [78, 83, 88].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[80, 70, 75], [85, 80, 78], [90, 85, 82]])\ny = np.array([78, 83, 88])\nmodel = LinearRegression().fit(X, y)\nprint(\"Assignment coef:\", model.coef_[0])\nprint(\"Quiz coef:\", model.coef_[1])\nprint(\"Midterm coef:\", model.coef_[2])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Standardize data and predict cholesterol from fat and sugar intake. X = [[60, 30], [70, 40], [80, 50]], y = [180, 200, 220].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import StandardScaler\n\nX = np.array([[60, 30], [70, 40], [80, 50]])\ny = np.array([180, 200, 220])\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use square root transformation on X and fit model to predict energy from time. X = [[1], [4], [9]], y = [10, 20, 30].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.sqrt(np.array([[1], [4], [9]]))\ny = np.array([10, 20, 30])\nmodel = LinearRegression().fit(X, y)\nprint(\"Sqrt transformed slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model using 2nd-degree polynomial on temperature to predict ice cream sales. X = [[20], [25], [30]], y = [100, 200, 400].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[20], [25], [30]])\ny = np.array([100, 200, 400])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply log transform on X to predict brightness from aperture size. X = [[1.4], [2.8], [5.6]], y = [100, 50, 25].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.log(np.array([[1.4], [2.8], [5.6]]))\ny = np.array([100, 50, 25])\nmodel = LinearRegression().fit(X, y)\nprint(\"Log-transformed slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Model price based on square footage and number of rooms. X = [[1000, 2], [1500, 3], [2000, 4]], y = [200000, 300000, 400000].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1000, 2], [1500, 3], [2000, 4]])\ny = np.array([200000, 300000, 400000])\nmodel = LinearRegression().fit(X, y)\nprint(\"Sqft coef:\", model.coef_[0])\nprint(\"Rooms coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict electricity usage from number of devices and hours used. X = [[3, 5], [4, 6], [5, 7]], y = [15, 20, 25].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[3, 5], [4, 6], [5, 7]])\ny = np.array([15, 20, 25])\nmodel = LinearRegression().fit(X, y)\nprint(\"Devices coef:\", model.coef_[0])\nprint(\"Hours coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use interaction features for study time and sleep to predict test score. X = [[2, 6], [4, 7], [6, 8]], y = [60, 75, 85].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[2, 6], [4, 7], [6, 8]])\ny = np.array([60, 75, 85])\npoly = PolynomialFeatures(interaction_only=True, include_bias=False)\nX_inter = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_inter, y)\nprint(\"Interaction coefs:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a linear model where predictors are mean-subtracted. X = [[10], [20], [30]], y = [100, 200, 300].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[10], [20], [30]])\ny = np.array([100, 200, 300])\nX_mean = X - np.mean(X, axis=0)\nmodel = LinearRegression().fit(X_mean, y)\nprint(\"Centered slope:\", model.coef_[0])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict CO2 emissions from engine size and fuel consumption. X = [[1.2, 5], [1.6, 7], [2.0, 9]], y = [120, 150, 180].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1.2, 5], [1.6, 7], [2.0, 9]])\ny = np.array([120, 150, 180])\nmodel = LinearRegression().fit(X, y)\nprint(\"Engine coef:\", model.coef_[0])\nprint(\"Fuel coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use polynomial features of degree 2 to model house price from area. X = [[1000], [1500], [2000]], y = [150000, 225000, 325000].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX = np.array([[1000], [1500], [2000]])\ny = np.array([150000, 225000, 325000])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Polynomial coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model to predict heart rate from exercise duration and intensity level. X = [[30, 3], [45, 5], [60, 7]], y = [100, 130, 160].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[30, 3], [45, 5], [60, 7]])\ny = np.array([100, 130, 160])\nmodel = LinearRegression().fit(X, y)\nprint(\"Duration coef:\", model.coef_[0])\nprint(\"Intensity coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict weight based on height and age. X = [[160, 25], [170, 30], [180, 35]], y = [60, 70, 80].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[160, 25], [170, 30], [180, 35]])\ny = np.array([60, 70, 80])\nmodel = LinearRegression().fit(X, y)\nprint(\"Height coef:\", model.coef_[0])\nprint(\"Age coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Apply normalization before predicting rent from area and distance to city. X = [[600, 5], [800, 3], [1000, 2]], y = [1000, 1300, 1600].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[600, 5], [800, 3], [1000, 2]])\ny = np.array([1000, 1300, 1600])\nscaler = MinMaxScaler()\nX_scaled = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_scaled, y)\nprint(\"Coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict fuel efficiency using horsepower and weight. X = [[100, 2500], [150, 3000], [200, 3500]], y = [30, 25, 20].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[100, 2500], [150, 3000], [200, 3500]])\ny = np.array([30, 25, 20])\nmodel = LinearRegression().fit(X, y)\nprint(\"Horsepower coef:\", model.coef_[0])\nprint(\"Weight coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use log(y) transformation for population prediction based on income and employment rate. X = [[30000, 80], [40000, 85], [50000, 90]], y = [5000, 10000, 20000].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[30000, 80], [40000, 85], [50000, 90]])\ny = np.log(np.array([5000, 10000, 20000]))\nmodel = LinearRegression().fit(X, y)\nprint(\"Log-transformed population coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict temperature drop from altitude and humidity. X = [[500, 30], [1000, 40], [1500, 50]], y = [20, 15, 10].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[500, 30], [1000, 40], [1500, 50]])\ny = np.array([20, 15, 10])\nmodel = LinearRegression().fit(X, y)\nprint(\"Altitude coef:\", model.coef_[0])\nprint(\"Humidity coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model for sales prediction using advertising on TV and online. X = [[50, 30], [60, 40], [70, 50]], y = [200, 250, 300].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[50, 30], [60, 40], [70, 50]])\ny = np.array([200, 250, 300])\nmodel = LinearRegression().fit(X, y)\nprint(\"TV coef:\", model.coef_[0])\nprint(\"Online coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Standardize predictors before fitting a model for crop output based on sunlight and water. X = [[5, 10], [6, 15], [7, 20]], y = [50, 70, 90].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[5, 10], [6, 15], [7, 20]])\ny = np.array([50, 70, 90])\nscaler = StandardScaler()\nX_std = scaler.fit_transform(X)\nmodel = LinearRegression().fit(X_std, y)\nprint(\"Standardized coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Model CO2 emissions from distance traveled and fuel used. X = [[100, 5], [200, 10], [300, 15]], y = [50, 100, 150].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[100, 5], [200, 10], [300, 15]])\ny = np.array([50, 100, 150])\nmodel = LinearRegression().fit(X, y)\nprint(\"Distance coef:\", model.coef_[0])\nprint(\"Fuel coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Use polynomial features of degree 2 to model volume from dimensions. X = [[1, 2], [2, 3], [3, 4]], y = [2, 6, 12].",
    "output": "import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1, 2], [2, 3], [3, 4]])\ny = np.array([2, 6, 12])\npoly = PolynomialFeatures(degree=2)\nX_poly = poly.fit_transform(X)\nmodel = LinearRegression().fit(X_poly, y)\nprint(\"Polynomial coefficients:\", model.coef_)\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict delivery time from package weight and delivery distance. X = [[1, 10], [2, 20], [3, 30]], y = [15, 30, 45].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[1, 10], [2, 20], [3, 30]])\ny = np.array([15, 30, 45])\nmodel = LinearRegression().fit(X, y)\nprint(\"Weight coef:\", model.coef_[0])\nprint(\"Distance coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit model to predict rating based on reviews and views. X = [[100, 1000], [200, 2000], [300, 3000]], y = [3.5, 4.0, 4.5].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[100, 1000], [200, 2000], [300, 3000]])\ny = np.array([3.5, 4.0, 4.5])\nmodel = LinearRegression().fit(X, y)\nprint(\"Reviews coef:\", model.coef_[0])\nprint(\"Views coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Predict weight loss from time spent walking and calorie deficit. X = [[30, 500], [60, 800], [90, 1000]], y = [1, 2, 3].",
    "output": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\n\nX = np.array([[30, 500], [60, 800], [90, 1000]])\ny = np.array([1, 2, 3])\nmodel = LinearRegression().fit(X, y)\nprint(\"Time coef:\", model.coef_[0])\nprint(\"Deficit coef:\", model.coef_[1])\nprint(\"Intercept:\", model.intercept_)"
  },
  {
    "input": "Fit a model to predict final grade based on midterm and attendance: X = [[80, 90], [85, 95], [70, 60], [90, 100]], y = [88, 92, 75, 95].",
    "output": "import numpy as np\n\nX = np.array([[80, 90], [85, 95], [70, 60], [90, 100]])\ny = np.array([88, 92, 75, 95])\nX_aug = np.hstack([X, np.ones((X.shape[0], 1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Grade = {params[0]:.4f}*Midterm + {params[1]:.4f}*Attendance + {params[2]:.4f}\")"
  },
  {
    "input": "Use least squares to fit the function y = a*log(x) + b to x = [1, 2, 4, 8], y = [0, 0.69, 1.38, 2.07].",
    "output": "import numpy as np\n\nx = np.array([1, 2, 4, 8])\ny = np.array([0, 0.69, 1.38, 2.07])\nX = np.vstack([np.log(x), np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*log(x) + {params[1]:.4f}\")"
  },
  {
    "input": "Fit a least squares model to temperature over hours: x = [0, 4, 8, 12, 16, 20], y = [30, 35, 45, 55, 50, 40].",
    "output": "import numpy as np\n\nx = np.array([0, 4, 8, 12, 16, 20])\ny = np.array([30, 35, 45, 55, 50, 40])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"Temperature = {params[0]:.4f}*Hour + {params[1]:.4f}\")"
  },
  {
    "input": "Estimate parameters in model y = a*x^2 + b*x for x = [1, 2, 3, 4], y = [3, 7, 13, 21].",
    "output": "import numpy as np\n\nx = np.array([1, 2, 3, 4])\ny = np.array([3, 7, 13, 21])\nX = np.vstack([x**2, x]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x^2 + {params[1]:.4f}*x\")"
  },
  {
    "input": "Apply least squares to normalize data by fitting a line to z-scores of x = [10, 20, 30, 40], y = [15, 25, 35, 45].",
    "output": "import numpy as np\n\nx = np.array([10, 20, 30, 40])\ny = np.array([15, 25, 35, 45])\nx_norm = (x - x.mean()) / x.std()\nX = np.vstack([x_norm, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*z_x + {params[1]:.4f}\")"
  },
  {
    "input": "Use least squares to fit a model with squared and cube terms: x = [1, 2, 3], y = [2, 9, 28].",
    "output": "import numpy as np\n\nx = np.array([1, 2, 3])\ny = np.array([2, 9, 28])\nX = np.vstack([x**3, x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x^3 + {params[1]:.4f}*x^2 + {params[2]:.4f}*x + {params[3]:.4f}\")"
  },
  {
    "input": "Fit a linear regression model to predict distance from time and speed: X = [[1, 10], [2, 15], [3, 20]], y = [10, 30, 60].",
    "output": "import numpy as np\n\nX = np.array([[1, 10], [2, 15], [3, 20]])\ny = np.array([10, 30, 60])\nX_aug = np.hstack([X, np.ones((X.shape[0], 1))])\nparams, *_ = np.linalg.lstsq(X_aug, y, rcond=None)\nprint(f\"Distance = {params[0]:.4f}*Time + {params[1]:.4f}*Speed + {params[2]:.4f}\")"
  },
  {
    "input": "Fit a model y = ax^2 + bx + c to x = [0, 1, 2, 3], y = [1, 2, 5, 10].",
    "output": "import numpy as np\n\nx = np.array([0, 1, 2, 3])\ny = np.array([1, 2, 5, 10])\nX = np.vstack([x**2, x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x^2 + {params[1]:.4f}*x + {params[2]:.4f}\")"
  },
  {
    "input": "Estimate linear trend from seasonal sales data: x = [1, 2, 3, 4], y = [110, 150, 200, 250].",
    "output": "import numpy as np\n\nx = np.array([1, 2, 3, 4])\ny = np.array([110, 150, 200, 250])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"Sales = {params[0]:.4f}*Month + {params[1]:.4f}\")"
  },
  {
    "input": "Fit model y = a/x + b for x = [1, 2, 3, 4], y = [4, 2.5, 2, 1.8].",
    "output": "import numpy as np\n\nx = np.array([1, 2, 3, 4])\ny = np.array([4, 2.5, 2, 1.8])\nX = np.vstack([1/x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*(1/x) + {params[1]:.4f}\")"
  },
  {
    "input": "Given x = [1, 2, 3, 4], y = [2, 4, 6, 10], fit y = a*x + b using least squares.",
    "output": "import numpy as np\n\nx = np.array([1, 2, 3, 4])\ny = np.array([2, 4, 6, 10])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x + {params[1]:.4f}\")"
  },
  {
    "input": "Fit model to data with negative correlation: x = [1, 2, 3, 4], y = [10, 8, 6, 4].",
    "output": "import numpy as np\n\nx = np.array([1, 2, 3, 4])\ny = np.array([10, 8, 6, 4])\nX = np.vstack([x, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"Negative correlation model: y = {params[0]:.4f}*x + {params[1]:.4f}\")"
  },
  {
    "input": "Perform regression with engineered feature x^2 on x = [1, 2, 3], y = [2, 5, 10].",
    "output": "import numpy as np\n\nx = np.array([1, 2, 3])\ny = np.array([2, 5, 10])\nX = np.vstack([x**2, np.ones_like(x)]).T\nparams, *_ = np.linalg.lstsq(X, y, rcond=None)\nprint(f\"y = {params[0]:.4f}*x^2 + {params[1]:.4f}\")"
  },
  {
    "input": "Predict if a student will pass (1) or fail (0) based on study hours using logistic regression. X = [[2], [4], [6], [8], [10]], y = [0, 0, 1, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[2], [4], [6], [8], [10]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(f\"Predicted probabilities: {model.predict_proba([[5], [7], [9]])[:,1]}\")"
  },
  {
    "input": "Use logistic regression to classify tumors as benign (0) or malignant (1) based on size. X = [[1.2], [2.3], [3.1], [3.8], [5.0]], y = [0, 0, 1, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[1.2], [2.3], [3.1], [3.8], [5.0]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\npred = model.predict([[2.5], [4.5]])\nprint(f\"Predictions: {pred}\")"
  },
  {
    "input": "Logistic regression to predict if a customer buys a product based on advertisement time. X = [[0.5], [1.0], [1.5], [2.0], [2.5]], y = [0, 0, 1, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[0.5], [1.0], [1.5], [2.0], [2.5]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Probability of purchase after 1.8 hours:\", model.predict_proba([[1.8]])[0,1])"
  },
  {
    "input": "Binary classification using logistic regression: Predict disease presence based on cholesterol levels. X = [[180], [190], [200], [210], [220]], y = [0, 0, 1, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[180], [190], [200], [210], [220]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Probability of disease at cholesterol 195:\", model.predict_proba([[195]])[0,1])"
  },
  {
    "input": "Logistic regression: Predict email spam status from number of links. X = [[1], [2], [3], [4], [5]], y = [0, 0, 1, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Spam probability with 3 links:\", model.predict_proba([[3]])[0,1])"
  },
  {
    "input": "Logistic regression: Classify customer satisfaction (0 = unsatisfied, 1 = satisfied) using service rating. X = [[1], [2], [3], [4], [5]], y = [0, 0, 1, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Probability of satisfaction at rating 3:\", model.predict_proba([[3]])[0,1])"
  },
  {
    "input": "Use Poisson regression to predict daily calls based on working hours. X = [[4], [6], [8], [10], [12]], y = [2, 4, 6, 8, 10].",
    "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\n\nX = np.array([[4], [6], [8], [10], [12]])\ny = np.array([2, 4, 6, 8, 10])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted calls for 9 hours:\", model.predict([[9]])[0])"
  },
  {
    "input": "Logistic regression to predict whether a customer subscribes (1) or not (0) based on call duration. X = [[1], [3], [5], [7], [9]], y = [0, 0, 1, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[1], [3], [5], [7], [9]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Subscription probability for 6 mins:\", model.predict_proba([[6]])[0,1])"
  },
  {
    "input": "Poisson regression: Model foot traffic at a store from number of ads shown. X = [[1], [2], [3], [4], [5]], y = [5, 10, 15, 20, 25].",
    "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\n\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([5, 10, 15, 20, 25])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted visits for 6 ads:\", model.predict([[6]])[0])"
  },
  {
    "input": "Use logistic regression to classify email as spam (1) or not (0) based on number of attachments. X = [[0], [1], [2], [3], [4]], y = [0, 0, 1, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[0], [1], [2], [3], [4]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Spam probability with 2 attachments:\", model.predict_proba([[2]])[0,1])"
  },
  {
    "input": "Poisson regression: Predict number of app downloads from ad impressions. X = [[100], [200], [300], [400], [500]], y = [1, 3, 6, 9, 11].",
    "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\n\nX = np.array([[100], [200], [300], [400], [500]])\ny = np.array([1, 3, 6, 9, 11])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Downloads for 350 impressions:\", model.predict([[350]])[0])"
  },
  {
    "input": "Logistic regression: Predict if a loan will default (1) or not (0) using applicant\u2019s credit score. X = [[600], [620], [640], [680], [720]], y = [1, 1, 0, 0, 0].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[600], [620], [640], [680], [720]])\ny = np.array([1, 1, 0, 0, 0])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Default probability at score 660:\", model.predict_proba([[660]])[0,1])"
  },
  {
    "input": "Poisson regression: Predict average purchases per visit from hours spent browsing. X = [[1], [2], [3], [4], [5]], y = [1, 3, 5, 7, 9].",
    "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\n\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([1, 3, 5, 7, 9])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted purchases for 3.5 hours:\", model.predict([[3.5]])[0])"
  },
  {
    "input": "Logistic regression: Predict if user clicks on an ad (1) or not (0) based on scroll depth. X = [[10], [20], [30], [40], [50]], y = [0, 0, 1, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[10], [20], [30], [40], [50]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Click probability at scroll depth 25:\", model.predict_proba([[25]])[0,1])"
  },
  {
    "input": "Poisson regression: Predict number of support tickets filed based on number of users. X = [[100], [200], [300], [400], [500]], y = [1, 2, 3, 5, 8].",
    "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\n\nX = np.array([[100], [200], [300], [400], [500]])\ny = np.array([1, 2, 3, 5, 8])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted tickets for 350 users:\", model.predict([[350]])[0])"
  },
  {
    "input": "Logistic regression: Predict whether an exam is passed (1) or failed (0) using revision hours. X = [[1], [2], [3], [4], [5]], y = [0, 0, 1, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Pass probability at 3.5 hours:\", model.predict_proba([[3.5]])[0,1])"
  },
  {
    "input": "Poisson regression: Predict number of texts sent daily based on age. X = [[18], [22], [26], [30], [34]], y = [50, 45, 40, 30, 20].",
    "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\n\nX = np.array([[18], [22], [26], [30], [34]])\ny = np.array([50, 45, 40, 30, 20])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted texts for age 28:\", model.predict([[28]])[0])"
  },
  {
    "input": "Logistic regression: Predict whether a machine breaks down (1) or not (0) based on load factor. X = [[10], [20], [30], [40], [50]], y = [0, 0, 0, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[10], [20], [30], [40], [50]])\ny = np.array([0, 0, 0, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Breakdown probability at 35:\", model.predict_proba([[35]])[0,1])"
  },
  {
    "input": "Poisson regression: Predict number of likes on a post from number of hashtags. X = [[1], [2], [3], [4], [5]], y = [3, 6, 10, 13, 15].",
    "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\n\nX = np.array([[1], [2], [3], [4], [5]])\ny = np.array([3, 6, 10, 13, 15])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Likes predicted for 6 hashtags:\", model.predict([[6]])[0])"
  },
  {
    "input": "Logistic regression: Predict binary outcome of churn (1) vs retention (0) using number of complaints. X = [[0], [1], [2], [3], [4]], y = [0, 0, 1, 1, 1].",
    "output": "from sklearn.linear_model import LogisticRegression\nimport numpy as np\n\nX = np.array([[0], [1], [2], [3], [4]])\ny = np.array([0, 0, 1, 1, 1])\nmodel = LogisticRegression()\nmodel.fit(X, y)\nprint(\"Churn probability with 2 complaints:\", model.predict_proba([[2]])[0,1])"
  },
  {
    "input": "Poisson regression: Predict number of retweets based on tweet length. X = [[20], [40], [60], [80], [100]], y = [5, 8, 11, 13, 15].",
    "output": "from sklearn.linear_model import PoissonRegressor\nimport numpy as np\n\nX = np.array([[20], [40], [60], [80], [100]])\ny = np.array([5, 8, 11, 13, 15])\nmodel = PoissonRegressor()\nmodel.fit(X, y)\nprint(\"Predicted retweets for 75 chars:\", model.predict([[75]])[0])"
  },
  {
    "input": "Perform a Cholesky decomposition of the matrix A = [[4, 2], [2, 3]].",
    "output": "import numpy as np\nA = np.array([[4, 2], [2, 3]])\nL = np.linalg.cholesky(A)\nprint(\"Cholesky factor L:\\n\", L)"
  },
  {
    "input": "Check if matrix B = [[25, 15, -5], [15, 18, 0], [-5, 0, 11]] can be decomposed using Cholesky method and show the result.",
    "output": "import numpy as np\nB = np.array([[25, 15, -5], [15, 18, 0], [-5, 0, 11]])\nL = np.linalg.cholesky(B)\nprint(\"Cholesky factor L:\\n\", L)"
  },
  {
    "input": "Generate a symmetric positive definite matrix C of size 4x4 and perform Cholesky decomposition.",
    "output": "import numpy as np\nnp.random.seed(0)\nA = np.random.rand(4, 4)\nC = np.dot(A, A.T) + 4*np.eye(4)\nL = np.linalg.cholesky(C)\nprint(\"Symmetric positive definite matrix C:\\n\", C)\nprint(\"Cholesky factor L:\\n\", L)"
  },
  {
    "input": "Use Cholesky decomposition to solve the linear system Ax = b, where A = [[6, 15], [15, 55]], b = [1, 2].",
    "output": "import numpy as np\nA = np.array([[6, 15], [15, 55]])\nb = np.array([1, 2])\nL = np.linalg.cholesky(A)\ny = np.linalg.solve(L, b)\nx = np.linalg.solve(L.T, y)\nprint(\"Solution x:\\n\", x)"
  },
  {
    "input": "Verify that L @ L.T reconstructs the original matrix A = [[9, 3], [3, 5]].",
    "output": "import numpy as np\nA = np.array([[9, 3], [3, 5]])\nL = np.linalg.cholesky(A)\nA_reconstructed = L @ L.T\nprint(\"Reconstructed A:\\n\", A_reconstructed)"
  },
  {
    "input": "Symbolically perform Cholesky decomposition on a 2x2 matrix [[a, b], [b, c]] assuming it is positive definite.",
    "output": "import sympy as sp\na, b, c = sp.symbols('a b c', positive=True)\nA = sp.Matrix([[a, b], [b, c]])\nL = A.cholesky()\nsp.pprint(L)"
  },
  {
    "input": "Construct a block matrix using Cholesky-decomposed submatrices and verify it remains positive definite.",
    "output": "import numpy as np\nA = np.array([[4, 1], [1, 3]])\nB = np.array([[2, 0], [0, 1]])\nblock = np.block([[A, np.zeros((2, 2))], [np.zeros((2, 2)), B]])\nL = np.linalg.cholesky(block)\nprint(\"Block matrix:\\n\", block)\nprint(\"Cholesky factor:\\n\", L)"
  },
  {
    "input": "Find the Cholesky decomposition of the covariance matrix of dataset X = [[2.0, 3.0], [3.0, 4.0], [4.0, 6.0]].",
    "output": "import numpy as np\nX = np.array([[2.0, 3.0], [3.0, 4.0], [4.0, 6.0]])\nCov = np.cov(X.T)\nL = np.linalg.cholesky(Cov)\nprint(\"Covariance matrix:\\n\", Cov)\nprint(\"Cholesky factor:\\n\", L)"
  },
  {
    "input": "Use Cholesky decomposition to simulate samples from a multivariate normal distribution with mean=[0,0] and given covariance matrix.",
    "output": "import numpy as np\n\nmean = np.array([0, 0])\ncov = np.array([[2, 1], [1, 2]])\nL = np.linalg.cholesky(cov)\nsamples = np.random.randn(5, 2) @ L.T + mean\nprint(\"Simulated samples:\\n\", samples)"
  },
  {
    "input": "Given matrix A = [[10, 2, 3], [2, 5, 1], [3, 1, 6]], compute its Cholesky factor and verify the reconstruction.",
    "output": "import numpy as np\nA = np.array([[10, 2, 3], [2, 5, 1], [3, 1, 6]])\nL = np.linalg.cholesky(A)\nA_recon = L @ L.T\nprint(\"Cholesky factor L:\\n\", L)\nprint(\"Reconstructed A:\\n\", A_recon)"
  },
  {
    "input": "Use Cholesky decomposition to compute the inverse of a symmetric positive definite matrix A = [[4, 1], [1, 3]].",
    "output": "import numpy as np\nA = np.array([[4, 1], [1, 3]])\nL = np.linalg.cholesky(A)\ninv_L = np.linalg.inv(L)\ninv_A = inv_L.T @ inv_L\nprint(\"Inverse of A using Cholesky:\\n\", inv_A)"
  },
  {
    "input": "Check whether the matrix A = [[1, 2], [2, 1]] is suitable for Cholesky decomposition. If not, catch the error.",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\ntry:\n    L = np.linalg.cholesky(A)\n    print(\"Cholesky factor:\\n\", L)\nexcept np.linalg.LinAlgError:\n    print(\"Matrix is not positive definite; Cholesky decomposition failed.\")"
  },
  {
    "input": "Use Cholesky decomposition to efficiently solve a least squares problem with A.T @ A where A = [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nb = np.array([1, 2, 3])\nAtA = A.T @ A\nAtb = A.T @ b\nL = np.linalg.cholesky(AtA)\ny = np.linalg.solve(L, Atb)\nx = np.linalg.solve(L.T, y)\nprint(\"Least squares solution using Cholesky:\\n\", x)"
  },
  {
    "input": "Given a symmetric matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]], perform Cholesky decomposition.",
    "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\nL = np.linalg.cholesky(A)\nprint(\"Cholesky factor L:\\n\", L)"
  },
  {
    "input": "Write a function to perform Cholesky decomposition from scratch for a 3x3 matrix.",
    "output": "import numpy as np\n\ndef cholesky_manual(A):\n    n = A.shape[0]\n    L = np.zeros_like(A)\n    for i in range(n):\n        for j in range(i+1):\n            temp_sum = np.dot(L[i,:j], L[j,:j])\n            if i == j:\n                L[i,j] = np.sqrt(A[i,i] - temp_sum)\n            else:\n                L[i,j] = (A[i,j] - temp_sum) / L[j,j]\n    return L\n\nA = np.array([[4, 2, 2], [2, 2, 1], [2, 1, 3]])\nL = cholesky_manual(A)\nprint(\"Manual Cholesky factor:\\n\", L)"
  },
  {
    "input": "Perform Cholesky decomposition symbolically on a 3x3 matrix with symbolic entries and positive definiteness assumption.",
    "output": "import sympy as sp\na, b, c, d, e, f = sp.symbols('a b c d e f', positive=True)\nA = sp.Matrix([[a, b, c], [b, d, e], [c, e, f]])\nL = A.cholesky()\nsp.pprint(L)"
  },
  {
    "input": "Show that Cholesky decomposition fails for a non-symmetric matrix A = [[1, 2], [3, 4]].",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ntry:\n    L = np.linalg.cholesky(A)\n    print(\"Cholesky factor:\\n\", L)\nexcept np.linalg.LinAlgError:\n    print(\"Matrix is not symmetric positive definite.\")"
  },
  {
    "input": "Use Cholesky decomposition to precondition a system Ax = b for faster CG convergence, A = [[6, 2], [2, 5]], b = [2, 1].",
    "output": "import numpy as np\nfrom scipy.sparse.linalg import cg\nA = np.array([[6, 2], [2, 5]])\nb = np.array([2, 1])\nL = np.linalg.cholesky(A)\nM_inv = np.linalg.inv(L).T @ np.linalg.inv(L)\nx, _ = cg(A, b, M=M_inv)\nprint(\"Preconditioned CG solution:\\n\", x)"
  },
  {
    "input": "Decompose matrix A = [[2, 1], [1, 2]] and verify each entry of L manually matches formula.",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\nL = np.linalg.cholesky(A)\nprint(\"L[0,0] = sqrt(2):\", np.sqrt(2))\nprint(\"L[1,0] = 1/sqrt(2):\", 1/np.sqrt(2))\nprint(\"L[1,1] = sqrt(2 - (1/sqrt(2))^2):\", np.sqrt(2 - (1/np.sqrt(2))**2))\nprint(\"Computed L:\\n\", L)"
  },
  {
    "input": "Generate a 5x5 positive definite matrix with random entries and compute its Cholesky factor.",
    "output": "import numpy as np\nnp.random.seed(1)\nA = np.random.randn(5, 5)\nA = A @ A.T + 5*np.eye(5)\nL = np.linalg.cholesky(A)\nprint(\"Cholesky factor L:\\n\", L)"
  },
  {
    "input": "Use Cholesky to solve a real-world linear regression problem: Fit y = Xw using normal equations with decomposition.",
    "output": "import numpy as np\nX = np.array([[1, 1], [1, 2], [1, 3]])\ny = np.array([1, 2, 2.5])\nXtX = X.T @ X\nXty = X.T @ y\nL = np.linalg.cholesky(XtX)\nz = np.linalg.solve(L, Xty)\nw = np.linalg.solve(L.T, z)\nprint(\"Regression weights using Cholesky:\\n\", w)"
  },
  {
    "input": "Check numerically if a matrix is suitable for Cholesky by confirming symmetry and all positive eigenvalues.",
    "output": "import numpy as np\nA = np.array([[5, 2], [2, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint(\"Is symmetric:\", np.allclose(A, A.T))\nprint(\"Positive eigenvalues:\", eigenvalues > 0)\nprint(\"Suitable for Cholesky:\", np.allclose(A, A.T) and np.all(eigenvalues > 0))"
  },
  {
    "input": "For matrix A = [[10, 2], [2, 2]], test Cholesky decomposition, then regularize it slightly if it fails.",
    "output": "import numpy as np\nA = np.array([[10, 2], [2, 2]])\ntry:\n    L = np.linalg.cholesky(A)\nexcept np.linalg.LinAlgError:\n    A += 1e-4 * np.eye(2)\n    L = np.linalg.cholesky(A)\nprint(\"Regularized matrix:\\n\", A)\nprint(\"Cholesky factor:\\n\", L)"
  },
  {
    "input": "Use Factor Analysis to reduce a dataset X of 4D features into 2 latent factors. X = [[2.5, 0.5, 2.2, 1.9], [1.9, 1.1, 2.3, 2.1], [3.1, 0.7, 2.9, 1.8]]",
    "output": "from sklearn.decomposition import FactorAnalysis\nimport numpy as np\nX = np.array([[2.5, 0.5, 2.2, 1.9], [1.9, 1.1, 2.3, 2.1], [3.1, 0.7, 2.9, 1.8]])\nfa = FactorAnalysis(n_components=2)\nX_reduced = fa.fit_transform(X)\nprint(\"Reduced representation (Factor Analysis):\\n\", X_reduced)"
  },
  {
    "input": "Apply NMF on a non-negative matrix X = [[1, 2], [3, 4], [5, 6]] and reduce it to 2 components.",
    "output": "from sklearn.decomposition import NMF\nimport numpy as np\nX = np.array([[1, 2], [3, 4], [5, 6]])\nnmf = NMF(n_components=2, init='random', random_state=0)\nW = nmf.fit_transform(X)\nH = nmf.components_\nprint(\"W (document-topic matrix):\\n\", W)\nprint(\"H (topic-word matrix):\\n\", H)"
  },
  {
    "input": "Simulate ICE plots for a linear regression model predicting house prices from features [[1200, 3], [1500, 4], [1700, 3]] using feature 0 (sqft).",
    "output": "from sklearn.linear_model import LinearRegression\nfrom sklearn.inspection import PartialDependenceDisplay\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nX = np.array([[1200, 3], [1500, 4], [1700, 3]])\ny = np.array([200, 250, 280])\nmodel = LinearRegression().fit(X, y)\n\nfig, ax = plt.subplots()\nPartialDependenceDisplay.from_estimator(model, X, features=[0], kind='individual', ax=ax)\nplt.title(\"ICE plot for Square Footage\")\nplt.show()"
  },
  {
    "input": "Reduce a 5D dataset to 3 latent variables using Factor Analysis. X = random 100x5 matrix.",
    "output": "from sklearn.decomposition import FactorAnalysis\nimport numpy as np\nX = np.random.rand(100, 5)\nfa = FactorAnalysis(n_components=3)\nX_latent = fa.fit_transform(X)\nprint(\"Latent 3D representation:\\n\", X_latent[:5])"
  },
  {
    "input": "Generate synthetic non-negative data and apply NMF to find latent topics. Use sklearn.datasets.make_multilabel_classification.",
    "output": "from sklearn.datasets import make_multilabel_classification\nfrom sklearn.decomposition import NMF\nX, _ = make_multilabel_classification(n_samples=50, n_features=10, random_state=0)\nnmf = NMF(n_components=4)\nW = nmf.fit_transform(X)\nprint(\"Latent features using NMF:\\n\", W[:5])"
  },
  {
    "input": "Compare the reconstruction quality between original and reduced data from Factor Analysis on a 50x6 dataset.",
    "output": "import numpy as np\nfrom sklearn.decomposition import FactorAnalysis\nX = np.random.randn(50, 6)\nfa = FactorAnalysis(n_components=3)\nX_reduced = fa.fit_transform(X)\nX_reconstructed = X_reduced @ fa.components_ + fa.mean_\nerror = np.mean((X - X_reconstructed)**2)\nprint(\"Reconstruction MSE:\", error)"
  },
  {
    "input": "Use NMF for image compression on a synthetic grayscale image matrix.",
    "output": "import numpy as np\nfrom sklearn.decomposition import NMF\nnp.random.seed(0)\nimage = np.abs(np.random.randn(20, 20))\nnmf = NMF(n_components=5)\nW = nmf.fit_transform(image)\nH = nmf.components_\nreconstructed = W @ H\nprint(\"Reconstructed image shape:\", reconstructed.shape)"
  },
  {
    "input": "Use ICE plots to show individual effects of 'Age' on a decision tree trained on synthetic medical dataset.",
    "output": "from sklearn.tree import DecisionTreeRegressor\nfrom sklearn.inspection import PartialDependenceDisplay\nimport matplotlib.pyplot as plt\nimport numpy as np\nX = np.random.rand(100, 3)*100\ny = X[:, 0] * 2 + np.random.randn(100)*10\nmodel = DecisionTreeRegressor().fit(X, y)\nPartialDependenceDisplay.from_estimator(model, X, features=[0], kind='individual')\nplt.title(\"ICE Plot for Age Feature\")\nplt.show()"
  },
  {
    "input": "Apply Factor Analysis to financial data (mock data) to identify underlying market factors.",
    "output": "import numpy as np\nfrom sklearn.decomposition import FactorAnalysis\nreturns = np.random.randn(100, 5)\nfa = FactorAnalysis(n_components=2)\nfactors = fa.fit_transform(returns)\nprint(\"Market factors extracted:\\n\", factors[:5])"
  },
  {
    "input": "Decompose a document-term matrix using NMF to identify topics. Use random integers between 0-3 for matrix values.",
    "output": "import numpy as np\nfrom sklearn.decomposition import NMF\nX = np.random.randint(0, 4, (10, 6))\nnmf = NMF(n_components=2, init='random', random_state=42)\nW = nmf.fit_transform(X)\nprint(\"Topic vectors:\\n\", W)"
  },
  {
    "input": "Use ICE plot on a Ridge regression model trained on diabetes dataset from sklearn.",
    "output": "from sklearn.datasets import load_diabetes\nfrom sklearn.linear_model import Ridge\nfrom sklearn.inspection import PartialDependenceDisplay\nimport matplotlib.pyplot as plt\nX, y = load_diabetes(return_X_y=True)\nmodel = Ridge().fit(X, y)\nPartialDependenceDisplay.from_estimator(model, X, [0], kind='individual')\nplt.title(\"ICE Plot on Feature 0\")\nplt.show()"
  },
  {
    "input": "Perform Factor Analysis and compare with PCA for the same 5D dataset.",
    "output": "import numpy as np\nfrom sklearn.decomposition import PCA, FactorAnalysis\nX = np.random.randn(100, 5)\npca = PCA(n_components=2)\nfa = FactorAnalysis(n_components=2)\nX_pca = pca.fit_transform(X)\nX_fa = fa.fit_transform(X)\nprint(\"PCA Result:\\n\", X_pca[:3])\nprint(\"Factor Analysis Result:\\n\", X_fa[:3])"
  },
  {
    "input": "Use NMF to separate signals in a dataset where X = V1 + V2 with mixed components.",
    "output": "from sklearn.decomposition import NMF\nimport numpy as np\nV = np.abs(np.random.randn(10, 5))\nnmf = NMF(n_components=2)\nW = nmf.fit_transform(V)\nH = nmf.components_\nprint(\"Separated components:\\n\", W @ H)"
  },
  {
    "input": "Simulate ICE curves on a Random Forest Regressor predicting CO2 emissions from engine size and weight.",
    "output": "from sklearn.ensemble import RandomForestRegressor\nfrom sklearn.inspection import PartialDependenceDisplay\nimport numpy as np\nimport matplotlib.pyplot as plt\nX = np.random.rand(100, 2)*100\ny = 0.5 * X[:,0] + 0.3 * X[:,1] + np.random.randn(100)*5\nmodel = RandomForestRegressor().fit(X, y)\nPartialDependenceDisplay.from_estimator(model, X, features=[0], kind='individual')\nplt.title(\"ICE: Engine Size vs CO2\")\nplt.show()"
  },
  {
    "input": "Apply NMF on a music spectrogram (simulated matrix) to separate sources.",
    "output": "import numpy as np\nfrom sklearn.decomposition import NMF\nnp.random.seed(0)\nspectrogram = np.abs(np.random.randn(50, 20))\nnmf = NMF(n_components=3)\nW = nmf.fit_transform(spectrogram)\nprint(\"Decomposed components (sources):\\n\", W[:5])"
  },
  {
    "input": "Use Factor Analysis to denoise data with 10 noisy dimensions.",
    "output": "from sklearn.decomposition import FactorAnalysis\nimport numpy as np\nX = np.random.randn(100, 10) + 0.3*np.random.randn(100, 10)\nfa = FactorAnalysis(n_components=3)\nX_clean = fa.fit_transform(X)\nprint(\"Denoised representation:\\n\", X_clean[:5])"
  },
  {
    "input": "Generate ICE plot to visualize feature interaction on a GradientBoostingRegressor.",
    "output": "from sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.inspection import PartialDependenceDisplay\nimport numpy as np\nimport matplotlib.pyplot as plt\nX = np.random.rand(100, 3)\ny = 5 * X[:,0] + 2 * X[:,1] + np.random.randn(100)\nmodel = GradientBoostingRegressor().fit(X, y)\nPartialDependenceDisplay.from_estimator(model, X, features=[0], kind='individual')\nplt.title(\"ICE Plot for Feature 0\")\nplt.show()"
  },
  {
    "input": "Perform NMF on a matrix and compute reconstruction error.",
    "output": "import numpy as np\nfrom sklearn.decomposition import NMF\nX = np.abs(np.random.randn(10, 5))\nnmf = NMF(n_components=2)\nW = nmf.fit_transform(X)\nH = nmf.components_\nreconstruction = W @ H\nerror = np.linalg.norm(X - reconstruction)\nprint(\"Reconstruction error:\", error)"
  },
  {
    "input": "Train a Ridge model and visualize the ICE plot on a single feature with strong nonlinearity.",
    "output": "from sklearn.linear_model import Ridge\nfrom sklearn.inspection import PartialDependenceDisplay\nimport numpy as np\nimport matplotlib.pyplot as plt\nX = np.random.rand(100, 1)*10\ny = X[:,0]**2 + np.random.randn(100)\nmodel = Ridge().fit(X, y)\nPartialDependenceDisplay.from_estimator(model, X, features=[0], kind='individual')\nplt.title(\"ICE Plot for Nonlinear Feature\")\nplt.show()"
  },
  {
    "input": "Compare ICE plots of two different models trained on the same dataset (linear vs nonlinear).",
    "output": "from sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.inspection import PartialDependenceDisplay\nimport matplotlib.pyplot as plt\nimport numpy as np\nX = np.random.rand(100, 1)*10\ny = X[:,0]**2 + np.random.randn(100)\nmodels = [LinearRegression(), RandomForestRegressor()]\nfor model in models:\n    model.fit(X, y)\n    PartialDependenceDisplay.from_estimator(model, X, features=[0], kind='individual')\n    plt.title(f\"ICE Plot - {type(model).__name__}\")\n    plt.show()"
  },
  {
    "input": "Apply NMF with sparse output on document-term matrix using l1_ratio.",
    "output": "from sklearn.decomposition import NMF\nimport numpy as np\nX = np.random.randint(0, 4, (10, 6))\nnmf = NMF(n_components=2, l1_ratio=0.9)\nW = nmf.fit_transform(X)\nprint(\"Sparse NMF components:\\n\", W)"
  },
  {
    "input": "Perform factor analysis on a dataset and print both latent representation and loading matrix.",
    "output": "import numpy as np\nfrom sklearn.decomposition import FactorAnalysis\nX = np.random.randn(100, 6)\nfa = FactorAnalysis(n_components=3)\nZ = fa.fit_transform(X)\nprint(\"Latent representation:\\n\", Z[:5])\nprint(\"Factor loadings:\\n\", fa.components_)"
  },
  {
    "input": "Simulate ICE plots on a simple decision stump model to show sharp local effects.",
    "output": "from sklearn.tree import DecisionTreeRegressor\nfrom sklearn.inspection import PartialDependenceDisplay\nimport matplotlib.pyplot as plt\nimport numpy as np\nX = np.linspace(0, 10, 100).reshape(-1, 1)\ny = (X[:,0] > 5).astype(float)\nmodel = DecisionTreeRegressor(max_depth=1).fit(X, y)\nPartialDependenceDisplay.from_estimator(model, X, [0], kind='individual')\nplt.title(\"ICE - Decision Stump\")\nplt.show()"
  },
  {
    "input": "Use NMF on a large sparse matrix and visualize the compressed topic matrix.",
    "output": "from sklearn.decomposition import NMF\nimport numpy as np\nX = np.random.poisson(1.0, (100, 50))\nnmf = NMF(n_components=5)\nW = nmf.fit_transform(X)\nprint(\"Topic space representation:\\n\", W[:5])"
  },
  {
    "input": "Solve the system of equations using Gaussian elimination:\n2x + 3y - z = 5\n4x + y + 2z = 6\n-x + 2y + 3z = 4",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[2, 3, -1],\n              [4, 1,  2],\n              [-1, 2, 3]])\nb = np.array([5, 6, 4])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Determine if the following system has a unique solution, no solution, or infinitely many solutions:\nx + y + z = 3\n2x + 2y + 2z = 6\n3x + 3y + 3z = 9",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[1, 1, 1],\n              [2, 2, 2],\n              [3, 3, 3]])\nb = np.array([3, 6, 9])\n\nrank_A = matrix_rank(A)\naugmented = np.column_stack((A, b))\nrank_aug = matrix_rank(augmented)\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Use Gaussian elimination to solve:\nx - y + 2z = 4\n3x + 2y - z = 1\n2x - 3y + 3z = 5",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, -1, 2],\n              [3, 2, -1],\n              [2, -3, 3]])\nb = np.array([4, 1, 5])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system using Gaussian elimination:\n3x + 2y = 12\n6x + 4y = 24",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[3, 2],\n              [6, 4]])\nb = np.array([12, 24])\n\nrank_A = matrix_rank(A)\naugmented = np.column_stack((A, b))\nrank_aug = matrix_rank(augmented)\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Find the solution to the system:\nx + 2y - z = 1\n2x - y + 3z = 5\n-x + 3y + 2z = 4",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, 2, -1],\n              [2, -1, 3],\n              [-1, 3, 2]])\nb = np.array([1, 5, 4])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Determine the number of solutions for the system:\n2x - y = 3\n4x - 2y = 6",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[2, -1],\n              [4, -2]])\nb = np.array([3, 6])\n\nrank_A = matrix_rank(A)\nrank_aug = matrix_rank(np.column_stack((A, b)))\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Solve using Gaussian elimination:\nx + y + z = 6\n2x - y + 3z = 14\n3x + 4y - 2z = -2",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, 1, 1],\n              [2, -1, 3],\n              [3, 4, -2]])\nb = np.array([6, 14, -2])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination to find the solution:\n2x + 3y = 8\n4x + 6y = 16",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[2, 3],\n              [4, 6]])\nb = np.array([8, 16])\n\nrank_A = matrix_rank(A)\nrank_aug = matrix_rank(np.column_stack((A, b)))\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Solve the system:\nx - 2y + z = 0\n3x + y - 4z = 5\n2x + 3y + 3z = 10",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, -2, 1],\n              [3, 1, -4],\n              [2, 3, 3]])\nb = np.array([0, 5, 10])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Determine if the system has a unique solution:\nx + 2y = 5\n2x + 4y = 10",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[1, 2],\n              [2, 4]])\nb = np.array([5, 10])\n\nrank_A = matrix_rank(A)\nrank_aug = matrix_rank(np.column_stack((A, b)))\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Solve the system using Gaussian elimination:\n2x + y - z = 1\n-3x - y + 2z = -4\n-2x + y + 2z = -3",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[2, 1, -1],\n              [-3, -1, 2],\n              [-2, 1, 2]])\nb = np.array([1, -4, -3])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Determine the solution to:\nx + y + z = 3\nx + 2y + 3z = 4\nx + 4y + 9z = 10",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, 1, 1],\n              [1, 2, 3],\n              [1, 4, 9]])\nb = np.array([3, 4, 10])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve:\n2x + 3y + z = 1\n4x + y - z = 2\n-2x + y + 3z = 3",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[2, 3, 1],\n              [4, 1, -1],\n              [-2, 1, 3]])\nb = np.array([1, 2, 3])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system of equations:\nx + y + z = 6\nx - y + z = 2\n2x + y - z = 2",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, 1, 1],\n              [1, -1, 1],\n              [2, 1, -1]])\nb = np.array([6, 2, 2])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Determine if the system has a solution:\nx + y + z = 3\n2x + 2y + 2z = 6\nx + y + z = 4",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[1, 1, 1],\n              [2, 2, 2],\n              [1, 1, 1]])\nb = np.array([3, 6, 4])\n\nrank_A = matrix_rank(A)\nrank_aug = matrix_rank(np.column_stack((A, b)))\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Use Gaussian elimination to solve:\nx + y + z = 1\nx + 2y + 3z = 4\nx + 4y + 9z = 10",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, 1, 1],\n              [1, 2, 3],\n              [1, 4, 9]])\nb = np.array([1, 4, 10])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system:\nx + y + z = 3\nx - y + z = 1\n2x + y - z = 2",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, 1, 1],\n              [1, -1, 1],\n              [2, 1, -1]])\nb = np.array([3, 1, 2])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve:\nx + 2y = 6\n2x + 4y = 12",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[1, 2],\n              [2, 4]])\nb = np.array([6, 12])\n\nrank_A = matrix_rank(A)\nrank_aug = matrix_rank(np.column_stack((A, b)))\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Solve the system:\nx + y + z = 3\n2x + 3y + z = 7\nx + 4y + 2z = 9",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, 1, 1],\n              [2, 3, 1],\n              [1, 4, 2]])\nb = np.array([3, 7, 9])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve:\nx - 2y + z = -3\n2x + 3y + 4z = 8\n3x - y + z = 2",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, -2, 1],\n              [2, 3, 4],\n              [3, -1, 1]])\nb = np.array([-3, 8, 2])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system:\nx + y + z = 0\n2x + 2y + 2z = 0\n3x + 3y + 3z = 0",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[1, 1, 1],\n              [2, 2, 2],\n              [3, 3, 3]])\nb = np.array([0, 0, 0])\n\nrank_A = matrix_rank(A)\nrank_aug = matrix_rank(np.column_stack((A, b)))\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Solve the following:\nx - y + z = 0\ny - z = 0\nx + y + z = 6",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, -1, 1],\n              [0, 1, -1],\n              [1, 1, 1]])\nb = np.array([0, 0, 6])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve:\nx + y + z = 4\n2x + y - z = 1\n3x + 2y + z = 9",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, 1, 1],\n              [2, 1, -1],\n              [3, 2, 1]])\nb = np.array([4, 1, 9])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n3x + 2y = 12\n6x + 4y = 24",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[3, 2],\n              [6, 4]])\nb = np.array([12, 24])\n\nrank_A = matrix_rank(A)\nrank_aug = matrix_rank(np.column_stack((A, b)))\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Solve:\nx - y = 2\n2x - 2y = 4\n3x - 3y = 6",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[1, -1],\n              [2, -2],\n              [3, -3]])\nb = np.array([2, 4, 6])\n\nrank_A = matrix_rank(A)\nrank_aug = matrix_rank(np.column_stack((A, b)))\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Solve the system:\n3x - y + 2z = 5\n2x + 4y - 3z = -6\nx + y + z = 4",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[3, -1, 2],\n              [2, 4, -3],\n              [1, 1, 1]])\nb = np.array([5, -6, 4])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Find the solution:\n4x + 2y + z = 9\n3x - y + z = 4\nx + y - z = 1",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[4, 2, 1],\n              [3, -1, 1],\n              [1, 1, -1]])\nb = np.array([9, 4, 1])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Determine the solution set:\n2x + 3y + z = 1\nx - y + 2z = 3\n3x + 2y + 4z = 7",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[2, 3, 1],\n              [1, -1, 2],\n              [3, 2, 4]])\nb = np.array([1, 3, 7])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n3x + y - z = 2\n2x - 2y + 4z = -2\n-x + 0.5y - z = 0",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[3, 1, -1],\n              [2, -2, 4],\n              [-1, 0.5, -1]])\nb = np.array([2, -2, 0])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve:\n2x + y - z = 8\n-3x - y + 2z = -11\n-2x + y + 2z = -3",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[2, 1, -1],\n              [-3, -1, 2],\n              [-2, 1, 2]])\nb = np.array([8, -11, -3])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the linear system:\nx + 2y + 3z = 10\n2x + 3y + z = 8\n3x + y + 2z = 11",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, 2, 3],\n              [2, 3, 1],\n              [3, 1, 2]])\nb = np.array([10, 8, 11])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using Gaussian elimination:\n2x - y + z = 3\nx + y - z = 0\nx - 2y + 3z = -10",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[2, -1, 1],\n              [1, 1, -1],\n              [1, -2, 3]])\nb = np.array([3, 0, -10])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve this system:\n3x + 4y - 5z = 6\n2x - y + 2z = -1\n5x + 3y + z = 4",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[3, 4, -5],\n              [2, -1, 2],\n              [5, 3, 1]])\nb = np.array([6, -1, 4])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Find x, y, z from:\n4x + y + z = 7\nx + 3y + z = 6\nx + y + 5z = 9",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[4, 1, 1],\n              [1, 3, 1],\n              [1, 1, 5]])\nb = np.array([7, 6, 9])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve:\n2x - y = 1\n-4x + 2y = -2\n6x - 3y = 3",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[2, -1],\n              [-4, 2],\n              [6, -3]])\nb = np.array([1, -2, 3])\n\nrank_A = matrix_rank(A)\nrank_aug = matrix_rank(np.column_stack((A, b)))\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Solve using Gaussian elimination:\n5x + y + z = 10\nx + 3y + z = 8\nx + y + 4z = 9",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[5, 1, 1],\n              [1, 3, 1],\n              [1, 1, 4]])\nb = np.array([10, 8, 9])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Find the solution:\n3x + 2y + z = 1\n2x + 3y + 2z = 2\nx + 4y + 3z = 3",
    "output": "import numpy as np\n\nA = np.array([[3, 2, 1],\n              [2, 3, 2],\n              [1, 4, 3]])\nb = np.array([1, 2, 3])\n\nx, residuals, rank, s = np.linalg.lstsq(A, b, rcond=None)\nprint(x)"
  },
  {
    "input": "Solve:\nx + 2y + z = 7\n2x + 5y + z = 18\n3x + 6y + 2z = 25",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[1, 2, 1],\n              [2, 5, 1],\n              [3, 6, 2]])\nb = np.array([7, 18, 25])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n4x + 2y = 10\n2x + y = 5",
    "output": "import numpy as np\n\n# Augmented matrix\nA = np.array([[4.0, 2.0, 10.0],\n              [2.0, 1.0, 5.0]])\n\n# Step 1: Make leading coefficient of first row = 1\nA[0] = A[0] / A[0][0]\n\n# Step 2: Eliminate x from second row\nA[1] = A[1] - A[1][0] * A[0]\n\n# Step 3: Make leading coefficient of second row = 1\nA[1] = A[1] / A[1][1]\n\n# Step 4: Back substitution to eliminate y from first row\nA[0] = A[0] - A[0][1] * A[1]\n\n# Final solution\nx = A[:, 2]\nprint(x)"
  },
  {
    "input": "Determine if the system has a unique solution:\nx + y + z = 1\nx - y + z = 0\n2x + 2z = 2",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 1],\n              [1, -1, 1],\n              [2, 0, 2]])\nb = np.array([1, 0, 2])\n\nrank_A = np.linalg.matrix_rank(A)\naugmented = np.column_stack((A, b))\nrank_augmented = np.linalg.matrix_rank(augmented)\n\nif rank_A != rank_augmented:\n    print(\"The system has no solution.\")\nelif rank_A < A.shape[1]:\n    print(\"The system has infinitely many solutions.\")\nelse:\n    x = np.linalg.solve(A, b)\n    print(\"The system has a unique solution:\", x)"
  },
  {
    "input": "Solve the system:\n2x + 4y + z = 5\nx + 3y + 2z = 6\n3x + y + z = 4",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[2, 4, 1],\n              [1, 3, 2],\n              [3, 1, 1]])\nb = np.array([5, 6, 4])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using Gaussian elimination:\n2x - y + 3z = 7\n4x + y - z = 1\n3x + 2y + z = 10",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[2, -1, 3],\n              [4, 1, -1],\n              [3, 2, 1]])\nb = np.array([7, 1, 10])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Find the solution to:\nx + 2y = 4\n2x + 4y = 8",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\n\nA = np.array([[1, 2],\n              [2, 4]])\nb = np.array([4, 8])\n\nrank_A = matrix_rank(A)\nrank_aug = matrix_rank(np.column_stack((A, b)))\n\nif rank_A == rank_aug:\n    if rank_A == A.shape[1]:\n        print(\"Unique solution\")\n    else:\n        print(\"Infinitely many solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Solve this system:\n3x + 4y + 2z = 14\n2x + y + z = 8\nx + 2y + 3z = 11",
    "output": "import numpy as np\nfrom numpy.linalg import solve\n\nA = np.array([[3, 4, 2],\n              [2, 1, 1],\n              [1, 2, 3]])\nb = np.array([14, 8, 11])\n\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system using Gaussian elimination:\n2x + 3y = 5\n4x + 6y = 10",
    "output": "import numpy as np\nA = np.array([[2, 3], [4, 6]])\nb = np.array([5, 10])\ntry:\n    x = np.linalg.solve(A, b)\n    print(x)\nexcept np.linalg.LinAlgError:\n    print('No unique solution')"
  },
  {
    "input": "Use Cramer's Rule to solve:\nx + 2y = 3\n3x - y = 2",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, -1]])\nb = np.array([3, 2])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    A1 = A.copy()\n    A1[:, 0] = b\n    A2 = A.copy()\n    A2[:, 1] = b\n    x = np.linalg.det(A1) / det_A\n    y = np.linalg.det(A2) / det_A\n    print([x, y])"
  },
  {
    "input": "Solve using matrix inversion:\n2x + y = 5\nx - 3y = -4",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, -3]])\nb = np.array([5, -4])\ntry:\n    x = np.linalg.inv(A).dot(b)\n    print(x)\nexcept np.linalg.LinAlgError:\n    print('Matrix is singular')"
  },
  {
    "input": "Solve the system using NumPy:\n3x - y + z = 2\n2x + 4y - 3z = -2\nx - y + 2z = 3",
    "output": "import numpy as np\nA = np.array([[3, -1, 1], [2, 4, -3], [1, -1, 2]])\nb = np.array([2, -2, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n2x - y + 3z = 7\nx + 4y - z = -1\n3x + y + 2z = 5",
    "output": "import numpy as np\nA = np.array([[2, -1, 3], [1, 4, -1], [3, 1, 2]])\nb = np.array([7, -1, 5])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x_vals = []\n    for i in range(3):\n        Ai = A.copy()\n        Ai[:, i] = b\n        x_vals.append(np.linalg.det(Ai) / det_A)\n    print(x_vals)"
  },
  {
    "input": "Determine if the system has a unique solution:\nx + y + z = 6\nx - y + z = 2\nx + y - z = 0",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, -1, 1], [1, 1, -1]])\nb = np.array([6, 2, 0])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x = np.linalg.solve(A, b)\n    print(x)"
  },
  {
    "input": "Solve the system:\n3x + 4y = 10\n5x + 6y = 16",
    "output": "import numpy as np\nA = np.array([[3, 4], [5, 6]])\nb = np.array([10, 16])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule:\nx + y + z = 6\n2x + 3y + 4z = 14\n3x + 4y + 5z = 20",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, 3, 4], [3, 4, 5]])\nb = np.array([6, 14, 20])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x_vals = []\n    for i in range(3):\n        Ai = A.copy()\n        Ai[:, i] = b\n        x_vals.append(np.linalg.det(Ai) / det_A)\n    print(x_vals)"
  },
  {
    "input": "Solve using Gaussian elimination:\n4x - y + 2z = 9\n3x + 2y - z = 4\n2x - 3y + 4z = 7",
    "output": "import numpy as np\nfrom scipy.linalg import solve\nA = np.array([[4, -1, 2], [3, 2, -1], [2, -3, 4]])\nb = np.array([9, 4, 7])\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix inverse:\n2x + 3y = 8\n4x + 5y = 16",
    "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nb = np.array([8, 16])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve the system:\nx + y + z = 3\nx + 2y + 3z = 6\nx + 4y + 9z = 10",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 2, 3], [1, 4, 9]])\nb = np.array([3, 6, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination:\nx + 2y + z = 7\n2x + 5y + z = 18\n3x + 6y + 2z = 25",
    "output": "import numpy as np\nA = np.array([[1, 2, 1], [2, 5, 1], [3, 6, 2]])\nb = np.array([7, 18, 25])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule:\nx + 3y - z = 5\n2x - y + 4z = 6\n-x + y + z = 1",
    "output": "import numpy as np\nA = np.array([[1, 3, -1], [2, -1, 4], [-1, 1, 1]])\nb = np.array([5, 6, 1])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x_vals = []\n    for i in range(3):\n        Ai = A.copy()\n        Ai[:, i] = b\n        x_vals.append(np.linalg.det(Ai) / det_A)\n    print(x_vals)"
  },
  {
    "input": "Solve the system:\nx - y + z = 1\n2x + 3y - z = 4\nx + y + z = 6",
    "output": "import numpy as np\nA = np.array([[1, -1, 1], [2, 3, -1], [1, 1, 1]])\nb = np.array([1, 4, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix method:\nx + y = 2\n2x + 2y = 5",
    "output": "import numpy as np\nA = np.array([[1, 1], [2, 2]])\nb = np.array([2, 5])\ntry:\n    x = np.linalg.solve(A, b)\n    print(x)\nexcept np.linalg.LinAlgError:\n    print('No solution')"
  },
  {
    "input": "Use Gaussian elimination to solve:\n2x - y + 3z = 7\n4x + y - z = 1\n3x + 2y + z = 10",
    "output": "import numpy as np\nA = np.array([[2, -1, 3], [4, 1, -1], [3, 2, 1]])\nb = np.array([7, 1, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using matrix inversion:\nx + 2y = 4\n3x + 4y = 10",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nb = np.array([4, 10])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve the system:\n2x + y + z = 5\n4x + 3y + 5z = 13\n-2x + y + 2z = 3",
    "output": "import numpy as np\nA = np.array([[2, 1, 1], [4, 3, 5], [-2, 1, 2]])\nb = np.array([5, 13, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve:\nx + 2y - z = 3\n3x - y + 2z = 4\n2x + y + z = 5",
    "output": "import numpy as np\nA = np.array([[1, 2, -1], [3, -1, 2], [2, 1, 1]])\nb = np.array([3, 4, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination:\nx + y + z = 4\n2x + 2y + 2z = 8\n3x + 3y + 3z = 12",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])\nb = np.array([4, 8, 12])\ntry:\n    x = np.linalg.solve(A, b)\n    print(x)\nexcept np.linalg.LinAlgError:\n    print('No unique solution')"
  },
  {
    "input": "Solve the system using numpy:\n3x + 4y + 2z = 14\n2x + y + z = 8\nx + 2y + 3z = 11",
    "output": "import numpy as np\nA = np.array([[3, 4, 2], [2, 1, 1], [1, 2, 3]])\nb = np.array([14, 8, 11])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule to solve:\nx - 2y = 4\n3x + y = 7",
    "output": "import numpy as np\nA = np.array([[1, -2], [3, 1]])\nb = np.array([4, 7])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    A1 = A.copy()\n    A1[:, 0] = b\n    A2 = A.copy()\n    A2[:, 1] = b\n    x = np.linalg.det(A1) / det_A\n    y = np.linalg.det(A2) / det_A\n    print([x, y])"
  },
  {
    "input": "Solve using Gaussian elimination:\nx + y + z = 3\n2x + 3y + 5z = 8\n4x + 5y + 6z = 12",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, 3, 5], [4, 5, 6]])\nb = np.array([3, 8, 12])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix inverse method to solve:\nx + 4y = 9\n2x + 3y = 8",
    "output": "import numpy as np\nA = np.array([[1, 4], [2, 3]])\nb = np.array([9, 8])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve the system using Gaussian elimination:\n3x + 2y + z = 1\n2x + 3y + 2z = 4\nx + y + z = 2",
    "output": "import numpy as np\nA = np.array([[3, 2, 1], [2, 3, 2], [1, 1, 1]])\nb = np.array([1, 4, 2])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix inverse method to solve:\n2x + y = 3\n5x + 4y = 8",
    "output": "import numpy as np\nA = np.array([[2, 1], [5, 4]])\nb = np.array([3, 8])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve using NumPy:\nx + y + z = 6\nx - y + z = 2\nx + y - z = 0",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, -1, 1], [1, 1, -1]])\nb = np.array([6, 2, 0])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n2x + 3y + z = 1\n4x + 5y + 3z = 3\n6x + 7y + 5z = 5",
    "output": "import numpy as np\nA = np.array([[2, 3, 1], [4, 5, 3], [6, 7, 5]])\nb = np.array([1, 3, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system:\n3x + y = 5\nx + 2y = 4",
    "output": "import numpy as np\nA = np.array([[3, 1], [1, 2]])\nb = np.array([5, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule:\n4x + 5y = 9\n6x + 7y = 13",
    "output": "import numpy as np\nA = np.array([[4, 5], [6, 7]])\nb = np.array([9, 13])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    A1 = A.copy()\n    A1[:, 0] = b\n    A2 = A.copy()\n    A2[:, 1] = b\n    x = np.linalg.det(A1) / det_A\n    y = np.linalg.det(A2) / det_A\n    print([x, y])"
  },
  {
    "input": "Solve the system using numpy:\n2x + 3y - z = 1\nx - y + z = 2\n3x + 4y + 2z = 5",
    "output": "import numpy as np\nA = np.array([[2, 3, -1], [1, -1, 1], [3, 4, 2]])\nb = np.array([1, 2, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix inverse to solve:\nx - 2y + 3z = 1\n2x + y + z = 4\n4x - y + z = 2",
    "output": "import numpy as np\nA = np.array([[1, -2, 3], [2, 1, 1], [4, -1, 1]])\nb = np.array([1, 4, 2])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination:\nx + 2y + 3z = 4\n2x + 3y + z = 5\n3x + y + 2z = 6",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 3, 1], [3, 1, 2]])\nb = np.array([4, 5, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using Cramer\u00e2\u20ac\u2122s Rule:\nx + y + z = 3\n2x - y + z = 3\nx + 3y - z = 2",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, -1, 1], [1, 3, -1]])\nb = np.array([3, 3, 2])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x_vals = []\n    for i in range(3):\n        Ai = A.copy()\n        Ai[:, i] = b\n        x_vals.append(np.linalg.det(Ai) / det_A)\n    print(x_vals)"
  },
  {
    "input": "Solve the system:\n2x + 5y = 20\n3x + 2y = 15",
    "output": "import numpy as np\nA = np.array([[2, 5], [3, 2]])\nb = np.array([20, 15])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using matrix inverse:\n3x - y + z = 2\n2x + 4y - z = 3\nx - y + 2z = 1",
    "output": "import numpy as np\nA = np.array([[3, -1, 1], [2, 4, -1], [1, -1, 2]])\nb = np.array([2, 3, 1])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve using NumPy:\n2x + 3y + 4z = 5\n3x + 4y + 5z = 6\n4x + 5y + 6z = 7",
    "output": "import numpy as np\n\n# Augmented matrix\nA = np.array([[2.0, 3.0, 4.0, 5.0],\n              [3.0, 4.0, 5.0, 6.0],\n              [4.0, 5.0, 6.0, 7.0]])\n\n# Gaussian Elimination\nfor i in range(3):\n    A[i] = A[i] / A[i][i]\n    for j in range(i + 1, 3):\n        A[j] = A[j] - A[j][i] * A[i]\n\n# Back Substitution\nx = np.zeros(3)\nx[2] = A[2][3] / A[2][2] if A[2][2] != 0 else 0\nx[1] = (A[1][3] - A[1][2] * x[2]) / A[1][1] if A[1][1] != 0 else 0\nx[0] = (A[0][3] - A[0][2] * x[2] - A[0][1] * x[1]) / A[0][0] if A[0][0] != 0 else 0\n\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination:\n4x + y - z = 2\n2x - 3y + z = -5\nx + 2y + 3z = 3",
    "output": "import numpy as np\nA = np.array([[4, 1, -1], [2, -3, 1], [1, 2, 3]])\nb = np.array([2, -5, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve system with matrix inversion:\n2x + y + z = 4\nx + 2y + z = 5\nx + y + 2z = 6",
    "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\nb = np.array([4, 5, 6])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Use NumPy to solve:\n5x + 6y + 7z = 18\n6x + 5y + 4z = 17\n7x + 8y + 9z = 24",
    "output": "import numpy as np\nA = np.array([[5, 6, 7], [6, 5, 4], [7, 8, 9]])\nb = np.array([18, 17, 24])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using Gaussian elimination:\n3x + y + 2z = 4\nx + 3y + z = 5\n2x + 2y + 3z = 6",
    "output": "import numpy as np\nA = np.array([[3, 1, 2], [1, 3, 1], [2, 2, 3]])\nb = np.array([4, 5, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix method to solve:\n6x + 7y = 30\n2x + 3y = 12",
    "output": "import numpy as np\nA = np.array([[6, 7], [2, 3]])\nb = np.array([30, 12])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination:\n3x + 2y + z = 8\nx - y + 2z = 3\n2x + 3y - z = 4",
    "output": "import numpy as np\nA = np.array([[3, 2, 1], [1, -1, 2], [2, 3, -1]])\nb = np.array([8, 3, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system:\n2x + y - z = 0\nx + y + z = 6\n3x - y + 2z = 5",
    "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, 1, 1], [3, -1, 2]])\nb = np.array([0, 6, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using matrix inversion:\n2x + 3y = 7\n4x + 5y = 11",
    "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nb = np.array([7, 11])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination:\n3x + 2y = 12\n5x + 4y = 20",
    "output": "import numpy as np\nA = np.array([[3, 2], [5, 4]])\nb = np.array([12, 20])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using Cramer\u00e2\u20ac\u2122s Rule:\n3x + 4y + z = 6\n2x + y + 3z = 5\nx + 2y + 2z = 7",
    "output": "import numpy as np\nA = np.array([[3, 4, 1], [2, 1, 3], [1, 2, 2]])\nb = np.array([6, 5, 7])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x_vals = []\n    for i in range(3):\n        Ai = A.copy()\n        Ai[:, i] = b\n        x_vals.append(np.linalg.det(Ai) / det_A)\n    print(x_vals)"
  },
  {
    "input": "Solve the system using Gaussian elimination:\n2x - y + 3z = 9\n4x + y - z = 1\n-2x + 5y + 2z = 7",
    "output": "import numpy as np\nA = np.array([[2, -1, 3], [4, 1, -1], [-2, 5, 2]])\nb = np.array([9, 1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n3x + 4y = 10\n5x - 2y = 8",
    "output": "import numpy as np\nA = np.array([[3, 4], [5, -2]])\nb = np.array([10, 8])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    A1 = A.copy()\n    A1[:, 0] = b\n    A2 = A.copy()\n    A2[:, 1] = b\n    x = np.linalg.det(A1) / det_A\n    y = np.linalg.det(A2) / det_A\n    print([x, y])"
  },
  {
    "input": "Solve the system:\n2x + 3y + 4z = 7\nx - y + z = 4\n3x + 4y - 2z = 1",
    "output": "import numpy as np\nA = np.array([[2, 3, 4], [1, -1, 1], [3, 4, -2]])\nb = np.array([7, 4, 1])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix inversion to solve:\n4x - y + z = 5\n3x + 2y - z = 3\nx + y + z = 6",
    "output": "import numpy as np\nA = np.array([[4, -1, 1], [3, 2, -1], [1, 1, 1]])\nb = np.array([5, 3, 6])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve using NumPy:\n5x + 6y = 16\n7x - 3y = 5",
    "output": "import numpy as np\nA = np.array([[5, 6], [7, -3]])\nb = np.array([16, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n3x - y + 2z = 7\nx + 4y - z = 5\n2x - y + 3z = 8",
    "output": "import numpy as np\nA = np.array([[3, -1, 2], [1, 4, -1], [2, -1, 3]])\nb = np.array([7, 5, 8])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system:\n2x + y - z = 4\nx - 2y + 3z = -1\n3x + 4y + z = 7",
    "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, -2, 3], [3, 4, 1]])\nb = np.array([4, -1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule:\n4x + 5y - z = 6\n2x - 3y + 4z = 8\nx + y + z = 3",
    "output": "import numpy as np\nA = np.array([[4, 5, -1], [2, -3, 4], [1, 1, 1]])\nb = np.array([6, 8, 3])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x_vals = []\n    for i in range(3):\n        Ai = A.copy()\n        Ai[:, i] = b\n        x_vals.append(np.linalg.det(Ai) / det_A)\n    print(x_vals)"
  },
  {
    "input": "Solve using matrix inversion:\n3x + 2y + z = 5\n2x - y + 4z = 6\nx + 3y - 2z = 7",
    "output": "import numpy as np\nA = np.array([[3, 2, 1], [2, -1, 4], [1, 3, -2]])\nb = np.array([5, 6, 7])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination:\n2x - 3y + z = 1\n4x + y - 2z = 2\nx + 2y + 3z = 3",
    "output": "import numpy as np\nA = np.array([[2, -3, 1], [4, 1, -2], [1, 2, 3]])\nb = np.array([1, 2, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system:\n5x + 2y - z = 4\n3x - y + 2z = 6\nx + 4y + 3z = 5",
    "output": "import numpy as np\nA = np.array([[5, 2, -1], [3, -1, 2], [1, 4, 3]])\nb = np.array([4, 6, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n2x + 3y - z = 5\nx - 4y + 2z = 6\n3x + y + z = 4",
    "output": "import numpy as np\nA = np.array([[2, 3, -1], [1, -4, 2], [3, 1, 1]])\nb = np.array([5, 6, 4])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x_vals = []\n    for i in range(3):\n        Ai = A.copy()\n        Ai[:, i] = b\n        x_vals.append(np.linalg.det(Ai) / det_A)\n    print(x_vals)"
  },
  {
    "input": "Solve the system using Gaussian elimination:\n6x - y + z = 10\n2x + 3y - 2z = 7\nx + 2y + 3z = 8",
    "output": "import numpy as np\nA = np.array([[6, -1, 1], [2, 3, -2], [1, 2, 3]])\nb = np.array([10, 7, 8])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix inversion to solve the following system:\n3x + y - z = 2\n4x - 2y + 5z = -1\nx + 3y + 2z = 7",
    "output": "import numpy as np\nA = np.array([[3, 1, -1], [4, -2, 5], [1, 3, 2]])\nb = np.array([2, -1, 7])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve this linear system using numpy:\n2x + 4y + 6z = 18\nx + y + z = 6\n3x + 2y + z = 10",
    "output": "import numpy as np\nA = np.array([[2, 4, 6], [1, 1, 1], [3, 2, 1]])\nb = np.array([18, 6, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n4x + 2y - 3z = 5\n3x + y + 4z = 10\nx + 5y + z = 8",
    "output": "import numpy as np\nA = np.array([[4, 2, -3], [3, 1, 4], [1, 5, 1]])\nb = np.array([5, 10, 8])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using numpy:\n5x - y + z = 4\n2x + 3y - 2z = 1\nx - y + 4z = 7",
    "output": "import numpy as np\nA = np.array([[5, -1, 1], [2, 3, -2], [1, -1, 4]])\nb = np.array([4, 1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule for:\n3x + 2y + z = 10\nx - y + 4z = 5\n2x + 3y + z = 7",
    "output": "import numpy as np\nA = np.array([[3, 2, 1], [1, -1, 4], [2, 3, 1]])\nb = np.array([10, 5, 7])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x_vals = []\n    for i in range(3):\n        Ai = A.copy()\n        Ai[:, i] = b\n        x_vals.append(np.linalg.det(Ai) / det_A)\n    print(x_vals)"
  },
  {
    "input": "Solve:\n6x - 2y + 3z = 12\nx + 4y - 5z = 2\n2x + y + z = 9",
    "output": "import numpy as np\nA = np.array([[6, -2, 3], [1, 4, -5], [2, 1, 1]])\nb = np.array([12, 2, 9])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix inversion to solve:\n4x + y + 2z = 11\nx - 3y + z = 2\n2x + 2y + 3z = 13",
    "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, -3, 1], [2, 2, 3]])\nb = np.array([11, 2, 13])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve using NumPy:\n3x + 3y + 3z = 9\nx + 2y + 3z = 8\n2x + y + z = 6",
    "output": "import numpy as np\nA = np.array([[3, 3, 3], [1, 2, 3], [2, 1, 1]])\nb = np.array([9, 8, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n2x + y + z = 6\nx + 3y - z = 2\n3x + 4y + 2z = 10",
    "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 3, -1], [3, 4, 2]])\nb = np.array([6, 2, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using matrix inversion:\n5x - y + 2z = 4\nx + 3y - 4z = 6\n2x + 4y + z = 10",
    "output": "import numpy as np\nA = np.array([[5, -1, 2], [1, 3, -4], [2, 4, 1]])\nb = np.array([4, 6, 10])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve the system using Gaussian elimination:\n3x + y - z = 1\nx - y + z = -3\n2x + y + z = 0",
    "output": "import numpy as np\nA = np.array([[3, 1, -1], [1, -1, 1], [2, 1, 1]])\nb = np.array([1, -3, 0])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n2x + 3y = 7\n3x + 5y = 9",
    "output": "import numpy as np\nA = np.array([[2, 3], [3, 5]])\nb = np.array([7, 9])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    A1 = A.copy()\n    A1[:, 0] = b\n    A2 = A.copy()\n    A2[:, 1] = b\n    x = np.linalg.det(A1) / det_A\n    y = np.linalg.det(A2) / det_A\n    print([x, y])"
  },
  {
    "input": "Solve the system:\n4x - y + z = 5\n3x + 2y - z = 3\nx + y + z = 6",
    "output": "import numpy as np\nA = np.array([[4, -1, 1], [3, 2, -1], [1, 1, 1]])\nb = np.array([5, 3, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix inversion to solve:\n3x + 2y + z = 5\n2x - y + 4z = 6\nx + 3y - 2z = 7",
    "output": "import numpy as np\nA = np.array([[3, 2, 1], [2, -1, 4], [1, 3, -2]])\nb = np.array([5, 6, 7])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve using NumPy:\n2x + 4y + 6z = 18\nx + y + z = 6\n3x + 2y + z = 10",
    "output": "import numpy as np\nA = np.array([[2, 4, 6], [1, 1, 1], [3, 2, 1]])\nb = np.array([18, 6, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using NumPy:\n5x - y + z = 4\n2x + 3y - 2z = 1\nx - y + 4z = 7",
    "output": "import numpy as np\nA = np.array([[5, -1, 1], [2, 3, -2], [1, -1, 4]])\nb = np.array([4, 1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n3x + 2y + z = 10\nx - y + 4z = 5\n2x + 3y + z = 7",
    "output": "import numpy as np\nA = np.array([[3, 2, 1], [1, -1, 4], [2, 3, 1]])\nb = np.array([10, 5, 7])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x_vals = []\n    for i in range(3):\n        Ai = A.copy()\n        Ai[:, i] = b\n        x_vals.append(np.linalg.det(Ai) / det_A)\n    print(x_vals)"
  },
  {
    "input": "Solve using NumPy:\n3x + 4y + 5z = 14\n2x + y - z = 1\nx + 3y + z = 7",
    "output": "import numpy as np\nA = np.array([[3, 4, 5], [2, 1, -1], [1, 3, 1]])\nb = np.array([14, 1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule to solve:\nx + 2y + 3z = 14\n4x + 5y + 6z = 32\n7x + 8y + 10z = 50",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\nb = np.array([14, 32, 50])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x_vals = []\n    for i in range(3):\n        Ai = A.copy()\n        Ai[:, i] = b\n        x_vals.append(np.linalg.det(Ai) / det_A)\n    print(x_vals)"
  },
  {
    "input": "Solve this system of equations using numpy:\n2x - 3y + z = 5\n-4x + y + 2z = -2\nx + 2y + 3z = 4",
    "output": "import numpy as np\nA = np.array([[2, -3, 1], [-4, 1, 2], [1, 2, 3]])\nb = np.array([5, -2, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination for:\n4x + 3y + 2z = 1\n2x - 2y + z = -3\nx + y + z = 2",
    "output": "import numpy as np\nA = np.array([[4, 3, 2], [2, -2, 1], [1, 1, 1]])\nb = np.array([1, -3, 2])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using NumPy:\n2x + y = 7\nx - y = 1",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, -1]])\nb = np.array([7, 1])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix inversion to solve:\n3x + y + z = 5\nx - 2y + 4z = 6\n2x + 3y + z = 10",
    "output": "import numpy as np\nA = np.array([[3, 1, 1], [1, -2, 4], [2, 3, 1]])\nb = np.array([5, 6, 10])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve this system:\nx + 2y - z = 3\n2x - y + 3z = 7\n4x + y + z = 10",
    "output": "import numpy as np\nA = np.array([[1, 2, -1], [2, -1, 3], [4, 1, 1]])\nb = np.array([3, 7, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination:\n2x + 3y + z = 1\nx - y + 2z = 4\n3x + 2y + 4z = 7",
    "output": "import numpy as np\nA = np.array([[2, 3, 1], [1, -1, 2], [3, 2, 4]])\nb = np.array([1, 4, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system:\n2x + y - 2z = -1\n4x - 6y = -2\n-2x + 7y + 2z = 9",
    "output": "import numpy as np\nA = np.array([[2, 1, -2], [4, -6, 0], [-2, 7, 2]])\nb = np.array([-1, -2, 9])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer\u00e2\u20ac\u2122s Rule to solve:\n3x + 2y = 7\nx + y = 3",
    "output": "import numpy as np\nA = np.array([[3, 2], [1, 1]])\nb = np.array([7, 3])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x = np.linalg.det(np.array([[7, 2], [3, 1]])) / det_A\n    y = np.linalg.det(np.array([[3, 7], [1, 3]])) / det_A\n    print([x, y])"
  },
  {
    "input": "Solve using NumPy:\n3x + y = 10\nx + 2y = 8",
    "output": "import numpy as np\nA = np.array([[3, 1], [1, 2]])\nb = np.array([10, 8])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system using Gaussian elimination:\n2x - 3y + z = 5\n-4x + y + 2z = -2\nx + 2y + 3z = 4",
    "output": "import numpy as np\nA = np.array([[2, -3, 1], [-4, 1, 2], [1, 2, 3]])\nb = np.array([5, -2, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using matrix inversion:\n4x + y + 2z = 11\nx - 3y + z = 2\n2x + 2y + 3z = 13",
    "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, -3, 1], [2, 2, 3]])\nb = np.array([11, 2, 13])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve the system:\n3x + 4y + 5z = 14\n2x + y - z = 1\nx + 3y + z = 7",
    "output": "import numpy as np\nA = np.array([[3, 4, 5], [2, 1, -1], [1, 3, 1]])\nb = np.array([14, 1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n4x + 3y + 2z = 1\n2x - 2y + z = -3\nx + y + z = 2",
    "output": "import numpy as np\nA = np.array([[4, 3, 2], [2, -2, 1], [1, 1, 1]])\nb = np.array([1, -3, 2])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using Gaussian elimination:\n5x + 2y + z = 17\nx + 3y + 2z = 13\n3x + y + 4z = 20",
    "output": "import numpy as np\nA = np.array([[5, 2, 1], [1, 3, 2], [3, 1, 4]])\nb = np.array([17, 13, 20])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n2x + y - z = 1\nx + 2y + 3z = 14\n4x + y + z = 10",
    "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, 2, 3], [4, 1, 1]])\nb = np.array([1, 14, 10])\ndet_A = np.linalg.det(A)\nif det_A == 0:\n    print('No unique solution')\nelse:\n    x_vals = []\n    for i in range(3):\n        Ai = A.copy()\n        Ai[:, i] = b\n        x_vals.append(np.linalg.det(Ai) / det_A)\n    print(x_vals)"
  },
  {
    "input": "Solve the following system:\nx + y + z = 6\nx + 2y + 3z = 14\n2x + 3y + z = 10",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 2, 3], [2, 3, 1]])\nb = np.array([6, 14, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use NumPy to solve:\n2x - y + 3z = 5\n4x + y - z = 3\n-2x + 5y + 2z = 7",
    "output": "import numpy as np\nA = np.array([[2, -1, 3], [4, 1, -1], [-2, 5, 2]])\nb = np.array([5, 3, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the linear system:\n6x - y + z = 4\n2x + 4y - z = 5\nx - y + 5z = 9",
    "output": "import numpy as np\nA = np.array([[6, -1, 1], [2, 4, -1], [1, -1, 5]])\nb = np.array([4, 5, 9])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix inversion:\n3x + y = 9\nx + 2y = 8",
    "output": "import numpy as np\nA = np.array([[3, 1], [1, 2]])\nb = np.array([9, 8])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve using NumPy:\n4x + y + z = 9\n2x - y + 2z = 5\nx + 3y + 3z = 12",
    "output": "import numpy as np\nA = np.array([[4, 1, 1], [2, -1, 2], [1, 3, 3]])\nb = np.array([9, 5, 12])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve:\n5x + 2y - z = 3\nx - y + z = 1\n3x + 4y + z = 10",
    "output": "import numpy as np\nA = np.array([[5, 2, -1], [1, -1, 1], [3, 4, 1]])\nb = np.array([3, 1, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination:\n3x + 2y + 4z = 20\nx - y + z = 2\n2x + y - z = 5",
    "output": "import numpy as np\nA = np.array([[3, 2, 4], [1, -1, 1], [2, 1, -1]])\nb = np.array([20, 2, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve system of equations:\n4x + 2y - z = 6\n3x - y + 2z = 5\nx + y + z = 4",
    "output": "import numpy as np\nA = np.array([[4, 2, -1], [3, -1, 2], [1, 1, 1]])\nb = np.array([6, 5, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve:\nx + 2y + z = 4\n3x - y + 2z = 7\n2x + y + 3z = 10",
    "output": "import numpy as np\nA = np.array([[1, 2, 1], [3, -1, 2], [2, 1, 3]])\nb = np.array([4, 7, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use matrix inversion to solve:\n2x + 3y = 5\nx + 2y = 4",
    "output": "import numpy as np\nA = np.array([[2, 3], [1, 2]])\nb = np.array([5, 4])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve the system using NumPy:\n4x + 5y = 9\n2x + y = 3",
    "output": "import numpy as np\nA = np.array([[4, 5], [2, 1]])\nb = np.array([9, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A coffee shop offers two blends: House Blend and Dark Roast. House Blend costs $5 per pound, and Dark Roast costs $7 per pound. A customer buys 10 pounds of coffee for $62. How many pounds of each blend did they purchase?",
    "output": "import numpy as np\nA = np.array([[1, 1], [5, 7]])\nb = np.array([10, 62])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A theater sold 120 tickets for a show, collecting a total of $1,800. Adult tickets cost $20 each, and child tickets cost $10 each. How many adult and child tickets were sold?",
    "output": "import numpy as np\nA = np.array([[1, 1], [20, 10]])\nb = np.array([120, 1800])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A farmer has 100 acres of land to plant wheat and corn. Wheat requires 1 acre per unit, and corn requires 2 acres per unit. The farmer wants to plant a total of 70 units. How many units of each crop should be planted?",
    "output": "import numpy as np\nA = np.array([[1, 1], [1, 2]])\nb = np.array([70, 100])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A chemist needs to mix a 10% acid solution with a 25% acid solution to obtain 15 liters of a 20% acid solution. How many liters of each solution should be used?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.10, 0.25]])\nb = np.array([15, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A company produces two products: A and B. Product A requires 2 hours of labor and 3 units of material. Product B requires 4 hours of labor and 2 units of material. The company has 40 hours of labor and 30 units of material available. How many units of each product should be produced?",
    "output": "import numpy as np\nA = np.array([[2, 4], [3, 2]])\nb = np.array([40, 30])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A dietitian wants to create a meal with exactly 500 calories using foods A and B. Food A has 100 calories per serving, and food B has 150 calories per serving. The total number of servings should be 4. How many servings of each food should be used?",
    "output": "import numpy as np\nA = np.array([[1, 1], [100, 150]])\nb = np.array([4, 500])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A car rental company offers two plans: Plan X charges a flat fee of $50 plus $0.20 per mile, and Plan Y charges a flat fee of $30 plus $0.50 per mile. For how many miles will the two plans cost the same?",
    "output": "import numpy as np\nA = np.array([[0.20, -0.50], [1, -1]])\nb = np.array([-20, 0])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Two friends decide to invest in a business. One invests $5,000, and the other invests $7,000. They agree to split the profits in proportion to their investments. If the total profit is $4,800, how much does each receive?",
    "output": "import numpy as np\nA = np.array([[5000, 7000], [1, 1]])\nb = np.array([4800, 1])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A school club is selling T-shirts and hoodies. T-shirts cost $15, and hoodies cost $30. They sold a total of 50 items and collected $1,200. How many T-shirts and hoodies were sold?",
    "output": "import numpy as np\nA = np.array([[1, 1], [15, 30]])\nb = np.array([50, 1200])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A landscaper is designing a rectangular garden with a perimeter of 60 meters. The length is 5 meters more than twice the width. What are the dimensions of the garden?",
    "output": "import numpy as np\nA = np.array([[2, 2], [1, -2]])\nb = np.array([60, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A store sells pens and notebooks. Pens cost $2 each, and notebooks cost $5 each. A customer buys 8 items and spends $28. How many pens and notebooks did they purchase?",
    "output": "import numpy as np\nA = np.array([[1, 1], [2, 5]])\nb = np.array([8, 28])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A boat travels 36 miles downstream in 3 hours and returns upstream in 4 hours. The speed of the current is 2 mph. What is the speed of the boat in still water?",
    "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\nb = np.array([12, 9])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A student scores 85 on a test with 100 questions. Each correct answer earns 1 point, and each incorrect answer deducts 0.25 points. How many questions did the student answer correctly?",
    "output": "import numpy as np\nA = np.array([[1, 1], [1, -0.25]])\nb = np.array([100, 85])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A manufacturer produces two types of widgets: Standard and Deluxe. Standard widgets require 2 hours of labor and 1 unit of material. Deluxe widgets require 3 hours of labor and 2 units of material. The company has 100 hours of labor and 60 units of material available. How many of each type should be produced?",
    "output": "import numpy as np\nA = np.array([[2, 3], [1, 2]])\nb = np.array([100, 60])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "An investor wants to split $10,000 between two accounts. One account earns 5% interest, and the other earns 8%. After one year, the total interest earned is $680. How much was invested in each account?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.05, 0.08]])\nb = np.array([10000, 680])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A printing company uses two printers. Printer A can print 100 pages per hour, and Printer B can print 80 pages per hour. Together, they print 1,440 pages in 16 hours. How many hours did each printer work?",
    "output": "import numpy as np\nA = np.array([[100, 80], [1, 1]])\nb = np.array([1440, 16])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A shop sells apples and bananas. Apples cost $2 each, and bananas cost $1.50. A customer buys 20 fruits and spends $34. How many of each fruit were purchased?",
    "output": "import numpy as np\nA = np.array([[1, 1], [2.0, 1.5]])\nb = np.array([20, 34])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Two buses leave the same station at the same time. One bus heads north at 60 km/h, the other south at 75 km/h. In how many hours will they be 405 km apart?",
    "output": "total_distance = 405\nrelative_speed = 60 + 75\ntime = total_distance / relative_speed\nprint(\"Time until they are 405 km apart:\", time, \"hours\")"
  },
  {
    "input": "A chemist mixes a solution that is 30% alcohol with another that is 70% alcohol. How many liters of each should be used to make 20 liters of a 50% alcohol solution?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.3, 0.7]])\nb = np.array([20, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A car travels 180 miles in 3 hours. For part of the time it travels at 50 mph and for the rest at 70 mph. How much time was spent at each speed?",
    "output": "import numpy as np\nA = np.array([[50, 70], [1, 1]])\nb = np.array([180, 3])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Two people are working together to paint a wall. One can do it in 4 hours, the other in 6 hours. How long will it take them working together?",
    "output": "import sympy as sp\nt = sp.Symbol('t')\neq = (1/4 + 1/6)*t - 1\nsolution = sp.solve(eq, t)\nprint(solution)"
  },
  {
    "input": "A system of three equations:\n2x + y - z = 8\n-x + 3y + 2z = 4\n3x - y + z = 10",
    "output": "import numpy as np\nA = np.array([[2, 1, -1], [-1, 3, 2], [3, -1, 1]])\nb = np.array([8, 4, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve for x and y:\n3x - 2y = 16\n4x + 5y = 2",
    "output": "import numpy as np\nA = np.array([[3, -2], [4, 5]])\nb = np.array([16, 2])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Two types of tickets were sold for a concert: standard at $25 and VIP at $60. 120 tickets were sold for $4,050. How many of each type?",
    "output": "import numpy as np\nA = np.array([[1, 1], [25, 60]])\nb = np.array([120, 4050])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A train travels 120 miles at a certain speed. If the speed were increased by 10 mph, the trip would take 30 minutes less. What is the original speed?",
    "output": "import sympy as sp\nv = sp.Symbol('v')\neq = 120/v - 120/(v + 10) - 0.5\nsolution = sp.solve(eq, v)\nprint(solution)"
  },
  {
    "input": "Mixing two solutions: one 20% salt, the other 60%. You want 10 liters of 40% solution. How many liters of each to use?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.2, 0.6]])\nb = np.array([10, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A sports store sells two kinds of shoes: sneakers at $50 and cleats at $80. If 40 shoes are sold and revenue is $2,600, how many of each were sold?",
    "output": "import numpy as np\nA = np.array([[1, 1], [50, 80]])\nb = np.array([40, 2600])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system using matrix inversion:\n2x + 3y = 12\n4x - y = 5",
    "output": "import numpy as np\nA = np.array([[2, 3], [4, -1]])\nb = np.array([12, 5])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Two trains leave the same station heading in opposite directions. One travels at 60 mph, the other at 80 mph. How long until they are 280 miles apart?",
    "output": "import numpy as np\nA = np.array([[140]])\nb = np.array([280])\ntime = np.linalg.solve(A, b)\nprint(\"Time until they are 280 miles apart:\", time[0], \"hours\")"
  },
  {
    "input": "A bookstore sells novels and textbooks. Novels cost $12 each, and textbooks cost $50 each. A customer buys 8 books and spends $296. How many novels and textbooks did they purchase?",
    "output": "import numpy as np\nA = np.array([[1, 1], [12, 50]])\nb = np.array([8, 296])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A farmer has 90 acres of land to plant wheat and barley. Wheat requires 2 acres per unit, and barley requires 1 acre per unit. The farmer wants to plant a total of 60 units. How many units of each crop should be planted?",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, 1]])\nb = np.array([90, 60])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A chemist needs to mix a 15% saline solution with a 30% saline solution to obtain 20 liters of a 25% saline solution. How many liters of each solution should be used?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.15, 0.30]])\nb = np.array([20, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A company produces two models of smartphones: Model X and Model Y. Model X requires 3 hours of assembly and 2 units of material. Model Y requires 5 hours of assembly and 4 units of material. The company has 240 hours of assembly time and 160 units of material available. How many units of each model should be produced?",
    "output": "import numpy as np\nA = np.array([[3, 5], [2, 4]])\nb = np.array([240, 160])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A dietitian wants to create a meal with exactly 600 calories using foods A and B. Food A has 120 calories per serving, and food B has 180 calories per serving. The total number of servings should be 5. How many servings of each food should be used?",
    "output": "import numpy as np\nA = np.array([[1, 1], [120, 180]])\nb = np.array([5, 600])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A car rental company offers two plans: Plan A charges a flat fee of $40 plus $0.25 per mile, and Plan B charges a flat fee of $60 plus $0.15 per mile. For how many miles will the two plans cost the same?",
    "output": "import numpy as np\nA = np.array([[0.25, -0.15], [1, -1]])\nb = np.array([-20, 0])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Two friends decide to invest in a business. One invests $8,000, and the other invests $12,000. They agree to split the profits in proportion to their investments. If the total profit is $10,000, how much does each receive?",
    "output": "import numpy as np\nA = np.array([[8000, 12000], [1, 1]])\nb = np.array([10000, 1])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A school club is selling tickets for a play. Adult tickets cost $15, and student tickets cost $10. They sold a total of 100 tickets and collected $1,200. How many adult and student tickets were sold?",
    "output": "import numpy as np\nA = np.array([[1, 1], [15, 10]])\nb = np.array([100, 1200])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A landscaper is designing a rectangular garden with a perimeter of 80 meters. The length is 10 meters more than the width. What are the dimensions of the garden?",
    "output": "import numpy as np\nA = np.array([[2, 2], [1, -1]])\nb = np.array([80, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A store sells pens and pencils. Pens cost $3 each, and pencils cost $1 each. A customer buys 15 items and spends $25. How many pens and pencils did they purchase?",
    "output": "import numpy as np\nA = np.array([[1, 1], [3, 1]])\nb = np.array([15, 25])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A boat travels 50 miles downstream in 2 hours and returns upstream in 5 hours. The speed of the current is 3 mph. What is the speed of the boat in still water?",
    "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\nb = np.array([25, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A student scores 90 on a test with 120 questions. Each correct answer earns 1 point, and each incorrect answer deducts 0.5 points. How many questions did the student answer correctly?",
    "output": "import numpy as np\nA = np.array([[1, 1], [1, -0.5]])\nb = np.array([120, 90])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A manufacturer produces two types of chairs: Standard and Deluxe. Standard chairs require 1 hour of labor and 2 units of material. Deluxe chairs require 2 hours of labor and 3 units of material. The company has 160 hours of labor and 240 units of material available. How many of each type should be produced?",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 3]])\nb = np.array([160, 240])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A grocer sells two types of rice. Type A costs $2 per kg, and Type B costs $3 per kg. A customer buys 20 kg of rice for $50. How many kilograms of each type did the customer buy?",
    "output": "import numpy as np\nA = np.array([[1, 1], [2, 3]])\nb = np.array([20, 50])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A furniture store sells two types of chairs. A wooden chair costs $120 and a plastic chair costs $80. If the store sold 50 chairs for a total of $5,000, how many of each were sold?",
    "output": "import numpy as np\nA = np.array([[1, 1], [120, 80]])\nb = np.array([50, 5000])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A chemist wants to mix a 10% acid solution with a 25% acid solution to get 40 liters of a 20% acid solution. How many liters of each solution are needed?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.1, 0.25]])\nb = np.array([40, 8])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A person buys 3 shirts and 2 pants for $160. Another person buys 2 shirts and 4 pants for $200. Find the price of each shirt and each pant.",
    "output": "import numpy as np\nA = np.array([[3, 2], [2, 4]])\nb = np.array([160, 200])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A pool can be filled by two pipes. Pipe A can fill the pool in 4 hours, and Pipe B in 6 hours. How long will it take both pipes working together to fill the pool?",
    "output": "import sympy as sp\nt = sp.Symbol('t')\neq = (1/4 + 1/6)*t - 1\nsolution = sp.solve(eq, t)\nprint(solution)"
  },
  {
    "input": "Two people run a race of 100 meters. One runs at 5 m/s and the other at 6 m/s. How long does it take for the faster runner to finish, and how far is the slower runner at that time?",
    "output": "distance = 100\nfast_speed = 6\nslow_speed = 5\ntime = distance / fast_speed\nslower_runner_distance = slow_speed * time\nprint(f\"Time for faster runner to finish: {time} seconds\")\nprint(f\"Distance covered by slower runner: {slower_runner_distance} meters\")"
  },
  {
    "input": "A triangle has perimeter 48 cm. The first side is twice as long as the second, and the third side is 4 cm more than the second. What are the lengths of the sides?",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, -2, 0], [0, 1, -1]])\nb = np.array([48, 0, -4])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A store sells pencils in boxes of 12 and boxes of 20. If a school orders 15 boxes containing a total of 240 pencils, how many of each type of box were ordered?",
    "output": "import numpy as np\nA = np.array([[1, 1], [12, 20]])\nb = np.array([15, 240])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using Cramer's Rule:\n3x + y = 7\n2x - 5y = -1",
    "output": "import numpy as np\nA = np.array([[3, 1], [2, -5]])\nb = np.array([7, -1])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.array([[7, 1], [-1, -5]]))\nDy = np.linalg.det(np.array([[3, 7], [2, -1]]))\nx = Dx / D\ny = Dy / D\nprint([x, y])"
  },
  {
    "input": "You bought 3 notebooks and 2 pens for $11, and 2 notebooks and 4 pens for $10. What is the cost of one notebook and one pen?",
    "output": "import numpy as np\nA = np.array([[3, 2], [2, 4]])\nb = np.array([11, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A movie theater sells adult tickets for $12 and child tickets for $8. They sold 100 tickets and made $1,040. How many of each ticket did they sell?",
    "output": "import numpy as np\nA = np.array([[1, 1], [12, 8]])\nb = np.array([100, 1040])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A coffee shop sells small and large cups of coffee. A small cup costs $2, and a large cup costs $3. On a particular day, the shop sold 100 cups for a total of $250. How many of each size were sold?",
    "output": "import numpy as np\nA = np.array([[1, 1], [2, 3]])\nb = np.array([100, 250])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A farmer has chickens and cows. Counting heads, he has 50 animals. Counting legs, he has 140. How many chickens and how many cows does he have?",
    "output": "import numpy as np\nA = np.array([[1, 1], [2, 4]])\nb = np.array([50, 140])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A theater sold 120 tickets for a show, collecting a total of $1,800. Adult tickets cost $20 each, and child tickets cost $10 each. How many of each type of ticket were sold?",
    "output": "import numpy as np\nA = np.array([[1, 1], [20, 10]])\nb = np.array([120, 1800])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A cyclist travels 120 km against the wind in 4 hours and returns with the wind in 3 hours. What are the cyclist's speed in still air and the speed of the wind?",
    "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\nb = np.array([30, 40])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A chemist needs to mix a 20% acid solution with a 50% acid solution to obtain 100 liters of a 40% acid solution. How many liters of each solution should be used?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.2, 0.5]])\nb = np.array([100, 40])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A store sells two brands of cereal. Brand A costs $4 per box, and Brand B costs $5 per box. A customer buys 30 boxes for $130. How many boxes of each brand did they buy?",
    "output": "import numpy as np\nA = np.array([[1, 1], [4, 5]])\nb = np.array([30, 130])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A school is organizing a field trip. They rent buses that hold 40 students and vans that hold 8 students. If 400 students are going on the trip and they use a total of 20 vehicles, how many buses and how many vans did they use?",
    "output": "import numpy as np\nA = np.array([[40, 8], [1, 1]])\nb = np.array([400, 20])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A gardener is planting two types of flowers: roses and tulips. Roses cost $3 each, and tulips cost $2 each. She spends $120 and plants 50 flowers. How many of each did she plant?",
    "output": "import numpy as np\nA = np.array([[1, 1], [3, 2]])\nb = np.array([50, 120])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A company produces two products: tables and chairs. Each table requires 3 hours of labor and 5 units of material. Each chair requires 2 hours of labor and 3 units of material. The company has 180 hours of labor and 300 units of material available. How many tables and chairs should they produce?",
    "output": "import numpy as np\nA = np.array([[3, 2], [5, 3]])\nb = np.array([180, 300])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A car rental agency offers two types of cars: sedans and SUVs. Sedans rent for $30 per day, and SUVs rent for $50 per day. On a particular day, the agency rented out 40 cars and collected $1,500 in rental fees. How many sedans and how many SUVs were rented?",
    "output": "import numpy as np\nA = np.array([[1, 1], [30, 50]])\nb = np.array([40, 1500])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A dietitian wants to prepare a meal with 500 calories using two foods. Food A has 100 calories per serving, and Food B has 150 calories per serving. The total number of servings should be 4. How many servings of each food should be used?",
    "output": "import numpy as np\nA = np.array([[1, 1], [100, 150]])\nb = np.array([4, 500])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A boat travels 60 miles downstream in 3 hours and returns upstream in 4 hours. The speed of the current is 2 mph. What is the speed of the boat in still water?",
    "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\nb = np.array([20, 16])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A car travels 180 km in 3 hours with the wind and 120 km in 3 hours against the wind. What is the speed of the car in still air and the speed of the wind?",
    "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\nb = np.array([60, 40])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A farmer has ducks and goats. He counts 60 heads and 174 legs. How many ducks and how many goats does he have?",
    "output": "import numpy as np\nA = np.array([[1, 1], [2, 4]])\nb = np.array([60, 174])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "You buy 5 pencils and 2 pens for $3.40. Your friend buys 3 pencils and 4 pens for $3.80. What is the cost of one pencil and one pen?",
    "output": "import numpy as np\nA = np.array([[5, 2], [3, 4]])\nb = np.array([3.4, 3.8])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A car rental service charges a flat fee of $50 and $0.20 per mile. Another company charges $30 flat and $0.40 per mile. At what distance do both companies charge the same amount?",
    "output": "import sympy as sp\nx = sp.Symbol('x')\neq = 50 + 0.2*x - (30 + 0.4*x)\nsolution = sp.solve(eq, x)\nprint(solution)"
  },
  {
    "input": "In a 3-hour exam, a student answered 90 questions. For every correct answer they gained 4 points, and for every wrong one they lost 1 point. The total score was 260. How many questions were correct and how many were wrong?",
    "output": "import numpy as np\nA = np.array([[1, 1], [4, -1]])\nb = np.array([90, 260])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "You invested $5,000 in two accounts. One pays 5% interest and the other pays 8%. If the total interest after one year is $340, how much is in each account?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.05, 0.08]])\nb = np.array([5000, 340])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Two trains leave the same station, one heading east at 60 km/h and the other west at 90 km/h. After how many hours will they be 450 km apart?",
    "output": "total_speed = 60 + 90\ntime = 450 / total_speed\nprint(time)"
  },
  {
    "input": "A mix of 3 types of grains costs $20 per bag. Type A costs $10/kg, B costs $25/kg, and C costs $30/kg. The bag has 2 kg of A, 1 kg of B, and x kg of C. What is the weight of C if the total weight is 5 kg?",
    "output": "import numpy as np\nA = np.array([[1, 1], [10*2 + 25, 30]])\nb = np.array([5, 20*5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A restaurant sold a total of 150 dishes. Veg dishes cost $8 and non-veg dishes $12. If the total sales were $1,400, how many of each were sold?",
    "output": "import numpy as np\nA = np.array([[1, 1], [8, 12]])\nb = np.array([150, 1400])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A box contains 100 coins, consisting of 25-cent and 10-cent coins. The total value is $15.50. How many of each coin are there?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.25, 0.10]])\nb = np.array([100, 15.5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using Cramer\u00e2\u20ac\u2122s Rule:\n2x + 3y = 13\n4x - y = 5",
    "output": "import numpy as np\nA = np.array([[2, 3], [4, -1]])\nb = np.array([13, 5])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.array([[13, 3], [5, -1]]))\nDy = np.linalg.det(np.array([[2, 13], [4, 5]]))\nx = Dx / D\ny = Dy / D\nprint([x, y])"
  },
  {
    "input": "A person has $8.80 in pennies and nickels. If there are twice as many nickels as pennies, how many pennies and nickels does the person have?",
    "output": "import numpy as np\nA = np.array([[1, -2], [1, 0.05]])\nb = np.array([0, 8.80])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A total of 78 seats for a concert are sold, producing a total revenue of $483. If seats cost either $2.50 or $10.50, how many of each type were sold?",
    "output": "import numpy as np\nA = np.array([[1, 1], [2.5, 10.5]])\nb = np.array([78, 483])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Jacob has some 32-cent, 29-cent, and 3-cent stamps. The number of 3-cent stamps is 5 less than the number of 29-cent stamps, and the number of 29-cent stamps is 10 less than the number of 32-cent stamps. The total value of the stamps is $9.45. How many of each does he have?",
    "output": "import numpy as np\nA = np.array([[1, -1, 0], [0, 1, -1], [32, 29, 3]])\nb = np.array([10, 5, 945])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Peterson mixes candy that sells for $2.00 per pound with candy that costs $3.60 per pound to make 50 pounds of candy selling for $2.16 per pound. How many pounds of each kind did he use?",
    "output": "import numpy as np\nA = np.array([[1, 1], [2, 3.6]])\nb = np.array([50, 108])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Jonathan mixes an alloy containing 14% silver with an alloy containing 24% silver to make 100 pounds of an alloy with 18% silver. How many pounds of each kind did he use?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.14, 0.24]])\nb = np.array([100, 18])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A large pizza at Palanzio\u00e2\u20ac\u2122s Pizzeria costs $6.80 plus $0.90 for each topping. The cost of a large cheese pizza at Guido\u00e2\u20ac\u2122s Pizza is $7.30 plus $0.65 for each topping. How many toppings need to be added for the pizzas to cost the same?",
    "output": "import numpy as np\nA = np.array([[0.90, -0.65], [1, -1]])\nb = np.array([0.50, 0])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Ms. Kitts works at a music store. Last week she sold 6 more than 3 times the number of CDs that she sold this week. She sold a total of 110 CDs over the two weeks. How many CDs did she sell each week?",
    "output": "import numpy as np\nA = np.array([[1, -3], [1, 1]])\nb = np.array([6, 110])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "The length of a rectangle is equal to triple the width. If the perimeter is 86 centimeters, what are the dimensions of the rectangle?",
    "output": "import numpy as np\nA = np.array([[1, -3], [2, 2]])\nb = np.array([0, 86])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "At a restaurant, the cost for a breakfast taco and a small glass of milk is $2.10. The cost for 2 tacos and 3 small glasses of milk is $5.15. Determine the cost of a taco and a small glass of milk.",
    "output": "import numpy as np\nA = np.array([[1, 1], [2, 3]])\nb = np.array([2.10, 5.15])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "The Frosty Ice-Cream sells sundaes for $2 and banana splits for $3. On a hot summer day, the shop sold 8 more sundaes than banana splits and made $156. How many of each did they sell?",
    "output": "import numpy as np\nA = np.array([[1, -1], [2, 3]])\nb = np.array([8, 156])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Chase bought 5 pieces of fudge and 3 pieces of bubble gum for a total of $5.70. Sara bought 2 pieces of fudge and 10 pieces of bubble gum for a total of $3.60. Determine the cost of one piece of fudge and one piece of bubble gum.",
    "output": "import numpy as np\nA = np.array([[5, 3], [2, 10]])\nb = np.array([5.70, 3.60])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Carla purchased a math textbook and a novel that cost a total of $54. The price of the math textbook is $8 more than 3 times the price of the novel. What are the prices of each book?",
    "output": "import numpy as np\nA = np.array([[1, -3], [1, 1]])\nb = np.array([8, 54])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "The price of an entertainment system at Extreme Electronics is $220 less than twice the price at Ultra Electronics. The difference in price between the two stores is $175. What are the prices at each store?",
    "output": "import numpy as np\nA = np.array([[1, -2], [1, -1]])\nb = np.array([-220, 175])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "The perimeter of a rectangular wooden deck is 90 feet. The deck's length is 5 feet less than 4 times its width. What are the length and width of the deck?",
    "output": "import numpy as np\nA = np.array([[1, -4], [2, 2]])\nb = np.array([5, 90])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "In a college, the number of boys is 20 more than twice the number of girls. If there are 260 students in total, how many are boys and how many are girls?",
    "output": "import numpy as np\nA = np.array([[1, -2], [1, 1]])\nb = np.array([20, 260])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A chemist wants to mix a solution that is 30% acid with one that is 70% acid to obtain 60 liters of a 50% acid solution. How many liters of each solution should be mixed?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.3, 0.7]])\nb = np.array([60, 30])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A cashier has 50 coins consisting of dimes and quarters. The total value is $8.35. How many of each coin does the cashier have?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.10, 0.25]])\nb = np.array([50, 8.35])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Find the number of solutions of the system:\n3x + 2y = 6\n6x + 4y = 12",
    "output": "import numpy as np\nA = np.array([[3, 2], [6, 4]])\nb = np.array([6, 12])\nrank_A = np.linalg.matrix_rank(A)\nAb = np.column_stack((A, b))\nrank_Ab = np.linalg.matrix_rank(Ab)\nif rank_A == rank_Ab == A.shape[1]:\n    print(\"Unique solution\")\nelif rank_A == rank_Ab < A.shape[1]:\n    print(\"Infinite solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Tickets for a concert were sold in two price categories: $25 for adults and $15 for students. If 400 tickets were sold and the total revenue was $8,000, how many of each type were sold?",
    "output": "import numpy as np\nA = np.array([[1, 1], [25, 15]])\nb = np.array([400, 8000])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "In a chemistry lab, a solution is made by mixing a 10% saline solution with a 40% saline solution. How many liters of each should be used to get 50 liters of a 25% solution?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.10, 0.40]])\nb = np.array([50, 12.5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A person traveled 120 km in 3 hours, partly by car at 50 km/h and partly by bike at 20 km/h. How long did he drive the car and how long did he ride the bike?",
    "output": "import numpy as np\nA = np.array([[1, 1], [50, 20]])\nb = np.array([3, 120])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A store sells pencils for $0.50 and pens for $1.20. A student buys 15 items and spends $12.60. How many pencils and pens did they buy?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.5, 1.2]])\nb = np.array([15, 12.6])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A boat travels 30 miles downstream in 2 hours and returns upstream in 3 hours. What are the speed of the boat in still water and the speed of the current?",
    "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\nb = np.array([15, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Two companies produce widgets. Company A produces 500 widgets per day, while Company B produces 300 widgets per day. Together they need to produce 12,600 widgets. How many days should each work if Company A works 3 days more than Company B?",
    "output": "import numpy as np\nA = np.array([[1, -1], [500, 300]])\nb = np.array([3, 12600])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Two investments yield returns of 5% and 7% respectively. If a total of $10,000 is invested and the annual return is $620, how much is invested in each?",
    "output": "import numpy as np\nA = np.array([[1, 1], [0.05, 0.07]])\nb = np.array([10000, 620])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system using Cramer's Rule:\n3x - 2y = 5\nx + 4y = 6",
    "output": "import numpy as np\nA = np.array([[3, -2], [1, 4]])\nb = np.array([5, 6])\nDx = np.linalg.det(np.array([[5, -2], [6, 4]]))\nDy = np.linalg.det(np.array([[3, 5], [1, 6]]))\nD = np.linalg.det(A)\nx = Dx / D\ny = Dy / D\nprint((x, y))"
  },
  {
    "input": "Determine if the following system has one solution, no solution, or infinitely many:\n2x + y = 4\n4x + 2y = 8",
    "output": "import numpy as np\nA = np.array([[2, 1], [4, 2]])\nb = np.array([4, 8])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nif rank_A == rank_Ab == A.shape[1]:\n    print(\"Unique solution\")\nelif rank_A == rank_Ab < A.shape[1]:\n    print(\"Infinite solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Given the system:\nx + y + z = 2\n2x + 3y + z = 5\n-x + y + 2z = 1\nSolve it using NumPy.",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, 3, 1], [-1, 1, 2]])\nb = np.array([2, 5, 1])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Reduce the augmented matrix to RREF:\n[1 2 3 | 9]\n[0 1 4 | 8]\n[2 4 6 | 18]",
    "output": "import sympy as sp\nA = sp.Matrix([[1,2,3,9], [0,1,4,8], [2,4,6,18]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
  },
  {
    "input": "Solve the following system using Gaussian elimination:\n2x + y - z = 8\n-3x - y + 2z = -11\n-2x + y + 2z = -3",
    "output": "import numpy as np\nfrom scipy.linalg import solve\nA = np.array([[2,1,-1], [-3,-1,2], [-2,1,2]])\nb = np.array([8, -11, -3])\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system and identify if it has a parametric solution:\n2x + 4y - 2z = 6\nx + 2y - z = 3\n0x + 0y + 0z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [2*x + 4*y - 2*z - 6, x + 2*y - z - 3]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
  },
  {
    "input": "Determine the solution type:\nx - 2y + z = 3\n2x - 4y + 2z = 6\n-3x + 6y - 3z = -9",
    "output": "import numpy as np\nA = np.array([[1,-2,1], [2,-4,2], [-3,6,-3]])\nb = np.array([3,6,-9])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nprint(\"Unique\" if rank_A == rank_Ab == A.shape[1] else \"Infinite\" if rank_A == rank_Ab else \"No solution\")"
  },
  {
    "input": "Solve for x, y using inverse matrix method:\n4x + y = 9\n2x - y = 1",
    "output": "import numpy as np\nA = np.array([[4,1],[2,-1]])\nb = np.array([9,1])\nx = np.dot(np.linalg.inv(A), b)\nprint(x)"
  },
  {
    "input": "Determine solution of augmented matrix:\n[1 2 3 | 4]\n[0 1 -1 | 2]\n[0 0 0 | 1]",
    "output": "import numpy as np\nA = np.array([[1,2,3], [0,1,-1], [0,0,0]])\nb = np.array([4,2,1])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nprint(\"No solution\" if rank_A != rank_Ab else \"Solvable\")"
  },
  {
    "input": "Given an inconsistent system:\n2x + 3y = 7\n4x + 6y = 20, verify inconsistency.",
    "output": "import numpy as np\nA = np.array([[2,3],[4,6]])\nb = np.array([7,20])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nprint(\"Inconsistent\" if rank_A != rank_Ab else \"Consistent\")"
  },
  {
    "input": "Solve the following with parametric solution:\nx + 2y + 3z = 4\n2x + 4y + 6z = 8",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [x + 2*y + 3*z - 4, 2*x + 4*y + 6*z - 8]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
  },
  {
    "input": "Use Cramer\u00e2\u20ac\u2122s Rule to solve:\n5x - y + z = 10\nx + 3y - z = 5\n2x + y + 4z = 11",
    "output": "import numpy as np\nA = np.array([[5, -1, 1], [1, 3, -1], [2, 1, 4]])\nb = np.array([10, 5, 11])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack((b, A[:,1], A[:,2])))\nDy = np.linalg.det(np.column_stack((A[:,0], b, A[:,2])))\nDz = np.linalg.det(np.column_stack((A[:,0], A[:,1], b)))\nprint((Dx/D, Dy/D, Dz/D))"
  },
  {
    "input": "Reduce the matrix to row echelon form:\n[2 1 -1 | 8]\n[-3 -1 2 | -11]\n[-2 1 2 | -3]",
    "output": "import sympy as sp\nA = sp.Matrix([[2,1,-1,8], [-3,-1,2,-11], [-2,1,2,-3]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
  },
  {
    "input": "Given augmented matrix has infinite solutions:\n[1 2 3 | 6]\n[2 4 6 | 12]\nFind the parametric form.",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [x + 2*y + 3*z - 6, 2*x + 4*y + 6*z - 12]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
  },
  {
    "input": "Check if the following system is consistent:\n3x + 6y = 12\nx + 2y = 4",
    "output": "import numpy as np\nA = np.array([[3, 6], [1, 2]])\nb = np.array([12, 4])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nprint(\"Consistent\" if rank_A == rank_Ab else \"Inconsistent\")"
  },
  {
    "input": "Solve by matrix method:\n3x - y + 2z = 5\n2x + 4y = 6\nz = 2",
    "output": "import numpy as np\nA = np.array([[3,-1,2], [2,4,0], [0,0,1]])\nb = np.array([5,6,2])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Determine the RREF of this augmented matrix:\n[1 3 | 7]\n[2 6 | 14]",
    "output": "import sympy as sp\nA = sp.Matrix([[1,3,7],[2,6,14]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
  },
  {
    "input": "Solve the homogeneous system:\n2x - 4y + 6z = 0\nx - 2y + 3z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [2*x - 4*y + 6*z, x - 2*y + 3*z]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
  },
  {
    "input": "Find the number of solutions:\nx - y + 2z = 1\n2x - 2y + 4z = 2\n3x - 3y + 6z = 3",
    "output": "import numpy as np\nA = np.array([[1,-1,2], [2,-2,4], [3,-3,6]])\nb = np.array([1,2,3])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A,b)))\nprint(\"Unique\" if rank_A == rank_Ab == A.shape[1] else \"Infinite\" if rank_A == rank_Ab else \"No solution\")"
  },
  {
    "input": "Solve for x, y, z:\n3x + 4y + z = 1\nx + y + 3z = 2\nx + 2y + z = 3",
    "output": "import numpy as np\nA = np.array([[3,4,1], [1,1,3], [1,2,1]])\nb = np.array([1,2,3])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system using Gaussian elimination:\nx + y + z = 3\nx + 2y + 3z = 7\n2x + 3y + z = 7",
    "output": "import numpy as np\nfrom scipy.linalg import solve\nA = np.array([[1,1,1],[1,2,3],[2,3,1]])\nb = np.array([3,7,7])\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system using Cramer's Rule:\n2x + 3y = 7\n4x - y = 5",
    "output": "import numpy as np\nA = np.array([[2, 3], [4, -1]])\nb = np.array([7, 5])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.array([[7, 3], [5, -1]]))\nDy = np.linalg.det(np.array([[2, 7], [4, 5]]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
  },
  {
    "input": "Determine if the system has one solution, no solution, or infinitely many solutions:\nx + 2y - z = 4\n2x + 4y - 2z = 8\n3x + 6y - 3z = 12",
    "output": "import numpy as np\nA = np.array([[1, 2, -1], [2, 4, -2], [3, 6, -3]])\nb = np.array([4, 8, 12])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nif rank_A == rank_Ab == A.shape[1]:\n    print(\"Unique solution\")\nelif rank_A == rank_Ab < A.shape[1]:\n    print(\"Infinite solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Solve the system using an augmented matrix:\n3x - y + 2z = 5\n2x + 4y - z = 6\nx - 3y + 3z = 2",
    "output": "import sympy as sp\nA = sp.Matrix([[3, -1, 2, 5], [2, 4, -1, 6], [1, -3, 3, 2]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
  },
  {
    "input": "Find the parametric solution of the system:\nx - y + 2z = 3\n2x - 2y + 4z = 6\n-x + y - 2z = -3",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [x - y + 2*z - 3, 2*x - 2*y + 4*z - 6, -x + y - 2*z + 3]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
  },
  {
    "input": "Determine the solution type of the system:\n2x + 3y = 6\n4x + 6y = 12\n6x + 9y = 18",
    "output": "import numpy as np\nA = np.array([[2, 3], [4, 6], [6, 9]])\nb = np.array([6, 12, 18])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nif rank_A == rank_Ab == A.shape[1]:\n    print(\"Unique solution\")\nelif rank_A == rank_Ab < A.shape[1]:\n    print(\"Infinite solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Solve the system using the inverse matrix method:\n4x - y = 7\n2x + 3y = 5",
    "output": "import numpy as np\nA = np.array([[4, -1], [2, 3]])\nb = np.array([7, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Reduce the augmented matrix to row echelon form:\n[2 1 -1 | 3]\n[4 -6 0 | -2]\n[-2 7 2 | 5]",
    "output": "import sympy as sp\nA = sp.Matrix([[2, 1, -1, 3], [4, -6, 0, -2], [-2, 7, 2, 5]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
  },
  {
    "input": "Solve the system using Gaussian elimination:\n2x - y + z = 1\nx + y - z = 3\n3x - y + 2z = 4",
    "output": "import numpy as np\nA = np.array([[2, -1, 1], [1, 1, -1], [3, -1, 2]])\nb = np.array([1, 3, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Determine if the system is consistent or inconsistent:\n3x - 2y = 5\n6x - 4y = 10\n9x - 6y = 15",
    "output": "import numpy as np\nA = np.array([[3, -2], [6, -4], [9, -6]])\nb = np.array([5, 10, 15])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nif rank_A == rank_Ab:\n    print(\"Consistent\")\nelse:\n    print(\"Inconsistent\")"
  },
  {
    "input": "Find the parametric solution of the homogeneous system:\nx + 2y - z = 0\n2x + 4y - 2z = 0\n-x - 2y + z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [x + 2*y - z, 2*x + 4*y - 2*z, -x - 2*y + z]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
  },
  {
    "input": "Solve the system using Cramer's Rule:\n5x + 2y - z = 10\n3x - y + 4z = 5\nx + 3y + 2z = 7",
    "output": "import numpy as np\nA = np.array([[5, 2, -1], [3, -1, 4], [1, 3, 2]])\nb = np.array([10, 5, 7])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:,1], A[:,2]]))\nDy = np.linalg.det(np.column_stack([A[:,0], b, A[:,2]]))\nDz = np.linalg.det(np.column_stack([A[:,0], A[:,1], b]))\nx = Dx / D\ny = Dy / D\nz = Dz / D\nprint((x, y, z))"
  },
  {
    "input": "Solve the system using matrix inverse method:\n3x + y - z = 1\n2x - 2y + 4z = -2\n-x + 0.5y - z = 0",
    "output": "import numpy as np\nA = np.array([[3, 1, -1], [2, -2, 4], [-1, 0.5, -1]])\nb = np.array([1, -2, 0])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n4x - y + z = 7\n2x + 3y + z = 4\nx + y - z = -2",
    "output": "import numpy as np\nA = np.array([[4, -1, 1], [2, 3, 1], [1, 1, -1]])\nb = np.array([7, 4, -2])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Find the general solution to the system:\n2x - y + 3z = 4\n-x + 2y - z = 1\nx + y + z = 6",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [2*x - y + 3*z - 4, -x + 2*y - z - 1, x + y + z - 6]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
  },
  {
    "input": "Determine if the system has infinite, unique, or no solutions:\nx + y + z = 6\n2x + 2y + 2z = 12\n3x + 3y + 3z = 18",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])\nb = np.array([6, 12, 18])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack([A, b]))\nif rank_A == rank_Ab == A.shape[1]:\n    print(\"Unique solution\")\nelif rank_A == rank_Ab < A.shape[1]:\n    print(\"Infinite solutions\")\nelse:\n    print(\"No solution\")"
  },
  {
    "input": "Use Gauss-Jordan elimination to solve:\n1x + 2y - z = 3\n2x + 3y + 2z = 7\n3x + y + 4z = 10",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, -1, 3], [2, 3, 2, 7], [3, 1, 4, 10]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
  },
  {
    "input": "Write the augmented matrix and solve:\n5x - y = 9\n3x + 4y = 1",
    "output": "import sympy as sp\nA = sp.Matrix([[5, -1, 9], [3, 4, 1]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
  },
  {
    "input": "Determine the solution set of the homogeneous system:\n3x - y + 4z = 0\n2x + 5y - z = 0\nx + 2y + 3z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [3*x - y + 4*z, 2*x + 5*y - z, x + 2*y + 3*z]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
  },
  {
    "input": "Check consistency of the system:\n2x + y + z = 5\nx - y - z = 0\n3x + y + z = 6",
    "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, -1, -1], [3, 1, 1]])\nb = np.array([5, 0, 6])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nprint(\"Consistent\" if rank_A == rank_Ab else \"Inconsistent\")"
  },
  {
    "input": "Use matrix methods to solve:\n7x + 2y - 3z = 5\n2x - 5y + z = -1\n4x + 3y + 2z = 10",
    "output": "import numpy as np\nA = np.array([[7, 2, -3], [2, -5, 1], [4, 3, 2]])\nb = np.array([5, -1, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system using the substitution method:\n3x + 4y = 12\nx - 2y = 5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 12)\neq2 = sp.Eq(x - 2*y, 5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n5x - 3y = -14\n3x + y = 0",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x - 3*y, -14)\neq2 = sp.Eq(3*x + y, 0)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system by graphing:\ny = -2x + 3\ny = x - 4",
    "output": "import numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(-10, 10, 400)\ny1 = -2*x + 3\ny2 = x - 4\nplt.plot(x, y1, label='y = -2x + 3')\nplt.plot(x, y2, label='y = x - 4')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.grid(True)\nplt.show()"
  },
  {
    "input": "Determine the number of solutions for the system:\n2x + 3y = 6\n4x + 6y = 12",
    "output": "import numpy as np\nA = np.array([[2, 3], [4, 6]])\nb = np.array([6, 12])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nif rank_A == rank_Ab == A.shape[1]:\n    print('Unique solution')\nelif rank_A == rank_Ab < A.shape[1]:\n    print('Infinite solutions')\nelse:\n    print('No solution')"
  },
  {
    "input": "Solve the system using matrices:\n3x + 2y = 5\n7x - 4y = 10",
    "output": "import numpy as np\nA = np.array([[3, 2], [7, -4]])\nb = np.array([5, 10])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system of three variables:\n2x - y + z = 3\nx + y - z = 0\n3x - 2y + 4z = 5",
    "output": "import numpy as np\nA = np.array([[2, -1, 1], [1, 1, -1], [3, -2, 4]])\nb = np.array([3, 0, 5])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A store sells apples and oranges. An apple costs $0.50 and an orange costs $0.80. If a customer buys 10 fruits for $7.00, how many of each did they buy?",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 10)\neq2 = sp.Eq(0.5*x + 0.8*y, 7)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Find the inverse of the matrix and use it to solve the system:\n[2 3]\n[4 5]\nwith b = [1 2]",
    "output": "import numpy as np\nA = np.array([[2, 3], [4, 5]])\nb = np.array([1, 2])\nA_inv = np.linalg.inv(A)\nx = np.dot(A_inv, b)\nprint(x)"
  },
  {
    "input": "Solve the system using determinants:\n3x - y = 2\n2x + 4y = 10",
    "output": "import numpy as np\nA = np.array([[3, -1], [2, 4]])\nb = np.array([2, 10])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:,1]]))\nDy = np.linalg.det(np.column_stack([A[:,0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
  },
  {
    "input": "A company produces two products, A and B. Each unit of A requires 2 hours of labor and 3 units of material. Each unit of B requires 1 hour of labor and 2 units of material. The company has 100 hours of labor and 120 units of material available. How many units of each product should be produced to use all resources?",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + y, 100)\neq2 = sp.Eq(3*x + 2*y, 120)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n4x - 2y = 8\nx + y = 3",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x - 2*y, 8)\neq2 = sp.Eq(x + y, 3)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n6x + 4y = 20\n3x - 2y = 5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x + 4*y, 20)\neq2 = sp.Eq(3*x - 2*y, 5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Determine if the following system has one solution, no solution, or infinitely many solutions:\n2x - y = 4\n4x - 2y = 8",
    "output": "import numpy as np\nA = np.array([[2, -1], [4, -2]])\nb = np.array([4, 8])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nif rank_A == rank_Ab == A.shape[1]:\n    print('Unique solution')\nelif rank_A == rank_Ab < A.shape[1]:\n    print('Infinite solutions')\nelse:\n    print('No solution')"
  },
  {
    "input": "Solve the system of equations:\nx + 2y + 3z = 14\n2x + 3y + z = 13\n3x + y + 2z = 13",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 3, 1], [3, 1, 2]])\nb = np.array([14, 13, 13])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system using matrix inversion:\n[1 2]\n[3 4]\nb = [5 11]",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nb = np.array([5, 11])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "A small business makes two products. Each product A earns $40 profit and product B earns $30 profit. Each A takes 1 hour on machine 1 and 2 hours on machine 2. Each B takes 2 hours on machine 1 and 1 hour on machine 2. The company has 40 hours on machine 1 and 50 hours on machine 2. How many of each product to maximize profit using all available time?",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + 2*y, 40)\neq2 = sp.Eq(2*x + y, 50)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n2x - y + z = 2\n3x + 2y - 4z = -2\n-x + 0.5y - z = 0",
    "output": "import sympy as sp\nA = sp.Matrix([[2, -1, 1, 2], [3, 2, -4, -2], [-1, 0.5, -1, 0]])\nA_rref, _ = A.rref()\nsp.pprint(A_rref)"
  },
  {
    "input": "Given the system:\n3x + 4y - 2z = 7\n-2x + y + 3z = -5\nx - y + z = 4\nFind the solution.",
    "output": "import numpy as np\nA = np.array([[3, 4, -2], [-2, 1, 3], [1, -1, 1]])\nb = np.array([7, -5, 4])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Check the consistency and solve the system:\n2x + y + z = 8\n4x + 2y + 2z = 16\nx - y + z = 2",
    "output": "import numpy as np\nA = np.array([[2, 1, 1], [4, 2, 2], [1, -1, 1]])\nb = np.array([8, 16, 2])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nif rank_A == rank_Ab:\n    x = np.linalg.lstsq(A, b, rcond=None)[0]\n    print(x)\nelse:\n    print('Inconsistent system')"
  },
  {
    "input": "Solve the following system with parametric solution (underdetermined):\nx + y + z = 3\n2x + 3y + 4z = 7",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [x + y + z - 3, 2*x + 3*y + 4*z - 7]\nsol = sp.linsolve(eqs, x, y, z)\nprint(sol)"
  },
  {
    "input": "Solve the system:\nx - y = 1\n2x + 3y = 12",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x - y, 1)\neq2 = sp.Eq(2*x + 3*y, 12)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n2x + 3y = 16\n4x - y = 9",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 16)\neq2 = sp.Eq(4*x - y, 9)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n5x + 2y = 20\n3x - 4y = -6",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x + 2*y, 20)\neq2 = sp.Eq(3*x - 4*y, -6)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system by graphing:\ny = 3x + 1\ny = -2x + 6",
    "output": "import numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(-10, 10, 400)\ny1 = 3*x + 1\ny2 = -2*x + 6\nplt.plot(x, y1, label='y = 3x + 1')\nplt.plot(x, y2, label='y = -2x + 6')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.grid(True)\nplt.show()"
  },
  {
    "input": "Determine the number of solutions for the system:\n3x - 2y = 5\n6x - 4y = 10",
    "output": "import numpy as np\nA = np.array([[3, -2], [6, -4]])\nb = np.array([5, 10])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nif rank_A == rank_Ab == A.shape[1]:\n    print('Unique solution')\nelif rank_A == rank_Ab < A.shape[1]:\n    print('Infinite solutions')\nelse:\n    print('No solution')"
  },
  {
    "input": "Solve the system using matrices:\n2x - y = 4\nx + 3y = 7",
    "output": "import numpy as np\nA = np.array([[2, -1], [1, 3]])\nb = np.array([4, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system of three variables:\nx + y + z = 6\n2x - y + 3z = 14\n-3x + 4y - z = -2",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [2, -1, 3], [-3, 4, -1]])\nb = np.array([6, 14, -2])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A farmer has 100 acres of land to plant wheat and corn. Each acre of wheat yields $200 profit, and each acre of corn yields $300 profit. The farmer wants to plant all 100 acres and maximize profit. How many acres of each should be planted?",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 100)\neq2 = sp.Eq(200*x + 300*y, 200*x + 300*(100 - x))\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Find the inverse of the matrix and use it to solve the system:\n[3 2]\n[1 4]\nwith b = [7 10]",
    "output": "import numpy as np\nA = np.array([[3, 2], [1, 4]])\nb = np.array([7, 10])\nA_inv = np.linalg.inv(A)\nx = np.dot(A_inv, b)\nprint(x)"
  },
  {
    "input": "Solve the system using determinants:\n4x + y = 9\n2x - 3y = -4",
    "output": "import numpy as np\nA = np.array([[4, 1], [2, -3]])\nb = np.array([9, -4])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:,1]]))\nDy = np.linalg.det(np.column_stack([A[:,0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
  },
  {
    "input": "A company produces two products, X and Y. Each unit of X requires 3 hours of labor and 2 units of material. Each unit of Y requires 2 hours of labor and 4 units of material. The company has 120 hours of labor and 160 units of material available. How many units of each product should be produced to use all resources?",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 2*y, 120)\neq2 = sp.Eq(2*x + 4*y, 160)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n3x - y = 7\n2x + 4y = 10",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - y, 7)\neq2 = sp.Eq(2*x + 4*y, 10)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n7x + 5y = 19\n4x - 3y = 2",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x + 5*y, 19)\neq2 = sp.Eq(4*x - 3*y, 2)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using matrices:\n3x - 4y + z = 2\nx + 5y - 2z = 3\n2x - y + 3z = -1",
    "output": "import numpy as np\nA = np.array([[3, -4, 1], [1, 5, -2], [2, -1, 3]])\nb = np.array([2, 3, -1])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n2x + 3y = 8\n4x - y = 2",
    "output": "import numpy as np\nA = np.array([[2, 3], [4, -1]])\nb = np.array([8, 2])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack((b, A[:,1])))\nDy = np.linalg.det(np.column_stack((A[:,0], b)))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
  },
  {
    "input": "Solve the 3x3 system with infinite solutions:\nx + y + z = 6\n2x + 2y + 2z = 12\n3x + 3y + 3z = 18",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 6)\neq2 = sp.Eq(2*x + 2*y + 2*z, 12)\neq3 = sp.Eq(3*x + 3*y + 3*z, 18)\nsol = sp.linsolve([eq1, eq2, eq3], x, y, z)\nprint(sol)"
  },
  {
    "input": "A chemist needs to mix a 10% acid solution with a 40% acid solution to get 20 liters of a 25% acid solution. How much of each solution is needed?",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 20)\neq2 = sp.Eq(0.10*x + 0.40*y, 0.25*20)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the following system using Gaussian elimination:\n1x + 2y + 3z = 9\n2x + 5y + 2z = 20\n4x + 2y + 5z = 31",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 3, 9], [2, 5, 2, 20], [4, 2, 5, 31]])\nrref, _ = A.rref()\nsp.pprint(rref)"
  },
  {
    "input": "Find whether the system has no solution, infinite solutions, or a unique solution:\n4x + y - 2z = 1\n2x - y + 3z = 7\nx + 3y - z = 4",
    "output": "import numpy as np\nA = np.array([[4, 1, -2], [2, -1, 3], [1, 3, -1]])\nb = np.array([1, 7, 4])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nif rank_A == rank_Ab == A.shape[1]:\n    print('Unique solution')\nelif rank_A == rank_Ab < A.shape[1]:\n    print('Infinite solutions')\nelse:\n    print('No solution')"
  },
  {
    "input": "Use substitution to solve:\n3x + y = 10\nx = 2y - 4",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + y, 10)\neq2 = sp.Eq(x, 2*y - 4)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve using numpy:\n[2x - 3y = 1, x + 4y = 7]",
    "output": "import numpy as np\nA = np.array([[2, -3], [1, 4]])\nb = np.array([1, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the following system:\n3a + 4b = 10\n6a - 2b = 8",
    "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(3*a + 4*b, 10)\neq2 = sp.Eq(6*a - 2*b, 8)\nsol = sp.solve((eq1, eq2), (a, b))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n2x + 3y + z = 5\n4x + y - z = 6\n-2x + 5y + 2z = -3",
    "output": "import numpy as np\nA = np.array([[2, 3, 1], [4, 1, -1], [-2, 5, 2]])\nb = np.array([5, 6, -3])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A boat travels 24 miles downstream in 2 hours and returns upstream in 3 hours. Find the speed of the boat in still water and the speed of the current.",
    "output": "import sympy as sp\nb, c = sp.symbols('b c')\neq1 = sp.Eq(2*(b + c), 24)\neq2 = sp.Eq(3*(b - c), 24)\nsol = sp.solve((eq1, eq2), (b, c))\nprint(sol)"
  },
  {
    "input": "Solve the system with fractions:\n(1/2)x + (1/3)y = 1\n(2/3)x - (1/4)y = 2",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq((1/2)*x + (1/3)*y, 1)\neq2 = sp.Eq((2/3)*x - (1/4)*y, 2)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Determine whether the system has a solution:\n2x - y + z = 1\n4x - 2y + 2z = 2\nx + y - z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x - y + z, 1)\neq2 = sp.Eq(4*x - 2*y + 2*z, 2)\neq3 = sp.Eq(x + y - z, 0)\nsol = sp.linsolve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Use matrix row operations to solve:\n3x + y = 7\n2x - 5y = -3",
    "output": "import sympy as sp\nA = sp.Matrix([[3, 1, 7], [2, -5, -3]])\nrref, _ = A.rref()\nsp.pprint(rref)"
  },
  {
    "input": "You buy 5 notebooks and 3 pens for $13.50. Your friend buys 3 notebooks and 4 pens for $11. How much is each notebook and pen?",
    "output": "import sympy as sp\nn, p = sp.symbols('n p')\neq1 = sp.Eq(5*n + 3*p, 13.50)\neq2 = sp.Eq(3*n + 4*p, 11)\nsol = sp.solve((eq1, eq2), (n, p))\nprint(sol)"
  },
  {
    "input": "Solve the following system of 3 equations:\nx - y + 2z = 4\n3x + 2y - z = 5\n2x + y + z = 7",
    "output": "import numpy as np\nA = np.array([[1, -1, 2], [3, 2, -1], [2, 1, 1]])\nb = np.array([4, 5, 7])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system:\n4a + 2b = 8\n3a - b = 5",
    "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(4*a + 2*b, 8)\neq2 = sp.Eq(3*a - b, 5)\nsol = sp.solve((eq1, eq2), (a, b))\nprint(sol)"
  },
  {
    "input": "A car rental company charges $25 per day and $0.10 per mile. Another company charges $30 per day and $0.05 per mile. At how many miles will the cost be the same?",
    "output": "import sympy as sp\nm = sp.symbols('m')\neq = sp.Eq(25 + 0.10*m, 30 + 0.05*m)\nsol = sp.solve(eq, m)\nprint(sol)"
  },
  {
    "input": "Solve the system with decimals:\n1.2x + 3.5y = 7.6\n0.8x - 1.2y = 2.4",
    "output": "import numpy as np\nA = np.array([[1.2, 3.5], [0.8, -1.2]])\nb = np.array([7.6, 2.4])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve this word problem:\nThe sum of two numbers is 10. Their difference is 4. What are the numbers?",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 10)\neq2 = sp.Eq(x - y, 4)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n5x - 2y + z = 3\nx + y - z = 4\n2x - 3y + 2z = -6",
    "output": "import numpy as np\nA = np.array([[5, -2, 1], [1, 1, -1], [2, -3, 2]])\nb = np.array([3, 4, -6])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system:\n3x + 2y - z = 1\n2x - 2y + 4z = -2\n-1x + 0.5y - z = 0",
    "output": "import numpy as np\nA = np.array([[3, 2, -1], [2, -2, 4], [-1, 0.5, -1]])\nb = np.array([1, -2, 0])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve this practical system:\nYou buy 2 burgers and 3 drinks for $12. Your friend buys 3 burgers and 2 drinks for $13. How much is each burger and drink?",
    "output": "import sympy as sp\nb, d = sp.symbols('b d')\neq1 = sp.Eq(2*b + 3*d, 12)\neq2 = sp.Eq(3*b + 2*d, 13)\nsol = sp.solve((eq1, eq2), (b, d))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n2x - 3y = 7\n4x + y = 5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x - 3*y, 7)\neq2 = sp.Eq(4*x + y, 5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n3x + 4y = 12\n5x - 2y = 10",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 12)\neq2 = sp.Eq(5*x - 2*y, 10)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Determine the number of solutions for the system:\n6x - 2y = 8\n3x - y = 4",
    "output": "import numpy as np\nA = np.array([[6, -2], [3, -1]])\nb = np.array([8, 4])\nrank_A = np.linalg.matrix_rank(A)\nrank_Ab = np.linalg.matrix_rank(np.column_stack((A, b)))\nif rank_A == rank_Ab == A.shape[1]:\n    print('Unique solution')\nelif rank_A == rank_Ab < A.shape[1]:\n    print('Infinite solutions')\nelse:\n    print('No solution')"
  },
  {
    "input": "Solve the system using matrices:\n7x + 5y = 2\n3x - y = 6",
    "output": "import numpy as np\nA = np.array([[7, 5], [3, -1]])\nb = np.array([2, 6])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve the system of three variables:\n2x + y - z = 4\nx - 2y + 3z = -1\n3x + 4y - 5z = 2",
    "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, -2, 3], [3, 4, -5]])\nb = np.array([4, -1, 2])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A store sells two types of coffee: regular and premium. Regular coffee costs $5 per pound, and premium coffee costs $8 per pound. If a customer buys 10 pounds of coffee for a total of $70, how many pounds of each type did they purchase?",
    "output": "import sympy as sp\nr, p = sp.symbols('r p')\neq1 = sp.Eq(r + p, 10)\neq2 = sp.Eq(5*r + 8*p, 70)\nsol = sp.solve((eq1, eq2), (r, p))\nprint(sol)"
  },
  {
    "input": "Find the inverse of the matrix and use it to solve the system:\n[3 4]\n[2 5]\nwith b = [7 12]",
    "output": "import numpy as np\nA = np.array([[3, 4], [2, 5]])\nb = np.array([7, 12])\nA_inv = np.linalg.inv(A)\nx = np.dot(A_inv, b)\nprint(x)"
  },
  {
    "input": "Solve the system using determinants:\n4x - y = 9\n2x + 3y = 5",
    "output": "import numpy as np\nA = np.array([[4, -1], [2, 3]])\nb = np.array([9, 5])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:,1]]))\nDy = np.linalg.det(np.column_stack([A[:,0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
  },
  {
    "input": "A company produces two products: desks and chairs. Each desk requires 4 hours of labor and 3 units of material. Each chair requires 2 hours of labor and 1 unit of material. The company has 100 hours of labor and 50 units of material available. How many desks and chairs should be produced to use all resources?",
    "output": "import sympy as sp\nd, c = sp.symbols('d c')\neq1 = sp.Eq(4*d + 2*c, 100)\neq2 = sp.Eq(3*d + c, 50)\nsol = sp.solve((eq1, eq2), (d, c))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n5x - y = 3\nx + 3y = 7",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x - y, 3)\neq2 = sp.Eq(x + 3*y, 7)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n2x + 3y = 8\n4x - y = 6",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 8)\neq2 = sp.Eq(4*x - y, 6)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system by graphing:\ny = -2x + 5\ny = x - 3",
    "output": "import numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(-10, 10, 400)\ny1 = -2*x + 5\ny2 = x - 3\nplt.plot(x, y1, label='y = -2x + 5')\nplt.plot(x, y2, label='y = x - 3')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.grid(True)\nplt.show()"
  },
  {
    "input": "Determine the number of solutions for the system:\n3x - y + 2z = 7\n6x - 2y + 4z = 14\n-x + y - z = -3",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(3*x - y + 2*z, 7)\neq2 = sp.Eq(6*x - 2*y + 4*z, 14)\neq3 = sp.Eq(-x + y - z, -3)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z), dict=True)\nprint(sol)"
  },
  {
    "input": "Solve using Cramer's Rule:\n4x + 2y = 10\n3x + 5y = 11",
    "output": "import numpy as np\nA = np.array([[4, 2], [3, 5]])\nb = np.array([10, 11])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:, 1]]))\nDy = np.linalg.det(np.column_stack([A[:, 0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
  },
  {
    "input": "Use the augmented matrix to determine the type of solution for the system:\n2x - y + 3z = 4\n-x + 4y - z = 2\nx + y + z = 0",
    "output": "import sympy as sp\nA = sp.Matrix([[2, -1, 3, 4], [-1, 4, -1, 2], [1, 1, 1, 0]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "A system has a parameter. Solve the system:\nx + 2y + z = 3\n2x + 5y + 3z = 8\nx + 3y + 2z = 5",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + 2*y + z, 3)\neq2 = sp.Eq(2*x + 5*y + 3*z, 8)\neq3 = sp.Eq(x + 3*y + 2*z, 5)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z), dict=True)\nprint(sol)"
  },
  {
    "input": "Solve this homogeneous system:\n3x - 2y + z = 0\n-6x + 4y - 2z = 0\n9x - 6y + 3z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(3*x - 2*y + z, 0)\neq2 = sp.Eq(-6*x + 4*y - 2*z, 0)\neq3 = sp.Eq(9*x - 6*y + 3*z, 0)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z), dict=True)\nprint(sol)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n[2 1 -1 | 3]\n[-3 -1 2 | -11]\n[-2 1 2 | -3]",
    "output": "import sympy as sp\nA = sp.Matrix([[2, 1, -1, 3], [-3, -1, 2, -11], [-2, 1, 2, -3]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Find the general solution to the system:\nx + 2y - z = 4\n2x + 4y - 2z = 8\n3x + 6y - 3z = 12",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + 2*y - z, 4)\neq2 = sp.Eq(2*x + 4*y - 2*z, 8)\neq3 = sp.Eq(3*x + 6*y - 3*z, 12)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z), dict=True)\nprint(sol)"
  },
  {
    "input": "Use matrix inverse to solve:\n[1 2]\n[3 4] * [x y]^T = [5 6]^T",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nb = np.array([5, 6])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Use LU decomposition to solve:\nA = [[4, 3], [6, 3]], b = [10, 12]",
    "output": "import scipy.linalg as la\nimport numpy as np\nA = np.array([[4, 3], [6, 3]])\nb = np.array([10, 12])\nP, L, U = la.lu(A)\ny = np.linalg.solve(L, np.dot(P.T, b))\nx = np.linalg.solve(U, y)\nprint(x)"
  },
  {
    "input": "Solve by Gauss-Jordan elimination:\n[1 -2 3 | 9]\n[2 1 2 | 8]\n[3 0 -1 | 3]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, -2, 3, 9], [2, 1, 2, 8], [3, 0, -1, 3]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Determine if the system has unique, infinite or no solutions:\n[1 2 -1 | 3]\n[2 4 -2 | 6]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, -1, 3], [2, 4, -2, 6]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Solve this system:\n5x - 3y + z = -1\n2x + 4y - 3z = 7\nx + y + z = 2",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(5*x - 3*y + z, -1)\neq2 = sp.Eq(2*x + 4*y - 3*z, 7)\neq3 = sp.Eq(x + y + z, 2)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(sol)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n2x + y = 1\n3x - y = 2",
    "output": "import numpy as np\nA = np.array([[2, 1], [3, -1]])\nb = np.array([1, 2])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:, 1]]))\nDy = np.linalg.det(np.column_stack([A[:, 0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
  },
  {
    "input": "A linear system has the augmented matrix:\n[1 2 3 | 4]\n[0 1 4 | 5]\n[0 0 0 | 1]. Determine if the system has a solution.",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 3, 4], [0, 1, 4, 5], [0, 0, 0, 1]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Solve the system using matrix inverse:\n3x + 4y = 5\n2x + y = 1",
    "output": "import numpy as np\nA = np.array([[3, 4], [2, 1]])\nb = np.array([5, 1])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve the homogeneous system:\n2x - 4y + 6z = 0\n-x + 2y - 3z = 0\n4x - 8y + 12z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x - 4*y + 6*z, 0)\neq2 = sp.Eq(-x + 2*y - 3*z, 0)\neq3 = sp.Eq(4*x - 8*y + 12*z, 0)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z), dict=True)\nprint(sol)"
  },
  {
    "input": "Solve this system of three equations with three unknowns:\n4x - y + z = 7\n2x + 3y - z = 4\n-x + 2y + 5z = 6",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - y + z, 7)\neq2 = sp.Eq(2*x + 3*y - z, 4)\neq3 = sp.Eq(-x + 2*y + 5*z, 6)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Determine if the following system has a unique solution:\n2x - y = 4\n-4x + 2y = -8",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x - y, 4)\neq2 = sp.Eq(-4*x + 2*y, -8)\nsol = sp.solve([eq1, eq2], (x, y), dict=True)\nprint(sol)"
  },
  {
    "input": "Solve using Gauss-Jordan elimination:\n[1 1 -1 | 9]\n[2 -1 1 | -2]\n[3 2 -4 | 3]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 1, -1, 9], [2, -1, 1, -2], [3, 2, -4, 3]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Find the general solution of:\nx - y + 2z = 3\n2x - 2y + 4z = 6",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x - y + 2*z, 3)\neq2 = sp.Eq(2*x - 2*y + 4*z, 6)\nsol = sp.solve([eq1, eq2], (x, y, z), dict=True)\nprint(sol)"
  },
  {
    "input": "Solve using Cramer's Rule:\n7x + 4y = 13\n5x - 2y = 3",
    "output": "import numpy as np\nA = np.array([[7, 4], [5, -2]])\nb = np.array([13, 3])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:, 1]]))\nDy = np.linalg.det(np.column_stack([A[:, 0], b]))\nx = Dx / D\ny = Dy / D\nprint((x, y))"
  },
  {
    "input": "Solve the system:\nx + y + z = 1\nx - y + z = 3\n2x + y + 3z = 4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 1)\neq2 = sp.Eq(x - y + z, 3)\neq3 = sp.Eq(2*x + y + 3*z, 4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n[3 2 -1 | 1]\n[2 -2 4 | -2]\n[-1 0.5 -1 | 0]",
    "output": "import sympy as sp\nA = sp.Matrix([[3, 2, -1, 1], [2, -2, 4, -2], [-1, 0.5, -1, 0]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Solve by finding the inverse of the matrix:\n[1 2 3]\n[0 1 4]\n[5 6 0] and b = [6 4 2]",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\nb = np.array([6, 4, 2])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve the linear system:\n4x - y + 3z = 7\n2x + y - z = 3\n-2x + 5y + 2z = 9",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - y + 3*z, 7)\neq2 = sp.Eq(2*x + y - z, 3)\neq3 = sp.Eq(-2*x + 5*y + 2*z, 9)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Determine if the system is consistent:\n[1 0 0 | 2]\n[0 1 0 | 3]\n[0 0 0 | 1]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 0, 0, 2], [0, 1, 0, 3], [0, 0, 0, 1]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Solve:\n3x + y = 10\n2x - y = 3",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + y, 10)\neq2 = sp.Eq(2*x - y, 3)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Use LU decomposition to solve:\nA = [[2, 1], [8, 7]], b = [3, 24]",
    "output": "import scipy.linalg as la\nimport numpy as np\nA = np.array([[2, 1], [8, 7]])\nb = np.array([3, 24])\nP, L, U = la.lu(A)\ny = np.linalg.solve(L, P.T @ b)\nx = np.linalg.solve(U, y)\nprint(x)"
  },
  {
    "input": "Solve the following matrix equation:\nAX = B where A = [[1, 2], [3, 4]], B = [[5], [11]]",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5], [11]])\nX = np.linalg.solve(A, B)\nprint(X)"
  },
  {
    "input": "Is the following system inconsistent?\n[1 2 3 | 4]\n[0 0 0 | 1]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 3, 4], [0, 0, 0, 1]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Use parametric form to solve:\nx - y + 2z = 3\n2x - 2y + 4z = 6\n-3x + 3y - 6z = -9",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x - y + 2*z, 3)\neq2 = sp.Eq(2*x - 2*y + 4*z, 6)\neq3 = sp.Eq(-3*x + 3*y - 6*z, -9)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z), dict=True)\nprint(sol)"
  },
  {
    "input": "Solve:\nx + y + z = 0\n2x + 3y + z = 1\n3x + 5y + 2z = 3",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 0)\neq2 = sp.Eq(2*x + 3*y + z, 1)\neq3 = sp.Eq(3*x + 5*y + 2*z, 3)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Use augmented matrix to find solution of:\n[2 3 | 5]\n[4 6 | 10]",
    "output": "import sympy as sp\nA = sp.Matrix([[2, 3, 5], [4, 6, 10]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Solve:\n2x + y + z = 7\nx + 3y + 2z = 13\n3x + y + 4z = 15",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + y + z, 7)\neq2 = sp.Eq(x + 3*y + 2*z, 13)\neq3 = sp.Eq(3*x + y + 4*z, 15)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n2x + 3y = 12\nx - y = 4",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 12)\neq2 = sp.Eq(x - y, 4)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n3x - 2y = 5\n5x + 3y = 7",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - 2*y, 5)\neq2 = sp.Eq(5*x + 3*y, 7)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system of equations:\n4x + 5y - z = 10\n2x - y + 3z = 5\nx + 2y + 4z = 8",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x + 5*y - z, 10)\neq2 = sp.Eq(2*x - y + 3*z, 5)\neq3 = sp.Eq(x + 2*y + 4*z, 8)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Determine if the system has a unique solution, no solution, or infinitely many solutions:\n2x - 4y = 6\nx - 2y = 3",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x - 4*y, 6)\neq2 = sp.Eq(x - 2*y, 3)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using matrix inversion:\n3x + 4y = 10\n5x - 2y = -3",
    "output": "import numpy as np\nA = np.array([[3, 4], [5, -2]])\nb = np.array([10, -3])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve the system using Cramer's Rule:\n2x + y - z = 3\nx - y + 2z = -2\n3x + 2y + z = 1",
    "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, -1, 2], [3, 2, 1]])\nb = np.array([3, -2, 1])\nD = np.linalg.det(A)\nDx = np.linalg.det(np.column_stack([b, A[:, 1], A[:, 2]]))\nDy = np.linalg.det(np.column_stack([A[:, 0], b, A[:, 2]]))\nDz = np.linalg.det(np.column_stack([A[:, 0], A[:, 1], b]))\nx = Dx / D\ny = Dy / D\nz = Dz / D\nprint((x, y, z))"
  },
  {
    "input": "Solve the system using Gaussian elimination:\n[1 2 3 | 4]\n[2 3 4 | 5]\n[3 4 5 | 6]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Solve the system:\n3x + 2y = 8\nx - 4y = -2",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 2*y, 8)\neq2 = sp.Eq(x - 4*y, -2)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n2x - y + 3z = 7\nx + 4y - z = -1\n3x + y + 2z = 5",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x - y + 3*z, 7)\neq2 = sp.Eq(x + 4*y - z, -1)\neq3 = sp.Eq(3*x + y + 2*z, 5)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n5x + 3y = 11\n3x - 2y = 4",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x + 3*y, 11)\neq2 = sp.Eq(3*x - 2*y, 4)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n4x - y = 2\n2x + 3y = 12",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x - y, 2)\neq2 = sp.Eq(2*x + 3*y, 12)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n3x - y + 2z = 5\n2x + 4y - z = -1\nx - 2y + z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(3*x - y + 2*z, 5)\neq2 = sp.Eq(2*x + 4*y - z, -1)\neq3 = sp.Eq(x - 2*y + z, 0)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Solve the system:\nx + y = 6\nx - y = 4",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 6)\neq2 = sp.Eq(x - y, 4)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n4x + y = 7\n-2x + 3y = 1",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x + y, 7)\neq2 = sp.Eq(-2*x + 3*y, 1)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using matrices:\n[2 1 -1 | 8]\n[-3 -1 2 | -11]\n[-2 1 2 | -3]",
    "output": "import sympy as sp\nA = sp.Matrix([[2, 1, -1, 8], [-3, -1, 2, -11], [-2, 1, 2, -3]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Determine if the system is consistent and has a unique solution:\n2x + 4y = 10\nx + 2y = 5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 4*y, 10)\neq2 = sp.Eq(x + 2*y, 5)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Find the solution to the system:\n5x - 3y + 2z = 3\n4x + y - z = 2\n-x + 2y + 5z = -4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(5*x - 3*y + 2*z, 3)\neq2 = sp.Eq(4*x + y - z, 2)\neq3 = sp.Eq(-x + 2*y + 5*z, -4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Solve the system using the inverse matrix method:\n[1 2 3 | 9]\n[0 1 4 | 10]\n[5 6 0 | 2]",
    "output": "import numpy as np\nA = np.array([[1,2,3], [0,1,4], [5,6,0]])\nb = np.array([9,10,2])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve the system:\n2x + 3y = 12\n4x + 6y = 24",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 12)\neq2 = sp.Eq(4*x + 6*y, 24)\nsol = sp.solve([eq1, eq2], (x, y), dict=True)\nprint(sol)"
  },
  {
    "input": "Solve the system:\nx - y + z = 0\n2x + y - z = 3\n3x + 2y + z = 5",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x - y + z, 0)\neq2 = sp.Eq(2*x + y - z, 3)\neq3 = sp.Eq(3*x + 2*y + z, 5)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Find the values of a and b that make the system consistent:\nx + ay = 2\n2x + 4y = b",
    "output": "import sympy as sp\nx, y, a, b = sp.symbols('x y a b')\neq1 = sp.Eq(x + a*y, 2)\neq2 = sp.Eq(2*x + 4*y, b)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n[1 -1 2 | 3]\n[3 2 -4 | -10]\n[2 3 -1 | 1]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, -1, 2, 3], [3, 2, -4, -10], [2, 3, -1, 1]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Solve using Cramer's Rule:\n2x + 5y = 20\n4x + 10y = 40",
    "output": "import numpy as np\nA = np.array([[2, 5], [4, 10]])\nb = np.array([20, 40])\nD = np.linalg.det(A)\nif D == 0:\n    print('No unique solution')\nelse:\n    Dx = np.linalg.det(np.column_stack([b, A[:, 1]]))\n    Dy = np.linalg.det(np.column_stack([A[:, 0], b]))\n    x = Dx / D\n    y = Dy / D\n    print((x, y))"
  },
  {
    "input": "Solve the system:\n2x + 3y - z = 1\n4x + y + z = 7\n-2x + 5y - 3z = -4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + 3*y - z, 1)\neq2 = sp.Eq(4*x + y + z, 7)\neq3 = sp.Eq(-2*x + 5*y - 3*z, -4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Use matrix method to solve:\n[1 3 1 | 9]\n[2 7 2 | 24]\n[1 5 2 | 17]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 3, 1, 9], [2, 7, 2, 24], [1, 5, 2, 17]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Solve using substitution:\n3x + 2y = 16\ny = 4x - 5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 2*y, 16)\neq2 = sp.Eq(y, 4*x - 5)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n3x - y = 2\n6x - 2y = 4",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - y, 2)\neq2 = sp.Eq(6*x - 2*y, 4)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system with parametric solutions:\nx + y + z = 6\n2x + 3y + z = 10",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 6)\neq2 = sp.Eq(2*x + 3*y + z, 10)\nsol = sp.solve([eq1, eq2], (x, y, z), dict=True)\nprint(sol)"
  },
  {
    "input": "Use Gaussian elimination:\n[1 2 3 | 14]\n[2 5 2 | 18]\n[2 3 1 | 10]",
    "output": "import sympy as sp\nA = sp.Matrix([[1,2,3,14],[2,5,2,18],[2,3,1,10]])\nRREF = A.rref()[0]\nprint(RREF)"
  },
  {
    "input": "Determine the nature of the system:\n4x - y = 3\n8x - 2y = 6",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x - y, 3)\neq2 = sp.Eq(8*x - 2*y, 6)\nsol = sp.solve([eq1, eq2], (x, y), dict=True)\nprint(sol)"
  },
  {
    "input": "Solve the system using numpy:\n[2 3 | 8]\n[1 -4 | -2]",
    "output": "import numpy as np\nA = np.array([[2, 3], [1, -4]])\nb = np.array([8, -2])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "Solve using Cramer\u00e2\u20ac\u2122s Rule:\n3x + 4y = 10\n2x - y = 5",
    "output": "import numpy as np\nA = np.array([[3, 4], [2, -1]])\nb = np.array([10, 5])\nD = np.linalg.det(A)\nif D == 0:\n    print('No unique solution')\nelse:\n    Dx = np.linalg.det(np.column_stack((b, A[:, 1])))\n    Dy = np.linalg.det(np.column_stack((A[:, 0], b)))\n    x = Dx / D\n    y = Dy / D\n    print((x, y))"
  },
  {
    "input": "Solve the system:\nx + y + z = 6\nx + 2y + 3z = 14\nx + 4y + 9z = 30",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 6)\neq2 = sp.Eq(x + 2*y + 3*z, 14)\neq3 = sp.Eq(x + 4*y + 9*z, 30)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Determine if the following system has no solution:\n2x + 3y = 7\n4x + 6y = 10",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 7)\neq2 = sp.Eq(4*x + 6*y, 10)\nsol = sp.solve([eq1, eq2], (x, y), dict=True)\nprint(sol)"
  },
  {
    "input": "Use inverse matrix to solve:\n[1 2 | 5]\n[3 4 | 11]",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nb = np.array([5, 11])\nx = np.linalg.inv(A).dot(b)\nprint(x)"
  },
  {
    "input": "Solve:\n4x + y - z = 5\n2x - 2y + z = -3\nx + y + z = 4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x + y - z, 5)\neq2 = sp.Eq(2*x - 2*y + z, -3)\neq3 = sp.Eq(x + y + z, 4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Solve the following linear system:\n3x + 4y = 7\n-6x - 8y = -14",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 7)\neq2 = sp.Eq(-6*x - 8*y, -14)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Find the general solution:\nx + 2y - z = 4\n2x + 4y - 2z = 8",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + 2*y - z, 4)\neq2 = sp.Eq(2*x + 4*y - 2*z, 8)\nsol = sp.solve([eq1, eq2], (x, y, z), dict=True)\nprint(sol)"
  },
  {
    "input": "Check if the system has infinite solutions:\nx - y = 1\n2x - 2y = 2",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x - y, 1)\neq2 = sp.Eq(2*x - 2*y, 2)\nsol = sp.solve([eq1, eq2], (x, y), dict=True)\nprint(sol)"
  },
  {
    "input": "Solve the system:\n7x + 2y = 3\n5x - 3y = -7",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x + 2*y, 3)\neq2 = sp.Eq(5*x - 3*y, -7)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Find the solution to:\n-3x + 4y - 2z = 7\nx - y + z = -1\n2x + 3y - z = 4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(-3*x + 4*y - 2*z, 7)\neq2 = sp.Eq(x - y + z, -1)\neq3 = sp.Eq(2*x + 3*y - z, 4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n5x - 2y = 7\n3x + 4y = -5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x - 2*y, 7)\neq2 = sp.Eq(3*x + 4*y, -5)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "A boat travels 36 miles downstream in 3 hours and returns upstream in 4 hours. Find the speed of the boat in still water and the speed of the current.",
    "output": "import sympy as sp\nb, c = sp.symbols('b c')\neq1 = sp.Eq(3*(b + c), 36)\neq2 = sp.Eq(4*(b - c), 36)\nsol = sp.solve([eq1, eq2], (b, c))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n2x + 3y = 8\n4x + 6y = 16",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 8)\neq2 = sp.Eq(4*x + 6*y, 16)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "The sum of two numbers is 15, and their difference is 3. Find the numbers.",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 15)\neq2 = sp.Eq(x - y, 3)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using matrices:\n[3 1 | 9]\n[2 4 | 12]",
    "output": "import numpy as np\nA = np.array([[3, 1], [2, 4]])\nb = np.array([9, 12])\nx = np.linalg.solve(A, b)\nprint(x)"
  },
  {
    "input": "A chemist needs to mix a 10% acid solution with a 25% acid solution to obtain 10 liters of a 15% solution. How many liters of each solution should be used?",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 10)\neq2 = sp.Eq(0.10*x + 0.25*y, 0.15*10)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n3x + 4y - z = 5\n2x - y + 3z = 9\nx + 2y + z = 4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(3*x + 4*y - z, 5)\neq2 = sp.Eq(2*x - y + 3*z, 9)\neq3 = sp.Eq(x + 2*y + z, 4)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Two angles are complementary. The measure of one angle is 10 degrees more than twice the other. Find the measures of the angles.",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 90)\neq2 = sp.Eq(x, 2*y + 10)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n4x - y + z = 2\n3x + 2y - z = 5\nx - y + 2z = 3",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - y + z, 2)\neq2 = sp.Eq(3*x + 2*y - z, 5)\neq3 = sp.Eq(x - y + 2*z, 3)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "The difference between two numbers is 7. Three times the smaller number plus twice the larger number is 22. Find the numbers.",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(y - x, 7)\neq2 = sp.Eq(3*x + 2*y, 22)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n2x + 3y + 4z = 7\nx - y + z = 4\n3x + 2y - z = 5",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + 3*y + 4*z, 7)\neq2 = sp.Eq(x - y + z, 4)\neq3 = sp.Eq(3*x + 2*y - z, 5)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "A store sells pens for $1.50 each and notebooks for $2.50 each. A customer buys 10 items for a total of $22. How many of each item did the customer buy?",
    "output": "import sympy as sp\np, n = sp.symbols('p n')\neq1 = sp.Eq(p + n, 10)\neq2 = sp.Eq(1.5*p + 2.5*n, 22)\nsol = sp.solve([eq1, eq2], (p, n))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n2x - 3y + z = -4\nx + y - z = 3\n3x - 2y + 4z = 10",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x - 3*y + z, -4)\neq2 = sp.Eq(x + y - z, 3)\neq3 = sp.Eq(3*x - 2*y + 4*z, 10)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "A dietitian is preparing a meal with two ingredients. One provides 3g of protein and 5g of carbs per serving, the other provides 4g of protein and 2g of carbs. If the goal is 20g of protein and 18g of carbs, how many servings of each should be used?",
    "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(3*a + 4*b, 20)\neq2 = sp.Eq(5*a + 2*b, 18)\nsol = sp.solve([eq1, eq2], (a, b))\nprint(sol)"
  },
  {
    "input": "Find the values of x and y:\n3x - 5y = -4\n2x + y = 7",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - 5*y, -4)\neq2 = sp.Eq(2*x + y, 7)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the following:\n5x + 2y - z = 10\nx - y + 3z = 1\n2x + y + 2z = 7",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(5*x + 2*y - z, 10)\neq2 = sp.Eq(x - y + 3*z, 1)\neq3 = sp.Eq(2*x + y + 2*z, 7)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Using Cramer's Rule, solve:\n3x + y = 10\n2x - y = 4",
    "output": "import sympy as sp\nA = sp.Matrix([[3, 1], [2, -1]])\nB = sp.Matrix([10, 4])\nsol = A.LUsolve(B)\nprint(sol)"
  },
  {
    "input": "Solve:\nx + y + z = 6\n2x + 3y + z = 14\nx - y + 2z = 2",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 6)\neq2 = sp.Eq(2*x + 3*y + z, 14)\neq3 = sp.Eq(x - y + 2*z, 2)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Solve by substitution:\n4x - y = 5\nx + 3y = 7",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x - y, 5)\neq2 = sp.Eq(x + 3*y, 7)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Three consecutive integers add up to 96. Find the integers.",
    "output": "import sympy as sp\nx = sp.symbols('x')\neq = sp.Eq(x + (x+1) + (x+2), 96)\nsol = sp.solve(eq, x)\nprint([sol[0], sol[0]+1, sol[0]+2])"
  },
  {
    "input": "Two numbers differ by 5. Their sum is 21. Find the numbers.",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x - y, 5)\neq2 = sp.Eq(x + y, 21)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using Gaussian elimination:\n[2 1 -1 | 8]\n[-3 -1 2 | -11]\n[-2 1 2 | -3]",
    "output": "import numpy as np\nfrom scipy.linalg import solve\nA = np.array([[2, 1, -1], [-3, -1, 2], [-2, 1, 2]])\nb = np.array([8, -11, -3])\nx = solve(A, b)\nprint(x)"
  },
  {
    "input": "In a triangle, the sum of the angles is 180 degrees. One angle is twice the second, and the third angle is 30 degrees more than the second. Find the angles.",
    "output": "import sympy as sp\na, b, c = sp.symbols('a b c')\neq1 = sp.Eq(a + b + c, 180)\neq2 = sp.Eq(a, 2*b)\neq3 = sp.Eq(c, b + 30)\nsol = sp.solve([eq1, eq2, eq3], (a, b, c))\nprint(sol)"
  },
  {
    "input": "Solve:\n4x - y + 2z = 7\n-2x + 5y - z = -8\nx + 3y + 3z = 12",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - y + 2*z, 7)\neq2 = sp.Eq(-2*x + 5*y - z, -8)\neq3 = sp.Eq(x + 3*y + 3*z, 12)\nsol = sp.solve([eq1, eq2, eq3], (x, y, z))\nprint(sol)"
  },
  {
    "input": "Solve:\n2x + 3y = 12\nx - y = 2",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 12)\neq2 = sp.Eq(x - y, 2)\nsol = sp.solve([eq1, eq2], (x, y))\nprint(sol)"
  },
  {
    "input": "Determine if the system is consistent, inconsistent, or dependent:\n2x - y = 4\n4x - 2y = 8",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x - y, 4)\neq2 = sp.Eq(4*x - 2*y, 8)\nsol = sp.solve([eq1, eq2], (x, y), dict=True)\nprint('Dependent' if len(sol) > 1 else 'Unique Solution' if sol else 'Inconsistent')"
  },
  {
    "input": "Solve the system of equations:\n3x + 4y = 12\n5x - 2y = -6",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 12)\neq2 = sp.Eq(5*x - 2*y, -6)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n2x - 3y + z = 7\n4x + y - 2z = -3\n-x + 2y + 3z = 4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x - 3*y + z, 7)\neq2 = sp.Eq(4*x + y - 2*z, -3)\neq3 = sp.Eq(-x + 2*y + 3*z, 4)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n7a + 5b = 2\n3a - 2b = 8",
    "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(7*a + 5*b, 2)\neq2 = sp.Eq(3*a - 2*b, 8)\nsolution = sp.solve((eq1, eq2), (a, b))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n4p - q + 2r = 9\n2p + 3q - r = -4\n-p + 2q + 5r = 7",
    "output": "import sympy as sp\np, q, r = sp.symbols('p q r')\neq1 = sp.Eq(4*p - q + 2*r, 9)\neq2 = sp.Eq(2*p + 3*q - r, -4)\neq3 = sp.Eq(-p + 2*q + 5*r, 7)\nsolution = sp.solve((eq1, eq2, eq3), (p, q, r))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n5m + 2n - 3o = 10\n-3m + 4n + o = -5\n2m - n + 4o = 6",
    "output": "import sympy as sp\nm, n, o = sp.symbols('m n o')\neq1 = sp.Eq(5*m + 2*n - 3*o, 10)\neq2 = sp.Eq(-3*m + 4*n + o, -5)\neq3 = sp.Eq(2*m - n + 4*o, 6)\nsolution = sp.solve((eq1, eq2, eq3), (m, n, o))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n3x - y + 2z = 5\nx + 4y - z = 6\n2x - 3y + 3z = -4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(3*x - y + 2*z, 5)\neq2 = sp.Eq(x + 4*y - z, 6)\neq3 = sp.Eq(2*x - 3*y + 3*z, -4)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n2a + 3b - c = 7\n4a - b + 5c = -3\n-a + 2b + 3c = 4",
    "output": "import sympy as sp\na, b, c = sp.symbols('a b c')\neq1 = sp.Eq(2*a + 3*b - c, 7)\neq2 = sp.Eq(4*a - b + 5*c, -3)\neq3 = sp.Eq(-a + 2*b + 3*c, 4)\nsolution = sp.solve((eq1, eq2, eq3), (a, b, c))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n5x + 3y = 11\n2x - 4y = -8",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x + 3*y, 11)\neq2 = sp.Eq(2*x - 4*y, -8)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n3p - 2q + r = 4\n2p + q - 3r = -6\np + 4q + 2r = 5",
    "output": "import sympy as sp\np, q, r = sp.symbols('p q r')\neq1 = sp.Eq(3*p - 2*q + r, 4)\neq2 = sp.Eq(2*p + q - 3*r, -6)\neq3 = sp.Eq(p + 4*q + 2*r, 5)\nsolution = sp.solve((eq1, eq2, eq3), (p, q, r))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n4x - 3y + 2z = 8\n2x + y - z = -3\n3x + 2y + 4z = 7",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - 3*y + 2*z, 8)\neq2 = sp.Eq(2*x + y - z, -3)\neq3 = sp.Eq(3*x + 2*y + 4*z, 7)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n2x + 3y = 18\n4x - y = 2",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 18)\neq2 = sp.Eq(4*x - y, 2)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n6a - 4b = 10\n3a + 2b = 8",
    "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(6*a - 4*b, 10)\neq2 = sp.Eq(3*a + 2*b, 8)\nsolution = sp.solve((eq1, eq2), (a, b))\nprint(solution)"
  },
  {
    "input": "Solve the system of equations:\n7x - 2y + 3z = 5\n3x + 4y - z = 7\nx - y + 2z = 4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(7*x - 2*y + 3*z, 5)\neq2 = sp.Eq(3*x + 4*y - z, 7)\neq3 = sp.Eq(x - y + 2*z, 4)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
  },
  {
    "input": "Solve the system using Cramer's Rule:\n2x + 3y = 7\n4x - y = 1",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, 3], [4, -1]])\nB = sp.Matrix([7, 1])\nsolution = A.LUsolve(B)\nprint(dict(zip((x, y), solution)))"
  },
  {
    "input": "Solve the system using Gaussian Elimination:\nx + y + z = 6\n2x + 3y + 7z = 20\n4x + 5y + 6z = 26",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[1,1,1,6],[2,3,7,20],[4,5,6,26]])\nreduced = A.rref()\nprint(reduced[0])"
  },
  {
    "input": "Find the solution to the system:\n3x + 2y = 12\nx - y = 1",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 2*y, 12)\neq2 = sp.Eq(x - y, 1)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Solve the following system:\n2x + 5y - z = 1\n3x - y + 2z = 4\nx + y + z = 6",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + 5*y - z, 1)\neq2 = sp.Eq(3*x - y + 2*z, 4)\neq3 = sp.Eq(x + y + z, 6)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
  },
  {
    "input": "Determine the values of x, y in the system:\n4x - 5y = 9\n6x + 2y = -2",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x - 5*y, 9)\neq2 = sp.Eq(6*x + 2*y, -2)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Solve the system of linear equations:\nx + 2y = 10\n3x + 4y = 24",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + 2*y, 10)\neq2 = sp.Eq(3*x + 4*y, 24)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n4a + b = 7\na - 2b = -1",
    "output": "import sympy as sp\na, b = sp.symbols('a b')\nA = sp.Matrix([[4,1],[1,-2]])\nB = sp.Matrix([7,-1])\nsolution = A.LUsolve(B)\nprint(dict(zip((a, b), solution)))"
  },
  {
    "input": "Use augmented matrix and row reduction:\n2x - y = 3\n5x + 3y = 13",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, -1, 3], [5, 3, 13]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
  },
  {
    "input": "Solve the system:\n3m + 4n + 5o = 27\n2m - 2n + o = 1\nm + n + o = 10",
    "output": "import sympy as sp\nm, n, o = sp.symbols('m n o')\neq1 = sp.Eq(3*m + 4*n + 5*o, 27)\neq2 = sp.Eq(2*m - 2*n + o, 1)\neq3 = sp.Eq(m + n + o, 10)\nsolution = sp.solve((eq1, eq2, eq3), (m, n, o))\nprint(solution)"
  },
  {
    "input": "Solve the system:\n6x + 2y = 14\nx - 3y = -7",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x + 2*y, 14)\neq2 = sp.Eq(x - 3*y, -7)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Solve the system:\n2x + y - z = 4\nx - y + 2z = 2\n3x + 2y + z = 10",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + y - z, 4)\neq2 = sp.Eq(x - y + 2*z, 2)\neq3 = sp.Eq(3*x + 2*y + z, 10)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n3x - 2y + 4z = 10\nx + y + z = 6\n2x - y + 3z = 9",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[3, -2, 4, 10], [1, 1, 1, 6], [2, -1, 3, 9]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
  },
  {
    "input": "Determine if the system has a unique solution, infinite solutions, or no solution:\n2x + y = 4\n4x + 2y = 8",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + y, 4)\neq2 = sp.Eq(4*x + 2*y, 8)\nsolution = sp.solve((eq1, eq2), (x, y), dict=True)\nprint(solution if solution else 'No unique solution')"
  },
  {
    "input": "Solve the system using matrix inverse method:\n5x + 3y = 16\nx + 2y = 8",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[5, 3], [1, 2]])\nB = sp.Matrix([16, 8])\nsolution = A.inv() * B\nprint(dict(zip((x, y), solution)))"
  },
  {
    "input": "Find parametric solution of the system:\nx - y + z = 0\n2x + y - z = 3",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x - y + z, 0)\neq2 = sp.Eq(2*x + y - z, 3)\nsolution = sp.solve((eq1, eq2), (x, y, z), dict=True)\nprint(solution)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n3a + 2b = 7\n5a + 4b = 13",
    "output": "import sympy as sp\na, b = sp.symbols('a b')\nA = sp.Matrix([[3, 2], [5, 4]])\nB = sp.Matrix([7, 13])\nsolution = A.LUsolve(B)\nprint(dict(zip((a, b), solution)))"
  },
  {
    "input": "Solve for x, y, z:\nx + y + z = 3\nx - y + z = 1\nx + 2y - z = 4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 3)\neq2 = sp.Eq(x - y + z, 1)\neq3 = sp.Eq(x + 2*y - z, 4)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
  },
  {
    "input": "Use an augmented matrix to determine the solution:\n4x - y + z = 3\n2x + y - z = 1\nx + 3y + 2z = 7",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[4, -1, 1, 3], [2, 1, -1, 1], [1, 3, 2, 7]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
  },
  {
    "input": "Check for consistency:\n2x + 3y = 5\n4x + 6y = 10\n6x + 9y = 15",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(2*x + 3*y, 5), sp.Eq(4*x + 6*y, 10), sp.Eq(6*x + 9*y, 15)]\nsolution = sp.solve(eqs, (x, y), dict=True)\nprint('Consistent' if solution else 'Inconsistent')"
  },
  {
    "input": "Solve the following:\n5x - y = 3\nx + 4y = 11",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x - y, 3)\neq2 = sp.Eq(x + 4*y, 11)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Find the general solution:\nx + y + z = 0\nx - y + z = 2",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + y + z, 0), sp.Eq(x - y + z, 2)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
  },
  {
    "input": "Solve this system using Gaussian elimination:\n3x + 2y = 12\nx - y = 1",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[3, 2, 12], [1, -1, 1]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
  },
  {
    "input": "Use inverse method:\n7x - 2y = 5\n3x + y = 4",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[7, -2], [3, 1]])\nB = sp.Matrix([5, 4])\nsolution = A.inv() * B\nprint(dict(zip((x, y), solution)))"
  },
  {
    "input": "Solve the system:\n2a - b + c = 3\na + b + c = 6\n3a - 2b + 4c = 10",
    "output": "import sympy as sp\na, b, c = sp.symbols('a b c')\neq1 = sp.Eq(2*a - b + c, 3)\neq2 = sp.Eq(a + b + c, 6)\neq3 = sp.Eq(3*a - 2*b + 4*c, 10)\nsolution = sp.solve((eq1, eq2, eq3), (a, b, c))\nprint(solution)"
  },
  {
    "input": "Solve for x and y:\n8x - 3y = 17\n2x + 5y = 1",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(8*x - 3*y, 17)\neq2 = sp.Eq(2*x + 5*y, 1)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Solve:\n4x + y - z = 8\nx - y + z = 2\n3x + 2y + z = 13",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x + y - z, 8)\neq2 = sp.Eq(x - y + z, 2)\neq3 = sp.Eq(3*x + 2*y + z, 13)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
  },
  {
    "input": "Determine whether the system has a solution:\nx + y + z = 2\nx + y + z = 3",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 2)\neq2 = sp.Eq(x + y + z, 3)\nsolution = sp.solve((eq1, eq2), (x, y, z))\nprint(solution if solution else 'No solution')"
  },
  {
    "input": "Use augmented matrix form:\n2x - y = 4\n-3x + 4y = -10",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, -1, 4], [-3, 4, -10]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
  },
  {
    "input": "Solve this system:\n5x + 2y = 9\nx + y = 3",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x + 2*y, 9)\neq2 = sp.Eq(x + y, 3)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Find values of x, y such that:\n3x + 4y = 11\n6x + 8y = 22",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(3*x + 4*y, 11), sp.Eq(6*x + 8*y, 22)]\nsolution = sp.solve(eqs, (x, y), dict=True)\nprint(solution)"
  },
  {
    "input": "Use Gaussian elimination to solve:\nx - 2y + z = 1\n2x + y - 3z = -2\n3x - y + 2z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[1, -2, 1, 1], [2, 1, -3, -2], [3, -1, 2, 0]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
  },
  {
    "input": "Solve the system:\n3a + b = 7\na - b = 1",
    "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(3*a + b, 7)\neq2 = sp.Eq(a - b, 1)\nsolution = sp.solve((eq1, eq2), (a, b))\nprint(solution)"
  },
  {
    "input": "Solve this linear system:\n4x - 2y + z = 5\nx + y - z = 2\n2x - y + 3z = 10",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(4*x - 2*y + z, 5)\neq2 = sp.Eq(x + y - z, 2)\neq3 = sp.Eq(2*x - y + 3*z, 10)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
  },
  {
    "input": "Solve the system:\n2x - y + 3z = 7\nx + 4y - z = -1\n3x - y + z = 10",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x - y + 3*z, 7)\neq2 = sp.Eq(x + 4*y - z, -1)\neq3 = sp.Eq(3*x - y + z, 10)\nsolution = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(solution)"
  },
  {
    "input": "Check consistency:\n2x + 3y - z = 4\n4x + 6y - 2z = 8\nx - y + z = 1",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(2*x + 3*y - z, 4), sp.Eq(4*x + 6*y - 2*z, 8), sp.Eq(x - y + z, 1)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint('Consistent' if solution else 'Inconsistent')"
  },
  {
    "input": "Find the inverse solution for:\n3x + y = 7\n2x - 4y = -6",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[3, 1], [2, -4]])\nB = sp.Matrix([7, -6])\nsolution = A.inv() * B\nprint(dict(zip((x, y), solution)))"
  },
  {
    "input": "Solve using Gaussian elimination:\n2x + y + z = 4\nx - y + 2z = 1\n3x + 2y - z = 7",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[2, 1, 1, 4], [1, -1, 2, 1], [3, 2, -1, 7]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
  },
  {
    "input": "Solve the following linear system:\n5x + y = 11\nx - y = 1",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x + y, 11)\neq2 = sp.Eq(x - y, 1)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Use Cramer\u00e2\u20ac\u2122s Rule to solve:\n2x + y = 3\nx - y = 1",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, 1], [1, -1]])\nB = sp.Matrix([3, 1])\nsolution = A.LUsolve(B)\nprint(dict(zip((x, y), solution)))"
  },
  {
    "input": "Solve and determine type of solution:\nx + y + z = 6\n2x + 2y + 2z = 12\n3x + 3y + 3z = 18",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + y + z, 6), sp.Eq(2*x + 2*y + 2*z, 12), sp.Eq(3*x + 3*y + 3*z, 18)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution if solution else 'No unique solution')"
  },
  {
    "input": "Solve this 2x2 system:\n4x - y = 9\n2x + 3y = 1",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x - y, 9)\neq2 = sp.Eq(2*x + 3*y, 1)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Use augmented matrix:\n2a + 3b + c = 1\n4a + 6b + 2c = 2\n3a - b + c = 0",
    "output": "import sympy as sp\na, b, c = sp.symbols('a b c')\nA = sp.Matrix([[2, 3, 1, 1], [4, 6, 2, 2], [3, -1, 1, 0]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
  },
  {
    "input": "Find parametric form of the solution:\nx + y - z = 0\n2x - y + z = 1",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + y - z, 0), sp.Eq(2*x - y + z, 1)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
  },
  {
    "input": "Check whether this system is consistent:\n3x - 2y = 6\n-6x + 4y = -12",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - 2*y, 6)\neq2 = sp.Eq(-6*x + 4*y, -12)\nsolution = sp.solve((eq1, eq2), (x, y), dict=True)\nprint('Consistent' if solution else 'Inconsistent')"
  },
  {
    "input": "Use inverse matrix method:\n4a + b = 10\n2a - b = 2",
    "output": "import sympy as sp\na, b = sp.symbols('a b')\nA = sp.Matrix([[4, 1], [2, -1]])\nB = sp.Matrix([10, 2])\nsolution = A.inv() * B\nprint(dict(zip((a, b), solution)))"
  },
  {
    "input": "Solve:\nx + 2y + z = 4\n3x + y - z = 3\n2x + 3y + 4z = 10",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + 2*y + z, 4), sp.Eq(3*x + y - z, 3), sp.Eq(2*x + 3*y + 4*z, 10)]\nsolution = sp.solve(eqs, (x, y, z))\nprint(solution)"
  },
  {
    "input": "Determine the solution:\n2x + 3y = 8\n4x + 6y = 17",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(2*x + 3*y, 8), sp.Eq(4*x + 6*y, 17)]\nsolution = sp.solve(eqs, (x, y), dict=True)\nprint(solution if solution else 'No solution')"
  },
  {
    "input": "Use RREF to solve:\n2x - y + 3z = 7\nx + 4y - z = -1\n3x - y + z = 10",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[2, -1, 3, 7], [1, 4, -1, -1], [3, -1, 1, 10]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
  },
  {
    "input": "Solve this:\n4x + y - 2z = 5\n3x - 2y + z = 2\n2x + y + 3z = 12",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(4*x + y - 2*z, 5), sp.Eq(3*x - 2*y + z, 2), sp.Eq(2*x + y + 3*z, 12)]\nsolution = sp.solve(eqs, (x, y, z))\nprint(solution)"
  },
  {
    "input": "Find the solution using inverse matrix:\n3x + 2y = 12\nx + 4y = 10",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[3, 2], [1, 4]])\nB = sp.Matrix([12, 10])\nsolution = A.inv() * B\nprint(dict(zip((x, y), solution)))"
  },
  {
    "input": "Solve:\n5x + 2y - z = 3\n3x - y + 4z = 7\nx + y + z = 6",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(5*x + 2*y - z, 3), sp.Eq(3*x - y + 4*z, 7), sp.Eq(x + y + z, 6)]\nsolution = sp.solve(eqs, (x, y, z))\nprint(solution)"
  },
  {
    "input": "Check for infinite solutions:\nx + y = 3\n2x + 2y = 6",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(x + y, 3), sp.Eq(2*x + 2*y, 6)]\nsolution = sp.solve(eqs, (x, y), dict=True)\nprint(solution if solution else 'Infinite solutions')"
  },
  {
    "input": "Use Gaussian elimination:\n4x + 2y = 10\n2x + y = 5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[4, 2, 10], [2, 1, 5]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
  },
  {
    "input": "Solve the system:\n7x - y = 3\n2x + 5y = 11",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x - y, 3)\neq2 = sp.Eq(2*x + 5*y, 11)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Find solution:\n3a + 2b = 14\na - 4b = -10",
    "output": "import sympy as sp\na, b = sp.symbols('a b')\neq1 = sp.Eq(3*a + 2*b, 14)\neq2 = sp.Eq(a - 4*b, -10)\nsolution = sp.solve((eq1, eq2), (a, b))\nprint(solution)"
  },
  {
    "input": "Solve the system:\n3x + 4y = 12\n5x - 2y = 10",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 12)\neq2 = sp.Eq(5*x - 2*y, 10)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Determine if the system is consistent:\n2x - 3y = 7\n4x - 6y = 14",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(2*x - 3*y, 7), sp.Eq(4*x - 6*y, 14)]\nsolution = sp.solve(eqs, (x, y), dict=True)\nprint('Consistent' if solution else 'Inconsistent')"
  },
  {
    "input": "Solve using substitution:\nx + 2y = 10\n3x - y = 5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + 2*y, 10)\neq2 = sp.Eq(3*x - y, 5)\nsolution = sp.solve((eq1, eq2), (x, y))\nprint(solution)"
  },
  {
    "input": "Solve the 3\u00c3\u20143 system:\nx + y - z = 2\n2x + y + z = 7\nx - y + 2z = 4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + y - z, 2), sp.Eq(2*x + y + z, 7), sp.Eq(x - y + 2*z, 4)]\nsolution = sp.solve(eqs, (x, y, z))\nprint(solution)"
  },
  {
    "input": "Solve graphically:\ny = 3x - 2\ny = -x + 6",
    "output": "import matplotlib.pyplot as plt\nimport numpy as np\nx = np.linspace(-10, 10, 400)\ny1 = 3*x - 2\ny2 = -x + 6\nplt.plot(x, y1, label='y=3x-2')\nplt.plot(x, y2, label='y=-x+6')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.grid(True)\nplt.show()"
  },
  {
    "input": "Use Cramer\u00e2\u20ac\u2122s Rule to solve:\n2x + y = 7\nx - 3y = -8",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, 1], [1, -3]])\nB = sp.Matrix([7, -8])\nsolution = A.inv() * B\nprint(dict(zip((x, y), solution)))"
  },
  {
    "input": "Determine the nature of the system:\nx + 4y = 9\n2x + 8y = 18",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(x + 4*y, 9), sp.Eq(2*x + 8*y, 18)]\nsolution = sp.solve(eqs, (x, y), dict=True)\nprint('Infinite solutions' if solution else 'No solution')"
  },
  {
    "input": "Solve using Gauss Elimination:\n2x + 3y + z = 10\n4x - y + 5z = 5\nx + 2y - 3z = -4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[2, 3, 1, 10], [4, -1, 5, 5], [1, 2, -3, -4]])\nrref_matrix = A.rref()[0]\nprint(rref_matrix)"
  },
  {
    "input": "Solve the system:\n3x - 2y = 6\n-6x + 4y = -12",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - 2*y, 6)\neq2 = sp.Eq(-6*x + 4*y, -12)\nsolution = sp.solve((eq1, eq2), (x, y), dict=True)\nprint('Consistent' if solution else 'Inconsistent')"
  },
  {
    "input": "Use RREF to solve:\nx - 2y + z = 3\n3x + y - z = 7\n2x - y + 4z = 5",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[1, -2, 1, 3], [3, 1, -1, 7], [2, -1, 4, 5]])\nrref_matrix, _ = A.rref()\nprint(rref_matrix)"
  },
  {
    "input": "Solve for parameters:\nx + y + z = 6\n2x + 3y + 2z = 14\n3x + 4y + kz = 20 (solve for k so system has unique solution)",
    "output": "import sympy as sp\nx, y, z, k = sp.symbols('x y z k')\nA = sp.Matrix([[1,1,1], [2,3,2], [3,4,k]])\ndet = A.det()\nsolution = sp.solve(sp.Eq(det, 0), k)\nprint(f\"k values to avoid for uniqueness: {solution}\")"
  },
  {
    "input": "Determine if this system has a solution:\n5x - y + z = 10\n2x + y - 3z = -6\nx + 4y + 2z = 7",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(5*x - y + z, 10), sp.Eq(2*x + y - 3*z, -6), sp.Eq(x + 4*y + 2*z, 7)]\nsolution = sp.solve(eqs, (x, y, z))\nprint('Solution:', solution)"
  },
  {
    "input": "Find the parametric form of the solution:\n2x + y + z = 3\n4x + 2y + 2z = 6",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + y + z, 3)\neq2 = sp.Eq(4*x + 2*y + 2*z, 6)\nsolution = sp.solve((eq1, eq2), (x, y, z), dict=True)\nprint(solution)"
  },
  {
    "input": "A plane intersects the x-y-z axes at A, B, and C respectively. Find the equation of the plane passing through points A(2,0,0), B(0,3,0), and C(0,0,6).",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nequation = x/2 + y/3 + z/6 - 1\nprint('Plane equation:', sp.simplify(sp.Eq(equation, 0)))"
  },
  {
    "input": "Solve:\nx + y + z = 6\nx + 2y + 3z = 14\n2x + 3y + az = b (express in terms of a and b)",
    "output": "import sympy as sp\nx, y, z, a, b = sp.symbols('x y z a b')\neqs = [sp.Eq(x + y + z, 6), sp.Eq(x + 2*y + 3*z, 14), sp.Eq(2*x + 3*y + a*z, b)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
  },
  {
    "input": "Three lines:\nLine 1: x + y = 4\nLine 2: x - y = 0\nLine 3: 2x + y = 5\nFind point of intersection of all three or state if none exist.",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(x + y, 4), sp.Eq(x - y, 0), sp.Eq(2*x + y, 5)]\nsolution = sp.solve(eqs, (x, y), dict=True)\nprint(solution if solution else 'No common intersection')"
  },
  {
    "input": "Solve the homogeneous system:\n3x - y + 2z = 0\n2x + 4y - z = 0\nx + y + z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(3*x - y + 2*z, 0), sp.Eq(2*x + 4*y - z, 0), sp.Eq(x + y + z, 0)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
  },
  {
    "input": "Given a system of two equations, identify values of 'm' for which it has no solution:\nx + 2y = 3\n2x + 4y = m",
    "output": "import sympy as sp\nx, y, m = sp.symbols('x y m')\neq1 = sp.Eq(x + 2*y, 3)\neq2 = sp.Eq(2*x + 4*y, m)\nsol = sp.solve((eq1, eq2), (x, y), dict=True)\nprint('No solution when m \u00e2\u2030\u00a0 6' if not sol else 'Solution exists')"
  },
  {
    "input": "Use Gaussian elimination to solve:\n3x + 2y - z = 1\n2x - 2y + 4z = -2\n-1x + 0.5y - z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[3, 2, -1, 1], [2, -2, 4, -2], [-1, 0.5, -1, 0]])\nrref, _ = A.rref()\nprint(rref)"
  },
  {
    "input": "Determine if the system is consistent:\n2x + 3y = 4\n4x + 6y = 10",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(2*x + 3*y, 4), sp.Eq(4*x + 6*y, 10)]\nsolution = sp.solve(eqs, (x, y), dict=True)\nprint('Consistent' if solution else 'Inconsistent')"
  },
  {
    "input": "Find the inverse of matrix A and use it to solve Ax = b:\nA = [[1, 2], [3, 4]], b = [5, 11]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2], [3, 4]])\nb = sp.Matrix([5, 11])\nx = A.inv() * b\nprint('Solution:', x)"
  },
  {
    "input": "Determine the rank of the augmented matrix:\nA = [[1, 2, -1], [2, 4, -2], [3, 6, -3]]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, -1], [2, 4, -2], [3, 6, -3]])\nrank = A.rank()\nprint('Rank:', rank)"
  },
  {
    "input": "Express the general solution to the homogeneous system:\nx + y + z = 0\n2x - y + 3z = 0",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + y + z, 0), sp.Eq(2*x - y + 3*z, 0)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
  },
  {
    "input": "Check if this system has infinitely many solutions:\n4x + 2y = 8\n2x + y = 4",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(4*x + 2*y, 8), sp.Eq(2*x + y, 4)]\nsolution = sp.solve(eqs, (x, y), dict=True)\nprint('Infinite solutions' if len(solution) == 1 else 'Unique or no solution')"
  },
  {
    "input": "Use matrix inverse to solve:\nA = [[2, 1], [5, 3]], b = [1, 2]",
    "output": "import sympy as sp\nA = sp.Matrix([[2, 1], [5, 3]])\nb = sp.Matrix([1, 2])\nx = A.inv() * b\nprint('Solution:', x)"
  },
  {
    "input": "Perform one row operation to eliminate x from second equation:\nRow1: x + 2y = 4\nRow2: 3x + y = 5",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 4], [3, 1, 5]])\nA[1,:] = A[1,:] - 3*A[0,:]\nprint(A)"
  },
  {
    "input": "Write the augmented matrix of the system:\n2x + y - z = 1\n-x + 3y + 2z = 4\n3x - 2y + z = 5",
    "output": "import sympy as sp\nA = sp.Matrix([[2, 1, -1, 1], [-1, 3, 2, 4], [3, -2, 1, 5]])\nprint('Augmented matrix:', A)"
  },
  {
    "input": "Find a basic solution of the underdetermined system:\nx + y + z = 4\nx - y + 2z = 2",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + y + z, 4), sp.Eq(x - y + 2*z, 2)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
  },
  {
    "input": "Determine values of 'k' such that the system is consistent:\nx + ky = 3\n3x + 6y = 9",
    "output": "import sympy as sp\nx, y, k = sp.symbols('x y k')\neqs = [sp.Eq(x + k*y, 3), sp.Eq(3*x + 6*y, 9)]\nsol = sp.solve(eqs, (x, y), dict=True)\nprint(sol)"
  },
  {
    "input": "Check if these lines intersect:\nLine1: x - 2y = 3\nLine2: 2x - 4y = 7",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(x - 2*y, 3), sp.Eq(2*x - 4*y, 7)]\nsol = sp.solve(eqs, (x, y), dict=True)\nprint('Intersection:', sol if sol else 'No intersection')"
  },
  {
    "input": "Find the null space of the matrix:\nA = [[1, 2, 3], [2, 4, 6]]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 3], [2, 4, 6]])\nnullspace = A.nullspace()\nprint('Null space:', nullspace)"
  },
  {
    "input": "Solve:\n3x - 2y + z = 1\nx + y + z = 4\n2x + 3y - z = 2",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(3*x - 2*y + z, 1), sp.Eq(x + y + z, 4), sp.Eq(2*x + 3*y - z, 2)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
  },
  {
    "input": "Reduce the matrix to echelon form:\nA = [[1, 2, -1], [2, 4, 0], [-1, -2, 2]]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, -1], [2, 4, 0], [-1, -2, 2]])\nA_echelon = A.echelon_form()\nprint(A_echelon)"
  },
  {
    "input": "Check for linear dependence among rows of:\n[[1, 2, 3], [2, 4, 6], [3, 6, 9]]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 3], [2, 4, 6], [3, 6, 9]])\nrank = A.rank()\nprint('Linearly dependent' if rank < A.rows else 'Independent')"
  },
  {
    "input": "Determine if these equations are equivalent:\nx + y = 2\n2x + 2y = 4",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neqs = [sp.Eq(x + y, 2), sp.Eq(2*x + 2*y, 4)]\nsolution = sp.solve(eqs, (x, y), dict=True)\nprint('Equivalent equations' if solution else 'Not equivalent')"
  },
  {
    "input": "Use sympy to plot the solution set of:\nx + y = 4\nx - y = 0",
    "output": "import sympy as sp\nimport matplotlib.pyplot as plt\nx, y = sp.symbols('x y')\neq1 = x + y - 4\neq2 = x - y\nsp.plot_implicit(sp.And(sp.Eq(eq1, 0), sp.Eq(eq2, 0)), (x, -10, 10), (y, -10, 10))"
  },
  {
    "input": "Determine if this 3x3 matrix is invertible:\n[[1, 2, 3], [0, 1, 4], [5, 6, 0]]",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 2, 3], [0, 1, 4], [5, 6, 0]])\ndet = A.det()\nprint('Invertible' if det != 0 else 'Not invertible')"
  },
  {
    "input": "Find determinant and solution:\n2x + y = 5\nx - y = 1",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, 1], [1, -1]])\nb = sp.Matrix([5, 1])\ndet = A.det()\nsol = A.inv() * b if det != 0 else 'No inverse'\nprint('Determinant:', det, 'Solution:', sol)"
  },
  {
    "input": "Find general solution for the system:\nx + 2y + z = 4\n2x + 4y + 2z = 8",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neqs = [sp.Eq(x + 2*y + z, 4), sp.Eq(2*x + 4*y + 2*z, 8)]\nsolution = sp.solve(eqs, (x, y, z), dict=True)\nprint(solution)"
  },
  {
    "input": "Express this system in matrix form:\nx + y = 3\n2x - y = 1",
    "output": "import sympy as sp\nA = sp.Matrix([[1, 1], [2, -1]])\nb = sp.Matrix([3, 1])\nprint('Matrix form: Ax = b, A =', A, 'b =', b)"
  },
  {
    "input": "Solve by substitution:\nx + y = 5\nx - y = 1",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\ny_expr = 5 - x\nx_val = sp.solve(x - y_expr - 1, x)[0]\ny_val = 5 - x_val\nprint('x =', x_val, ', y =', y_val)"
  },
  {
    "input": "Use Gaussian elimination to solve:\n4x + y + z = 7\n2x + 3y + 2z = 4\nx + y + z = 3",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\nA = sp.Matrix([[4, 1, 1, 7], [2, 3, 2, 4], [1, 1, 1, 3]])\nrref, _ = A.rref()\nprint(rref)"
  },
  {
    "input": "Solve the system using the elimination method:\n6x + y = 8\n4x + 2y = 0",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x + y, 8)\neq2 = sp.Eq(4*x + 2*y, 0)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n-3x + 4y = 12\n6x - 8y = -24",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(-3*x + 4*y, 12)\neq2 = sp.Eq(6*x - 8*y, -24)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n2x - 5y = 20\n4x - 10y = 40",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x - 5*y, 20)\neq2 = sp.Eq(4*x - 10*y, 40)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Use Cramer\u00e2\u20ac\u2122s Rule to solve the system:\n2x + 3y = 5\n4x - y = 1",
    "output": "import sympy as sp\nfrom sympy import Matrix\nx, y = sp.symbols('x y')\nA = Matrix([[2, 3], [4, -1]])\nB = Matrix([5, 1])\nsol = A.LUsolve(B)\nprint(dict(zip((x, y), sol)))"
  },
  {
    "input": "Use Cramer\u00e2\u20ac\u2122s Rule to solve the system:\n3x - y = 4\n2x + 5y = 1",
    "output": "import sympy as sp\nfrom sympy import Matrix\nx, y = sp.symbols('x y')\nA = Matrix([[3, -1], [2, 5]])\nB = Matrix([4, 1])\nsol = A.LUsolve(B)\nprint(dict(zip((x, y), sol)))"
  },
  {
    "input": "Use matrix inverse to solve the system:\n2x + y = 3\nx - y = 1",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, -1]])\nB = np.array([3, 1])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
  },
  {
    "input": "Use matrix inverse to solve the system:\n4x - 2y = 10\n-3x + y = -5",
    "output": "import numpy as np\nA = np.array([[4, -2], [-3, 1]])\nB = np.array([10, -5])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
  },
  {
    "input": "Find the solution using Gaussian elimination:\n3x + 2y = 16\nx - y = 1",
    "output": "import numpy as np\nA = np.array([[3, 2, 16], [1, -1, 1]], dtype=float)\nA[1] = A[1] - A[0]*(A[1][0]/A[0][0])\nA[1] = A[1]/A[1][1]\nA[0] = A[0] - A[1]*(A[0][1])\nA[0] = A[0]/A[0][0]\nprint({'x': A[0][2], 'y': A[1][2]})"
  },
  {
    "input": "Solve the system of equations:\n2x + 3y - z = 5\n4x - y + 2z = 6\n-6x + 5y + z = -4",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(2*x + 3*y - z, 5)\neq2 = sp.Eq(4*x - y + 2*z, 6)\neq3 = sp.Eq(-6*x + 5*y + z, -4)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(sol)"
  },
  {
    "input": "Solve for x and y:\n7x + 3y = -1\n-2x + 5y = 17",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x + 3*y, -1)\neq2 = sp.Eq(-2*x + 5*y, 17)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Use matrix methods to solve:\n5x - 4y = 9\n-3x + 2y = -7",
    "output": "import numpy as np\nA = np.array([[5, -4], [-3, 2]])\nB = np.array([9, -7])\nX = np.linalg.solve(A, B)\nprint({'x': X[0], 'y': X[1]})"
  },
  {
    "input": "Use Gaussian elimination to solve:\nx + y + z = 6\n2x - y + 3z = 14\nx + 2y - z = -2",
    "output": "import sympy as sp\nx, y, z = sp.symbols('x y z')\neq1 = sp.Eq(x + y + z, 6)\neq2 = sp.Eq(2*x - y + 3*z, 14)\neq3 = sp.Eq(x + 2*y - z, -2)\nsol = sp.solve((eq1, eq2, eq3), (x, y, z))\nprint(sol)"
  },
  {
    "input": "Determine if the system has infinite solutions:\n2x + 4y = 8\nx + 2y = 4",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 4*y, 8)\neq2 = sp.Eq(x + 2*y, 4)\nsol = sp.solve((eq1, eq2), (x, y), dict=True)\nprint('Infinite solutions' if len(sol) == 0 else sol)"
  },
  {
    "input": "Check if the following system is inconsistent:\n3x - 6y = 9\nx - 2y = 1",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - 6*y, 9)\neq2 = sp.Eq(x - 2*y, 1)\nsol = sp.solve((eq1, eq2), (x, y), dict=True)\nprint('No solution' if len(sol) == 0 else sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n7x - 8y = -12\n-4x + 2y = 3",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x - 8*y, -12)\neq2 = sp.Eq(-4*x + 2*y, 3)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n3x + 9y = -6\n-4x - 12y = 8",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 9*y, -6)\neq2 = sp.Eq(-4*x - 12*y, 8)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n-7x + 7y = 63\ny = 6 - 2x",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(-7*x + 7*y, 63)\neq2 = sp.Eq(y, 6 - 2*x)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n3x - 8y = 27\ny = 4 - 7x",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - 8*y, 27)\neq2 = sp.Eq(y, 4 - 7*x)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\nx = 19 + 7y\n3x - 3y = 3",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x, 19 + 7*y)\neq2 = sp.Eq(3*x - 3*y, 3)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\nx = 39 + 8y\n-9x + 2y = -71",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x, 39 + 8*y)\neq2 = sp.Eq(-9*x + 2*y, -71)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\nx = -5 - 2y\n-2x - 6y = 18",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x, -5 - 2*y)\neq2 = sp.Eq(-2*x - 6*y, 18)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\nx = 15 + 6y\n9x + 3y = 21",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x, 15 + 6*y)\neq2 = sp.Eq(9*x + 3*y, 21)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n6x - 8y = 24\ny = 15 + 3x",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x - 8*y, 24)\neq2 = sp.Eq(y, 15 + 3*x)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n9x + 8y = -45\ny = 15 - 8x",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(9*x + 8*y, -45)\neq2 = sp.Eq(y, 15 - 8*x)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\nx + 4y = 0\n9x - 7y = -43",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + 4*y, 0)\neq2 = sp.Eq(9*x - 7*y, -43)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\nx + 6y = -53\n5x - 9y = 47",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + 6*y, -53)\neq2 = sp.Eq(5*x - 9*y, 47)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the substitution method:\n2x + 3y = 6\nx - 4y = 8",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + 3*y, 6)\neq2 = sp.Eq(x - 4*y, 8)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n5x - 2y = 9\n3x + 4y = -7",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(5*x - 2*y, 9)\neq2 = sp.Eq(3*x + 4*y, -7)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Use Cramer's Rule to solve the system:\n3x + y = 7\n2x - 5y = -3",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[3, 1], [2, -5]])\nB = sp.Matrix([7, -3])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
  },
  {
    "input": "Solve the system using matrix inverses:\n4x + y = 5\n-2x + 3y = 4",
    "output": "import numpy as np\nA = np.array([[4, 1], [-2, 3]])\nB = np.array([5, 4])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
  },
  {
    "input": "Solve the system using the substitution method:\n7x - 3y = 10\n2x + y = 5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x - 3*y, 10)\neq2 = sp.Eq(2*x + y, 5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n6x + 5y = 20\n4x - 2y = -6",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x + 5*y, 20)\neq2 = sp.Eq(4*x - 2*y, -6)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Use Cramer's Rule to solve the system:\n5x + 2y = 3\n3x - y = 7",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[5, 2], [3, -1]])\nB = sp.Matrix([3, 7])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
  },
  {
    "input": "Solve the system using matrix inverses:\n3x - y = 4\nx + 2y = -1",
    "output": "import numpy as np\nA = np.array([[3, -1], [1, 2]])\nB = np.array([4, -1])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
  },
  {
    "input": "Solve the system using the substitution method:\n4x + 3y = 14\n2x - 5y = -3",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x + 3*y, 14)\neq2 = sp.Eq(2*x - 5*y, -3)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n3x + 4y = 12\n5x - 2y = 8",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x + 4*y, 12)\neq2 = sp.Eq(5*x - 2*y, 8)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Use Cramer's Rule to solve the system:\n2x - 3y = 5\n4x + y = -2",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[2, -3], [4, 1]])\nB = sp.Matrix([5, -2])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
  },
  {
    "input": "Solve the system using matrix inverses:\n5x + y = 6\n3x - 4y = 2",
    "output": "import numpy as np\nA = np.array([[5, 1], [3, -4]])\nB = np.array([6, 2])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
  },
  {
    "input": "Solve the system using the substitution method:\n3x - 2y = 7\nx + 4y = -5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - 2*y, 7)\neq2 = sp.Eq(x + 4*y, -5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using the elimination method:\n6x - y = 10\n-3x + 2y = -5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(6*x - y, 10)\neq2 = sp.Eq(-3*x + 2*y, -5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n4x + y = 1\nx - 2y = 3",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[4, 1], [1, -2]])\nB = sp.Matrix([1, 3])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
  },
  {
    "input": "Solve using matrix inverse method:\n2x + 5y = 11\n3x - y = 4",
    "output": "import numpy as np\nA = np.array([[2, 5], [3, -1]])\nB = np.array([11, 4])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
  },
  {
    "input": "Solve the system using substitution:\n3x = y + 2\n4x - y = 6",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x, y + 2)\neq2 = sp.Eq(4*x - y, 6)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system:\n7x + 2y = 16\nx - y = 3",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(7*x + 2*y, 16)\neq2 = sp.Eq(x - y, 3)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Use Cramer's Rule to solve:\n3x - 4y = -1\n2x + y = 5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[3, -4], [2, 1]])\nB = sp.Matrix([-1, 5])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
  },
  {
    "input": "Solve using matrix inverses:\n6x + 7y = 13\n4x - y = 9",
    "output": "import numpy as np\nA = np.array([[6, 7], [4, -1]])\nB = np.array([13, 9])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
  },
  {
    "input": "Solve by elimination:\n2x + y = 5\n-6x + 3y = -15",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x + y, 5)\neq2 = sp.Eq(-6*x + 3*y, -15)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system:\nx + y = 6\n2x - 3y = -7",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x + y, 6)\neq2 = sp.Eq(2*x - 3*y, -7)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve using substitution:\n3x - y = 0\nx + 2y = 8",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(3*x - y, 0)\neq2 = sp.Eq(x + 2*y, 8)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve using Cramer's Rule:\n5x - y = 4\n2x + 3y = 7",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\nA = sp.Matrix([[5, -1], [2, 3]])\nB = sp.Matrix([4, 7])\nsol = A.inv() * B\nprint(dict(zip((x, y), sol)))"
  },
  {
    "input": "Solve with matrix inverse:\n7x + 3y = 10\nx + 2y = 1",
    "output": "import numpy as np\nA = np.array([[7, 3], [1, 2]])\nB = np.array([10, 1])\nX = np.linalg.inv(A).dot(B)\nprint({'x': X[0], 'y': X[1]})"
  },
  {
    "input": "Solve by substitution:\n2x = y - 1\nx + y = 4",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(2*x, y - 1)\neq2 = sp.Eq(x + y, 4)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve by elimination:\n4x + 3y = 24\n2x - 6y = 10",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(4*x + 3*y, 24)\neq2 = sp.Eq(2*x - 6*y, 10)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve:\nx - y = 1\nx + y = 5",
    "output": "import sympy as sp\nx, y = sp.symbols('x y')\neq1 = sp.Eq(x - y, 1)\neq2 = sp.Eq(x + y, 5)\nsol = sp.solve((eq1, eq2), (x, y))\nprint(sol)"
  },
  {
    "input": "Solve the system using SVD:\n2x + 3y = 8\n5x - y = 2",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [5, -1]])\nb = np.array([8, 2])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve the system:\nx + y + z = 6\n2x + 3y + z = 14\n3x + 4y + 2z = 20",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 1], [2, 3, 1], [3, 4, 2]])\nb = np.array([6, 14, 20])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Find the least-squares solution using SVD:\nx + 2y = 4\n2x + 4y = 9",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 4]])\nb = np.array([4, 9])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 2))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Given a system: 3x - y + 2z = 7, 2x + 4y - z = 1, x - y + z = 4. Solve using SVD.",
    "output": "import numpy as np\n\nA = np.array([[3, -1, 2], [2, 4, -1], [1, -1, 1]])\nb = np.array([7, 1, 4])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\n4x + 2y = 10\n6x + 3y = 15",
    "output": "import numpy as np\n\nA = np.array([[4, 2], [6, 3]])\nb = np.array([10, 15])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve:\nx - y + z = 2\n2x + y - z = 1\n3x + 2y + z = 5",
    "output": "import numpy as np\n\nA = np.array([[1, -1, 1], [2, 1, -1], [3, 2, 1]])\nb = np.array([2, 1, 5])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\n2x + y = 5\n4x + 2y = 11",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [4, 2]])\nb = np.array([5, 11])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 2))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "System of equations:\n3x + y + z = 10\nx + 2y + 3z = 14\n2x + 3y + z = 13\nSolve using SVD.",
    "output": "import numpy as np\n\nA = np.array([[3, 1, 1], [1, 2, 3], [2, 3, 1]])\nb = np.array([10, 14, 13])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve the system using SVD:\n5x + 4y = 13\n10x + 8y = 26.5",
    "output": "import numpy as np\n\nA = np.array([[5, 4], [10, 8]])\nb = np.array([13, 26.5])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 2))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve:\nx + 2y + 3z = 6\n4x + 5y + 6z = 15\n7x + 8y + 9z = 24\nUsing SVD.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nb = np.array([6, 15, 24])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((3, 3))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve:\n2x + y + z = 5\nx - y + z = 3\n3x + 2y + 4z = 10",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 1], [1, -1, 1], [3, 2, 4]])\nb = np.array([5, 3, 10])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Find the SVD solution for:\n4x - y + z = 9\n-2x + 2y - 3z = -4\n3x + y + 2z = 10",
    "output": "import numpy as np\n\nA = np.array([[4, -1, 1], [-2, 2, -3], [3, 1, 2]])\nb = np.array([9, -4, 10])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve this system using SVD:\n2x + 3y + z = 7\nx + y + z = 4\nx - y + z = 2",
    "output": "import numpy as np\n\nA = np.array([[2, 3, 1], [1, 1, 1], [1, -1, 1]])\nb = np.array([7, 4, 2])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to find the solution:\n3x + 2y = 11\nx + 4y = 10",
    "output": "import numpy as np\n\nA = np.array([[3, 2], [1, 4]])\nb = np.array([11, 10])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\n5x + 3y + z = 12\n2x + 2y + 2z = 12\n3x + 4y + 5z = 26",
    "output": "import numpy as np\n\nA = np.array([[5, 3, 1], [2, 2, 2], [3, 4, 5]])\nb = np.array([12, 12, 26])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "System:\n2x + 3y + 5z = 18\n4x + y + z = 11\n6x + 2y + 3z = 20\nSolve using SVD.",
    "output": "import numpy as np\n\nA = np.array([[2, 3, 5], [4, 1, 1], [6, 2, 3]])\nb = np.array([18, 11, 20])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve this inconsistent system:\n3x + 2y = 8\n6x + 4y = 17",
    "output": "import numpy as np\n\nA = np.array([[3, 2], [6, 4]])\nb = np.array([8, 17])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 2))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\n3x + y + z = 8\nx + 3y + z = 10\nx + y + 3z = 12",
    "output": "import numpy as np\n\nA = np.array([[3, 1, 1], [1, 3, 1], [1, 1, 3]])\nb = np.array([8, 10, 12])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD for:\n4x + y + z = 9\n2x + 3y + 5z = 18\nx + y + z = 6",
    "output": "import numpy as np\n\nA = np.array([[4, 1, 1], [2, 3, 5], [1, 1, 1]])\nb = np.array([9, 18, 6])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\n3x - y = 5\n6x - 2y = 9",
    "output": "import numpy as np\n\nA = np.array([[3, -1], [6, -2]])\nb = np.array([5, 9])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 2))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "System:\n2x + 5y = 13\n3x + 4y = 12\nSolve it using SVD.",
    "output": "import numpy as np\n\nA = np.array([[2, 5], [3, 4]])\nb = np.array([13, 12])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve:\n5x + y = 6\n2x + 3y = 7\nx + 4y = 8\nUsing SVD.",
    "output": "import numpy as np\n\nA = np.array([[5, 1], [2, 3], [1, 4]])\nb = np.array([6, 7, 8])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 3))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve:\n2x + y - z = 3\nx + 3y + 2z = 7\n3x + 2y + 4z = 13",
    "output": "import numpy as np\n\nA = np.array([[2, 1, -1], [1, 3, 2], [3, 2, 4]])\nb = np.array([3, 7, 13])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\n2x + 2y + z = 9\nx + 3y + 3z = 13\n3x + y + 4z = 17",
    "output": "import numpy as np\n\nA = np.array([[2, 2, 1], [1, 3, 3], [3, 1, 4]])\nb = np.array([9, 13, 17])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve:\n4x + 2y = 10\n3x + 5y = 13\nx + y = 4",
    "output": "import numpy as np\n\nA = np.array([[4, 2], [3, 5], [1, 1]])\nb = np.array([10, 13, 4])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 3))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\nx + y = 4\nx - y = 2",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [1, -1]])\nb = np.array([4, 2])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve:\n2x + y = 5\nx + y = 3",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [1, 1]])\nb = np.array([5, 3])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve the system:\nx + 2y = 6\nx - y = 1\nusing SVD",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [1, -1]])\nb = np.array([6, 1])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD:\n2x + 3y = 8\nx + y = 3",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [1, 1]])\nb = np.array([8, 3])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\n3x + y = 7\nx + y = 4",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [1, 1]])\nb = np.array([7, 4])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "SVD solution:\n2x + y = 5\n4x + 2y = 10",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [4, 2]])\nb = np.array([5, 10])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 2))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD:\n3x + 2y = 11\nx - y = 1",
    "output": "import numpy as np\n\nA = np.array([[3, 2], [1, -1]])\nb = np.array([11, 1])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\nx + y = 5\nx + 2y = 7",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [1, 2]])\nb = np.array([5, 7])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve:\n2x + 3y = 6\n3x + 4y = 9",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [3, 4]])\nb = np.array([6, 9])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve this system:\n2x + y = 4\nx + 3y = 7\nusing SVD",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [1, 3]])\nb = np.array([4, 7])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "SVD solution:\n3x + 3y = 12\nx + 2y = 6",
    "output": "import numpy as np\n\nA = np.array([[3, 3], [1, 2]])\nb = np.array([12, 6])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\n2x + 2y = 6\nx + y = 3",
    "output": "import numpy as np\n\nA = np.array([[2, 2], [1, 1]])\nb = np.array([6, 3])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 2))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD:\n4x + y = 9\nx + y = 5",
    "output": "import numpy as np\n\nA = np.array([[4, 1], [1, 1]])\nb = np.array([9, 5])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve:\n3x + y = 7\nx + 2y = 6",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [1, 2]])\nb = np.array([7, 6])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve:\nx + 2y = 4\n2x + 3y = 7\nusing SVD",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 3]])\nb = np.array([4, 7])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "SVD solution:\n4x + y = 10\n2x + 2y = 8",
    "output": "import numpy as np\n\nA = np.array([[4, 1], [2, 2]])\nb = np.array([10, 8])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 2))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD:\nx + y = 3\n2x + 2y = 6",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [2, 2]])\nb = np.array([3, 6])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 2))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\nx + 2y = 6\n3x + y = 7",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 1]])\nb = np.array([6, 7])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "SVD solution:\n2x + 3y = 7\n4x + y = 9",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [4, 1]])\nb = np.array([7, 9])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve:\n3x + 2y = 10\nx + y = 4\nusing SVD",
    "output": "import numpy as np\n\nA = np.array([[3, 2], [1, 1]])\nb = np.array([10, 4])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve:\nx + y = 5\n2x + 3y = 11",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [2, 3]])\nb = np.array([5, 11])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\n4x + 3y = 15\nx + 2y = 7",
    "output": "import numpy as np\n\nA = np.array([[4, 3], [1, 2]])\nb = np.array([15, 7])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "SVD method:\n2x + 4y = 12\nx + y = 4",
    "output": "import numpy as np\n\nA = np.array([[2, 4], [1, 1]])\nb = np.array([12, 4])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "SVD solve:\n3x + y = 9\nx + y = 4",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [1, 1]])\nb = np.array([9, 4])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Determine the solution of this linear system using Singular Value Decomposition:\n2x + 3y = 13\nx + y = 5",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [1, 1]])\nb = np.array([13, 5])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Apply SVD to solve:\n3x + 4y = 18\nx + 2y = 8",
    "output": "import numpy as np\n\nA = np.array([[3, 4], [1, 2]])\nb = np.array([18, 8])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Using singular value decomposition, find the solution:\n2x + y = 7\nx + 3y = 10",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [1, 3]])\nb = np.array([7, 10])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "What is the solution of the system below using SVD?\n4x + 2y = 14\nx + y = 5",
    "output": "import numpy as np\n\nA = np.array([[4, 2], [1, 1]])\nb = np.array([14, 5])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2,2))\nS_inv[:len(S), :len(S)] = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use singular value decomposition to find the values of x and y:\n3x + y = 11\n2x + y = 9",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [2, 1]])\nb = np.array([11, 9])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Find x and y using SVD:\n2x + 3y = 12\nx + 4y = 10",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [1, 4]])\nb = np.array([12, 10])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to determine the solution of the linear system:\n4x + y = 13\nx + 2y = 7",
    "output": "import numpy as np\n\nA = np.array([[4, 1], [1, 2]])\nb = np.array([13, 7])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve the following equations using singular value decomposition:\n2x + 2y = 10\nx + 3y = 9",
    "output": "import numpy as np\n\nA = np.array([[2, 2], [1, 3]])\nb = np.array([10, 9])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Determine the least squares solution using SVD:\n3x + y = 8\nx + 2y = 6",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [1, 2]])\nb = np.array([8, 6])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Find the solution via SVD:\n2x + y = 7\nx + 2y = 8",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [1, 2]])\nb = np.array([7, 8])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve this system of equations:\n4x + 3y = 16\nx + y = 6",
    "output": "import numpy as np\n\nA = np.array([[4, 3], [1, 1]])\nb = np.array([16, 6])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve the following linear system using the SVD approach:\n2x + 5y = 19\nx + y = 6",
    "output": "import numpy as np\n\nA = np.array([[2, 5], [1, 1]])\nb = np.array([19, 6])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve the equations below using the singular value decomposition method:\n2x + y = 5\nx + 2y = 6",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [1, 2]])\nb = np.array([5, 6])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Using SVD, solve the following:\n3x + 2y = 11\n2x + 2y = 10",
    "output": "import numpy as np\n\nA = np.array([[3, 2], [2, 2]])\nb = np.array([11, 10])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use singular value decomposition to compute the solution:\nx + 4y = 10\n2x + 3y = 12",
    "output": "import numpy as np\n\nA = np.array([[1, 4], [2, 3]])\nb = np.array([10, 12])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve via SVD:\n2x + y = 6\nx + 3y = 9",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [1, 3]])\nb = np.array([6, 9])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Determine the values of x and y using the SVD technique:\n3x + y = 9\nx + 2y = 7",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [1, 2]])\nb = np.array([9, 7])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Find the SVD solution to:\n2x + 2y = 8\n3x + y = 9",
    "output": "import numpy as np\n\nA = np.array([[2, 2], [3, 1]])\nb = np.array([8, 9])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2, 2))\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve with SVD:\n3x + 3y = 15\n2x + y = 8",
    "output": "import numpy as np\n\nA = np.array([[3, 3], [2, 1]])\nb = np.array([15, 8])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Find the solution to this system using SVD:\n4x + 3y = 17\nx + y = 6",
    "output": "import numpy as np\n\nA = np.array([[4, 3], [1, 1]])\nb = np.array([17, 6])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use the singular value decomposition method to solve:\n2x + y = 5\nx + 2y = 7",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [1, 2]])\nb = np.array([5, 7])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve the following using singular value decomposition:\nA = [[2, 1], [3, 2]], b = [7, 13]",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [3, 2]])\nb = np.array([7, 13])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Given the matrix system Ax = b with\nA = [[4, 2], [1, 3]] and b = [14, 10], find x using SVD.",
    "output": "import numpy as np\n\nA = np.array([[4, 2], [1, 3]])\nb = np.array([14, 10])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve the system:\n5x + 2y = 21\n3x + 4y = 24",
    "output": "import numpy as np\n\nA = np.array([[5, 2], [3, 4]])\nb = np.array([21, 24])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\n6x + y = 20\nx + 5y = 19",
    "output": "import numpy as np\n\nA = np.array([[6, 1], [1, 5]])\nb = np.array([20, 19])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Find the solution using singular value decomposition for the matrix equation:\nA = [[3, 5], [1, 6]]\nb = [19, 17]",
    "output": "import numpy as np\n\nA = np.array([[3, 5], [1, 6]])\nb = np.array([19, 17])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve:\n2x + 6y = 26\nx + 2y = 10",
    "output": "import numpy as np\n\nA = np.array([[2, 6], [1, 2]])\nb = np.array([26, 10])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Given:\nA = [[2, 4], [3, 1]],\nb = [16, 11]\nFind x such that Ax = b using SVD.",
    "output": "import numpy as np\n\nA = np.array([[2, 4], [3, 1]])\nb = np.array([16, 11])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use singular value decomposition to solve this system:\n7x + y = 30\n2x + 3y = 18",
    "output": "import numpy as np\n\nA = np.array([[7, 1], [2, 3]])\nb = np.array([30, 18])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Apply SVD to this matrix equation:\nA = [[5, 2], [4, 6]]\nb = [23, 40]",
    "output": "import numpy as np\n\nA = np.array([[5, 2], [4, 6]])\nb = np.array([23, 40])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using singular value decomposition:\n3x + 7y = 34\n5x + 2y = 29",
    "output": "import numpy as np\n\nA = np.array([[3, 7], [5, 2]])\nb = np.array([34, 29])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve the system below using SVD:\n2x + 5y = 21\n4x + 3y = 26",
    "output": "import numpy as np\n\nA = np.array([[2, 5], [4, 3]])\nb = np.array([21, 26])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to determine the solution of the system:\nA = [[6, 4], [3, 2]], b = [28, 14]",
    "output": "import numpy as np\n\nA = np.array([[6, 4], [3, 2]])\nb = np.array([28, 14])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Determine the solution using SVD:\n4x + 7y = 43\n6x + y = 28",
    "output": "import numpy as np\n\nA = np.array([[4, 7], [6, 1]])\nb = np.array([43, 28])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve this matrix equation using singular value decomposition:\nA = [[1, 8], [5, 3]], b = [33, 28]",
    "output": "import numpy as np\n\nA = np.array([[1, 8], [5, 3]])\nb = np.array([33, 28])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Apply SVD to solve:\nx + 5y = 19\n6x + 3y = 33",
    "output": "import numpy as np\n\nA = np.array([[1, 5], [6, 3]])\nb = np.array([19, 33])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use singular value decomposition to compute x in the matrix system:\nA = [[4, 6], [2, 3]], b = [36, 18]",
    "output": "import numpy as np\n\nA = np.array([[4, 6], [2, 3]])\nb = np.array([36, 18])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve using SVD:\n5x + 4y = 31\nx + 6y = 29",
    "output": "import numpy as np\n\nA = np.array([[5, 4], [1, 6]])\nb = np.array([31, 29])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Given the matrix A and vector b:\nA = [[7, 2], [5, 4]], b = [33, 37]\nSolve Ax = b using SVD.",
    "output": "import numpy as np\n\nA = np.array([[7, 2], [5, 4]])\nb = np.array([33, 37])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Solve the system below using the singular value decomposition method:\nA = [[6, 2], [4, 5]], b = [30, 34]",
    "output": "import numpy as np\n\nA = np.array([[6, 2], [4, 5]])\nb = np.array([30, 34])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Use SVD to solve this linear system:\n3x + 8y = 46\n5x + 2y = 34",
    "output": "import numpy as np\n\nA = np.array([[3, 8], [5, 2]])\nb = np.array([46, 34])\n\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(x)"
  },
  {
    "input": "Compute the SVD of the matrix A = [[3, 2], [2, 3]].",
    "output": "import numpy as np\n\nA = np.array([[3, 2], [2, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('Singular values:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Given matrix A = [[4, 0], [3, -5]], find its singular values.",
    "output": "import numpy as np\n\nA = np.array([[4, 0], [3, -5]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)"
  },
  {
    "input": "For A = [[1, 2, 3], [4, 5, 6]], determine the matrices U, S, and Vt from its SVD.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [4, 5, 6]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Find the rank of matrix A = [[7, 8], [9, 10]] using its singular values.",
    "output": "import numpy as np\n\nA = np.array([[7, 8], [9, 10]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank:', rank)"
  },
  {
    "input": "Given A = [[2, 4], [1, 3], [0, 0]], compute its SVD and verify U * diag(S) * Vt equals A.",
    "output": "import numpy as np\n\nA = np.array([[2, 4], [1, 3], [0, 0]])\nU, S, Vt = np.linalg.svd(A)\n\n# Create full Sigma matrix with same shape as A\nS_full = np.zeros((3, 2))\nnp.fill_diagonal(S_full, S)\n\nA_reconstructed = U @ S_full @ Vt\nprint('Reconstructed A:', A_reconstructed)"
  },
  {
    "input": "For matrix A = [[5, 5, 5], [5, 5, 5]], determine if it has full rank using SVD.",
    "output": "import numpy as np\n\nA = np.array([[5, 5, 5], [5, 5, 5]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Full rank:', rank == min(A.shape))"
  },
  {
    "input": "Compute the condition number of A = [[1, 2], [3, 4]] using its singular values.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4]])\n_, S, _ = np.linalg.svd(A)\ncondition_number = S.max() / S.min()\nprint('Condition number:', condition_number)"
  },
  {
    "input": "Given A = [[1, 0, 0], [0, 2, 0], [0, 0, 3]], find its SVD and interpret the results.",
    "output": "import numpy as np\n\nA = np.array([[1, 0, 0], [0, 2, 0], [0, 0, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "For A = [[0, 1], [1, 0]], compute its SVD and explain the significance of the singular values.",
    "output": "import numpy as np\n\nA = np.array([[0, 1], [1, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Determine the null space of A = [[2, 4], [1, 2]] using SVD.",
    "output": "import numpy as np\n\nA = np.array([[2, 4], [1, 2]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space:', null_space)"
  },
  {
    "input": "Compute the pseudoinverse of A = [[1, 2], [3, 4], [5, 6]] using SVD.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros_like(A.T, dtype=float)\nS_inv[:len(S), :len(S)] = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nprint('Pseudoinverse of A:', A_pinv)"
  },
  {
    "input": "For A = [[3, 0, 0], [0, 2, 0], [0, 0, 1]], verify that its singular values are the diagonal elements.",
    "output": "import numpy as np\n\nA = np.array([[3, 0, 0], [0, 2, 0], [0, 0, 1]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)"
  },
  {
    "input": "Given A = [[1, 2], [2, 1]], compute its SVD and discuss the orthogonality of U and Vt.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 1]])\nU, _, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('Vt:', Vt)\nprint('U orthogonal:', np.allclose(U @ U.T, np.eye(U.shape[0])))\nprint('Vt orthogonal:', np.allclose(Vt @ Vt.T, np.eye(Vt.shape[0])))"
  },
  {
    "input": "For A = [[2, 3], [5, 7]], compute its SVD and determine the energy captured by the first singular value.",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [5, 7]])\n_, S, _ = np.linalg.svd(A)\nenergy = (S[0]**2) / np.sum(S**2)\nprint('Energy captured by first singular value:', energy)"
  },
  {
    "input": "Find the best rank-1 approximation of A = [[1, 2], [3, 4]] using SVD.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Rank-1 approximation:', A_rank1)"
  },
  {
    "input": "Given matrix A = [[3, 1], [0, 2]], use SVD to compute A\u00e1\u00b5\u2014A and confirm it's equal to V\u00ce\u00a3\u00c2\u00b2V\u00e1\u00b5\u2014.",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [0, 2]])\nU, S, Vt = np.linalg.svd(A)\nAtA = A.T @ A\nSigma_squared = Vt.T @ np.diag(S**2) @ Vt\nprint('A\u00e1\u00b5\u2014A:', AtA)\nprint('V\u00ce\u00a3\u00c2\u00b2V\u00e1\u00b5\u2014:', Sigma_squared)"
  },
  {
    "input": "If A = [[2, 2], [1, 3]], compute the SVD and verify if V is orthonormal.",
    "output": "import numpy as np\n\nA = np.array([[2, 2], [1, 3]])\n_, _, Vt = np.linalg.svd(A)\nV = Vt.T\nprint('Is V orthonormal?', np.allclose(V @ V.T, np.eye(V.shape[0])))"
  },
  {
    "input": "Find the SVD of A = [[1, 0], [0, 0], [0, 0]] and interpret the geometry of the transformation.",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [0, 0], [0, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "A matrix A = [[1, 1], [1, 1]] has repeated rows. Use SVD to confirm its rank and interpret it.",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [1, 1]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)\nprint('Rank:', np.sum(S > 1e-10))"
  },
  {
    "input": "Using SVD, determine whether A = [[0, 0], [0, 0]] has full rank.",
    "output": "import numpy as np\n\nA = np.array([[0, 0], [0, 0]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)\nprint('Rank:', np.sum(S > 1e-10))"
  },
  {
    "input": "Let A = [[1, 2], [2, 4]]. Find the null space using its SVD components.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 4]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space:', null_space)"
  },
  {
    "input": "Given A = [[3, 1], [0, 2]], compute the compact SVD and reconstruct the matrix.",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [0, 2]])\nU, S, Vt = np.linalg.svd(A)\nA_reconstructed = U @ np.diag(S) @ Vt\nprint('Reconstructed A:', A_reconstructed)"
  },
  {
    "input": "Use SVD to find a basis for the column space of A = [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\ncolumn_space_basis = U[:, :rank]\nprint('Basis for column space:', column_space_basis)"
  },
  {
    "input": "Given a rectangular matrix A = [[1, 2, 3], [4, 5, 6]], use SVD to estimate the rank.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [4, 5, 6]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Estimated rank:', rank)"
  },
  {
    "input": "For A = [[2, 0, 0], [0, 0, 0]], find its SVD and describe what the singular values represent.",
    "output": "import numpy as np\n\nA = np.array([[2, 0, 0], [0, 0, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('Singular values:', S)"
  },
  {
    "input": "Use SVD to verify if A = [[6, 0], [0, 2]] is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[6, 0], [0, 2]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)\n# Diagonal matrices are already diagonalizable"
  },
  {
    "input": "Matrix A = [[2, 3], [2, 3]] is not full rank. Use SVD to explore its properties.",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [2, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Decompose the matrix A = [[2, -1], [-1, 2]] using Singular Value Decomposition.",
    "output": "import numpy as np\n\nA = np.array([[2, -1], [-1, 2]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Using SVD, analyze the transformation behavior of matrix A = [[0, 4], [3, 0]].",
    "output": "import numpy as np\n\nA = np.array([[0, 4], [3, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Matrix A = [[6, 1], [2, 5]]: Find its SVD and compute U\u00ce\u00a3V\u00e1\u00b5\u2014 to verify reconstruction.",
    "output": "import numpy as np\n\nA = np.array([[6, 1], [2, 5]])\nU, S, Vt = np.linalg.svd(A)\nA_reconstructed = U @ np.diag(S) @ Vt\nprint('Reconstructed A:', A_reconstructed)"
  },
  {
    "input": "Compute the singular values of matrix A = [[1, 1], [1, -1]].",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [1, -1]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)"
  },
  {
    "input": "Let A be [[3, 4], [0, 0], [0, 0]]. Perform SVD and interpret the rank.",
    "output": "import numpy as np\n\nA = np.array([[3, 4], [0, 0], [0, 0]])\n_, S, _ = np.linalg.svd(A)\nprint('Rank:', np.sum(S > 1e-10))"
  },
  {
    "input": "Determine U, \u00ce\u00a3, and V\u00e1\u00b5\u2014 for matrix A = [[1, 0, 0], [0, 1, 0]].",
    "output": "import numpy as np\n\nA = np.array([[1, 0, 0], [0, 1, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Perform SVD on matrix A = [[2, 2], [2, -2]] and discuss the spread of singular values.",
    "output": "import numpy as np\n\nA = np.array([[2, 2], [2, -2]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)"
  },
  {
    "input": "Use SVD to compute the pseudoinverse of A = [[0, 1], [1, 1]].",
    "output": "import numpy as np\n\nA = np.array([[0, 1], [1, 1]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nprint('Pseudoinverse:', A_pinv)"
  },
  {
    "input": "Given matrix A = [[1, 3], [2, 6]], determine if it is rank deficient using SVD.",
    "output": "import numpy as np\n\nA = np.array([[1, 3], [2, 6]])\n_, S, _ = np.linalg.svd(A)\nprint('Rank:', np.sum(S > 1e-10))"
  },
  {
    "input": "Let A = [[5, 1, 0], [0, 0, 0]]. Use SVD to analyze its rank and basis vectors.",
    "output": "import numpy as np\n\nA = np.array([[5, 1, 0], [0, 0, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Compute the best rank-1 approximation for A = [[4, 0], [3, 0]].",
    "output": "import numpy as np\n\nA = np.array([[4, 0], [3, 0]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Rank-1 approximation:', A_rank1)"
  },
  {
    "input": "Given A = [[1, 2], [2, 1]], use SVD to check if its transformation preserves volume.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 1]])\n_, S, _ = np.linalg.svd(A)\ndet = S[0] * S[1]\nprint('Determinant of A\u00e1\u00b5\u2014A (volume squared):', det)"
  },
  {
    "input": "Matrix A = [[0, 1], [-1, 0]]. Analyze its rotation behavior using SVD.",
    "output": "import numpy as np\n\nA = np.array([[0, 1], [-1, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "For matrix A = [[1, 2], [2, 5]], compute its SVD and confirm orthonormality of V.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 5]])\n_, _, Vt = np.linalg.svd(A)\nV = Vt.T\nprint('Orthonormal V:', np.allclose(V.T @ V, np.eye(V.shape[1])))"
  },
  {
    "input": "Given A = [[2, 3], [2, 3]], find SVD and explain the geometry of compression.",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [2, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Let A = [[0, 2], [0, 0], [0, 0]]. Use SVD to determine its image space.",
    "output": "import numpy as np\n\nA = np.array([[0, 2], [0, 0], [0, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('Image space basis:', U[:, :np.sum(S > 1e-10)])"
  },
  {
    "input": "Matrix A = [[4, 1], [2, 2]]. Perform SVD and assess singular value spread.",
    "output": "import numpy as np\n\nA = np.array([[4, 1], [2, 2]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)"
  },
  {
    "input": "Is A = [[1, 1], [1, 1]] invertible? Use SVD to justify your answer.",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [1, 1]])\n_, S, _ = np.linalg.svd(A)\nprint('Invertible:', np.all(S > 1e-10))"
  },
  {
    "input": "Given matrix A = [[1, 0, 0], [0, 0, 0]], perform SVD and interpret the null space.",
    "output": "import numpy as np\n\nA = np.array([[1, 0, 0], [0, 0, 0]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space:', null_space)"
  },
  {
    "input": "Let A = [[2, 1, 0], [1, 2, 0]]. Use SVD to check orthogonality of left singular vectors.",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 0], [1, 2, 0]])\nU, _, _ = np.linalg.svd(A)\nprint('U orthogonal:', np.allclose(U.T @ U, np.eye(U.shape[1])))"
  },
  {
    "input": "Use SVD to extract the null space of matrix A = [[1, 2], [2, 4]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 4]])\nU, S, Vt = np.linalg.svd(A)\nnull_mask = (S <= 1e-10)\nnull_space = Vt.T[:, null_mask]\nprint('Null space:', null_space)"
  },
  {
    "input": "For A = [[0, 1], [1, 0]], compute its SVD and examine rotation/reflection.",
    "output": "import numpy as np\n\nA = np.array([[0, 1], [1, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Given A = [[1, 0], [0, 2], [0, 0]], use SVD to find orthonormal basis for range(A).",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [0, 2], [0, 0]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nrange_basis = U[:, :rank]\nprint('Range basis:', range_basis)"
  },
  {
    "input": "Given A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], perform an SVD and compute the optimal rank-2 approximation.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Optimal rank-2 approximation:', A_rank2)"
  },
  {
    "input": "Perform SVD on matrix A = [[3, 1], [4, 2]] and verify the reconstruction error for rank-1 approximation.",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [4, 2]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nreconstruction_error = np.linalg.norm(A - A_rank1)\nprint('Reconstruction error for rank-1 approximation:', reconstruction_error)"
  },
  {
    "input": "Let A = [[1, 2], [2, 3], [3, 4]]. Perform an SVD and determine the total energy captured by the first two singular values.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 3], [3, 4]])\n_, S, _ = np.linalg.svd(A)\nenergy = np.sum(S[:2]**2) / np.sum(S**2)\nprint('Energy captured by the first two singular values:', energy)"
  },
  {
    "input": "Given A = [[1, 0], [0, 0], [0, 0]], compute the rank and verify the rank using SVD.",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [0, 0], [0, 0]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank of A:', rank)"
  },
  {
    "input": "Use SVD to compute the pseudoinverse of A = [[1, 2], [3, 4], [5, 6]] and verify the properties.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\n\n# Create S_inv as a (2x3) matrix\nS_inv = np.zeros((2, 3))\nnp.fill_diagonal(S_inv, 1 / S)\n\nA_pinv = Vt.T @ S_inv @ U.T\nprint('Pseudoinverse of A:', A_pinv)\n\n# Verify A @ A+ @ A \u00e2\u2030\u02c6 A and A+ @ A @ A+ \u00e2\u2030\u02c6 A+\nA_check = A @ A_pinv @ A\nA_pinv_check = A_pinv @ A @ A_pinv\nprint('A @ A+ @ A:', A_check)\nprint('A+ @ A @ A+:', A_pinv_check)"
  },
  {
    "input": "Given A = [[1, 2], [2, 1]], perform SVD and analyze the singular values in the context of its invertibility.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 1]])\n_, S, _ = np.linalg.svd(A)\nprint('Singular values:', S)\nprint('Is invertible?', np.all(S > 1e-10))"
  },
  {
    "input": "Matrix A = [[0, 1], [1, 0]] is a 2D rotation matrix. Use SVD to verify the rotation properties of A.",
    "output": "import numpy as np\n\nA = np.array([[0, 1], [1, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "For a large matrix A with dimensions 1000x1000, perform an SVD and compute the sum of squared singular values.",
    "output": "import numpy as np\n\nA = np.random.rand(1000, 1000)\n_, S, _ = np.linalg.svd(A)\nsum_squared_singular_values = np.sum(S**2)\nprint('Sum of squared singular values:', sum_squared_singular_values)"
  },
  {
    "input": "Given A = [[3, 5, 1], [4, 6, 0]], compute the SVD and interpret the null space of A.",
    "output": "import numpy as np\n\nA = np.array([[3, 5, 1], [4, 6, 0]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space of A:', null_space)"
  },
  {
    "input": "Perform SVD on matrix A = [[1, 1, 0], [0, 1, 1]] and describe the geometric transformation represented by A.",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 0], [0, 1, 1]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Given A = [[1, 0], [0, 1], [0, 0]], perform SVD and compute the energy captured by the first singular value.",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [0, 1], [0, 0]])\n_, S, _ = np.linalg.svd(A)\nenergy = (S[0]**2) / np.sum(S**2)\nprint('Energy captured by the first singular value:', energy)"
  },
  {
    "input": "Let A = [[5, 5, 5], [10, 10, 10]]. Perform SVD and determine the rank of the matrix.",
    "output": "import numpy as np\n\nA = np.array([[5, 5, 5], [10, 10, 10]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank of A:', rank)"
  },
  {
    "input": "Given A = [[1, 2], [3, 4], [5, 6]], find the best rank-1 approximation using SVD and explain the error.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nreconstruction_error = np.linalg.norm(A - A_rank1)\nprint('Rank-1 approximation error:', reconstruction_error)"
  },
  {
    "input": "Use SVD to analyze matrix A = [[4, 1], [1, 4]] and determine if it is positive definite.",
    "output": "import numpy as np\n\nA = np.array([[4, 1], [1, 4]])\n_, S, _ = np.linalg.svd(A)\npositive_definite = np.all(S > 0)\nprint('Is the matrix positive definite?', positive_definite)"
  },
  {
    "input": "Given A = [[1, 0, 0], [0, 2, 0], [0, 0, 3]], use SVD to compute the condition number of A.",
    "output": "import numpy as np\n\nA = np.array([[1, 0, 0], [0, 2, 0], [0, 0, 3]])\n_, S, _ = np.linalg.svd(A)\ncondition_number = S[0] / S[-1]\nprint('Condition number of A:', condition_number)"
  },
  {
    "input": "Given matrix A = [[1, 1], [1, -1]], compute the SVD and verify if it is orthogonal.",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [1, -1]])\nU, S, Vt = np.linalg.svd(A)\northogonal = np.allclose(U.T @ U, np.eye(U.shape[1])) and np.allclose(Vt @ Vt.T, np.eye(Vt.shape[0]))\nprint('Is A orthogonal?', orthogonal)"
  },
  {
    "input": "Given a matrix A = [[3, 2], [2, 3]], perform SVD and verify the matrix's rank-2 approximation.",
    "output": "import numpy as np\n\nA = np.array([[3, 2], [2, 3]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
  },
  {
    "input": "Use SVD to compute the error in approximating matrix A = [[2, 0], [0, 3], [4, 0]] with its rank-1 approximation.",
    "output": "import numpy as np\n\nA = np.array([[2, 0], [0, 3], [4, 0]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nerror = np.linalg.norm(A - A_rank1)\nprint('Error in rank-1 approximation:', error)"
  },
  {
    "input": "Perform SVD on matrix A = [[1, 0, 0], [0, 0, 0], [0, 0, 1]] and analyze the null space.",
    "output": "import numpy as np\n\nA = np.array([[1, 0, 0], [0, 0, 0], [0, 0, 1]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space:', null_space)"
  },
  {
    "input": "Given A = [[1, 2], [3, 4]], compute its SVD and determine the distance between A and its rank-1 approximation.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\ndistance = np.linalg.norm(A - A_rank1)\nprint('Distance between A and its rank-1 approximation:', distance)"
  },
  {
    "input": "Given matrix A = [[2, 3, 4], [5, 6, 7], [8, 9, 10]], compute its SVD and determine the rank and nullity.",
    "output": "import numpy as np\n\nA = np.array([[2, 3, 4], [5, 6, 7], [8, 9, 10]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nnullity = A.shape[1] - rank\nprint('Rank:', rank)\nprint('Nullity:', nullity)"
  },
  {
    "input": "Use SVD to compute the best rank-2 approximation of A = [[1, 1, 1], [2, 2, 2], [3, 3, 3]].",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Best rank-2 approximation:', A_rank2)"
  },
  {
    "input": "Matrix A = [[3, 5], [5, 7]] is symmetric. Use SVD to verify the eigendecomposition properties of A.",
    "output": "import numpy as np\n\nA = np.array([[3, 5], [5, 7]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Given A = [[0, 0, 1], [0, 1, 0], [1, 0, 0]], use SVD to show that A is an orthogonal matrix.",
    "output": "import numpy as np\n\nA = np.array([[0, 0, 1], [0, 1, 0], [1, 0, 0]])\nU, S, Vt = np.linalg.svd(A)\northogonal = np.allclose(U.T @ U, np.eye(U.shape[1])) and np.allclose(Vt @ Vt.T, np.eye(Vt.shape[0]))\nprint('Is A orthogonal?', orthogonal)"
  },
  {
    "input": "Let A be a 5x5 matrix with singular values 1, 2, 3, 4, 5. Calculate the condition number of A.",
    "output": "import numpy as np\n\nS = np.array([1, 2, 3, 4, 5])\ncondition_number = S[0] / S[-1]\nprint('Condition number of A:', condition_number)"
  },
  {
    "input": "Given A = [[1, 1], [0, 1], [0, 0]], perform SVD and calculate the best rank-1 approximation.",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [0, 1], [0, 0]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Best rank-1 approximation:', A_rank1)"
  },
  {
    "input": "Use SVD to compute the pseudoinverse of a 3x3 matrix A = [[1, 2, 3], [0, 4, 5], [6, 7, 8]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [0, 4, 5], [6, 7, 8]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1 / S)\nA_pinv = Vt.T @ S_inv @ U.T\nprint('Pseudoinverse of A:', A_pinv)"
  },
  {
    "input": "Given matrix A = [[1, 0], [0, 1], [0, 0]], use SVD to find the null space and rank of A.",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [0, 1], [0, 0]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nrank = np.sum(S > 1e-10)\nprint('Null space:', null_space)\nprint('Rank:', rank)"
  },
  {
    "input": "Matrix A = [[4, 4], [1, 2], [3, 5]] has 3 rows and 2 columns. Perform SVD and compute the rank and condition number of A.",
    "output": "import numpy as np\n\nA = np.array([[4, 4], [1, 2], [3, 5]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\ncondition_number = S[0] / S[-1]\nprint('Rank:', rank)\nprint('Condition number:', condition_number)"
  },
  {
    "input": "Given matrix A = [[3, 1], [4, 2], [5, 3]], perform SVD and compute the best rank-2 approximation.",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [4, 2], [5, 3]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Best rank-2 approximation:', A_rank2)"
  },
  {
    "input": "Use SVD to find the optimal rank-3 approximation of A = [[1, 0, 1], [2, 3, 4], [5, 6, 7]].",
    "output": "import numpy as np\n\nA = np.array([[1, 0, 1], [2, 3, 4], [5, 6, 7]])\nU, S, Vt = np.linalg.svd(A)\nA_rank3 = U[:, :3] @ np.diag(S[:3]) @ Vt[:3, :]\nprint('Optimal rank-3 approximation:', A_rank3)"
  },
  {
    "input": "Given A = [[1, 2], [3, 4], [5, 6]], compute the singular values and their contribution to the matrix energy.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\n_, S, _ = np.linalg.svd(A)\nenergy = np.sum(S**2)\nprint('Matrix energy:', energy)"
  },
  {
    "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] is decomposed using SVD. Determine the best rank-2 approximation and the error between the original and approximation.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nerror = np.linalg.norm(A - A_rank2)\nprint('Rank-2 approximation error:', error)"
  },
  {
    "input": "Given A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], perform SVD and compute the optimal rank-1 approximation.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Optimal rank-1 approximation:', A_rank1)"
  },
  {
    "input": "Given A = [[2, 2], [3, 3]], perform SVD and check the orthogonality of the U and V matrices.",
    "output": "import numpy as np\n\nA = np.array([[2, 2], [3, 3]])\nU, S, Vt = np.linalg.svd(A)\northogonal_U = np.allclose(U.T @ U, np.eye(U.shape[1]))\northogonal_Vt = np.allclose(Vt @ Vt.T, np.eye(Vt.shape[0]))\nprint('Is U orthogonal?', orthogonal_U)\nprint('Is Vt orthogonal?', orthogonal_Vt)"
  },
  {
    "input": "Perform SVD on matrix A = [[1, 0, 1], [0, 1, 1], [1, 0, 0]] and find the rank of the matrix.",
    "output": "import numpy as np\n\nA = np.array([[1, 0, 1], [0, 1, 1], [1, 0, 0]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank of A:', rank)"
  },
  {
    "input": "Given matrix A = [[1, 1, 1], [2, 2, 2], [3, 3, 3]], compute its SVD and explain the implications for matrix approximation.",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Use SVD to compute the rank-2 approximation of matrix A = [[1, 1], [2, 2], [3, 3]] and explain the dimensionality reduction process.",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [2, 2], [3, 3]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
  },
  {
    "input": "Given matrix A = [[2, 3], [4, 5], [6, 7]], compute the SVD and explain its role in dimensionality reduction.",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [4, 5], [6, 7]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Use SVD to compute the best rank-3 approximation of matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nA_rank3 = U[:, :3] @ np.diag(S[:3]) @ Vt[:3, :]\nprint('Best rank-3 approximation:', A_rank3)"
  },
  {
    "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and determine its rank.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank of A:', rank)"
  },
  {
    "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] has orthogonal columns. Compute A^T A.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nAtA = A.T @ A\nprint('A^T A:', AtA)"
  },
  {
    "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and explain its role in dimensionality reduction.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Use SVD to compute the Moore-Penrose pseudoinverse of A = [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\n\n# Create S_inv with proper shape\nS_inv = np.zeros((2, 3))\nnp.fill_diagonal(S_inv, 1 / S)\n\nA_pinv = Vt.T @ S_inv @ U.T\nprint('Pseudoinverse of A:', A_pinv)"
  },
  {
    "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and determine the null space.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space of A:', null_space)"
  },
  {
    "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] is decomposed using SVD. Compute the best rank-1 approximation.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Best rank-1 approximation:', A_rank1)"
  },
  {
    "input": "Use SVD to compute the rank-2 approximation of A = [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
  },
  {
    "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and explain its application in image compression.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] is decomposed using SVD. Compute the condition number of A.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\ncondition_number = S[0] / S[-1]\nprint('Condition number of A:', condition_number)"
  },
  {
    "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and determine the rank and nullity.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nnullity = A.shape[1] - rank\nprint('Rank of A:', rank)\nprint('Nullity of A:', nullity)"
  },
  {
    "input": "Use SVD to compute the best rank-1 approximation of A = [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\n\n# Best rank-1 approximation using first singular value\nrank = 1\nA_rank1 = U[:, :rank] @ np.diag(S[:rank]) @ Vt[:rank, :]\nprint('Rank-1 approximation:', A_rank1)"
  },
  {
    "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute its SVD and explain its role in principal component analysis.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] is decomposed using SVD. Compute the rank and condition number of A.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\ncondition_number = S[0] / S[-1]\nprint('Rank of A:', rank)\nprint('Condition number of A:', condition_number)"
  },
  {
    "input": "Given matrix A = [[1, 2], [3, 4], [5, 6]], compute the rank-2 approximation using SVD.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
  },
  {
    "input": "Use SVD to compute the pseudoinverse of matrix A = [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\n\n# Create S_inv with correct shape (2x3)\nS_inv = np.zeros((2, 3))\nnp.fill_diagonal(S_inv, 1 / S)\n\nA_pinv = Vt.T @ S_inv @ U.T\nprint('Pseudoinverse of A:', A_pinv)"
  },
  {
    "input": "Given matrix A = [[2, 3], [5, 7], [8, 9]], use SVD to compute the rank and null space.",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [5, 7], [8, 9]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nrank = np.sum(S > 1e-10)\nprint('Null space:', null_space)\nprint('Rank:', rank)"
  },
  {
    "input": "Matrix A = [[2, 3], [4, 5], [6, 7]] has orthogonal columns. Compute the condition number of A.",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [4, 5], [6, 7]])\nU, S, Vt = np.linalg.svd(A)\ncondition_number = S[0] / S[-1]\nprint('Condition number of A:', condition_number)"
  },
  {
    "input": "Given matrix A = [[1, 1, 1], [1, 2, 3], [2, 3, 4]], compute the SVD and determine the optimal rank-2 approximation.",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 1], [1, 2, 3], [2, 3, 4]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
  },
  {
    "input": "Matrix A = [[3, 1], [1, 2], [4, 5]] is decomposed using SVD. Compute its rank and explain the significance of the singular values.",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [1, 2], [4, 5]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank of A:', rank)\nprint('Singular values:', S)"
  },
  {
    "input": "Given matrix A = [[4, 2, 1], [1, 2, 3], [2, 3, 4]], compute its SVD and explain how to use it in dimensionality reduction.",
    "output": "import numpy as np\n\nA = np.array([[4, 2, 1], [1, 2, 3], [2, 3, 4]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('S:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Use SVD to compute the best rank-2 approximation of matrix A = [[4, 2], [1, 3], [2, 4]].",
    "output": "import numpy as np\n\nA = np.array([[4, 2], [1, 3], [2, 4]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
  },
  {
    "input": "Given A = [[1, 1], [1, 2], [2, 3]], perform SVD and compute its null space.",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [1, 2], [2, 3]])\nU, S, Vt = np.linalg.svd(A)\nnull_space = Vt.T[:, np.where(S <= 1e-10)[0]]\nprint('Null space of A:', null_space)"
  },
  {
    "input": "Matrix A = [[1, 2], [3, 4], [5, 6]] is decomposed using SVD. Compute the rank and explain how the singular values are related to the rank of A.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Rank of A:', rank)\nprint('Singular values:', S)"
  },
  {
    "input": "Use SVD to compute the rank-1 approximation of matrix A = [[4, 5], [7, 8], [10, 11]].",
    "output": "import numpy as np\n\nA = np.array([[4, 5], [7, 8], [10, 11]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Rank-1 approximation:', A_rank1)"
  },
  {
    "input": "Matrix A = [[2, 4], [6, 8], [10, 12]] is decomposed using SVD. Compute the rank-2 approximation.",
    "output": "import numpy as np\n\nA = np.array([[2, 4], [6, 8], [10, 12]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
  },
  {
    "input": "Given A = [[1, 2], [3, 4], [5, 6]], compute the best rank-1 approximation using SVD.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\nA_rank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint('Best rank-1 approximation:', A_rank1)"
  },
  {
    "input": "Use SVD to compute the optimal rank-2 approximation of matrix A = [[3, 3], [2, 2], [4, 5]].",
    "output": "import numpy as np\n\nA = np.array([[3, 3], [2, 2], [4, 5]])\nU, S, Vt = np.linalg.svd(A)\nA_rank2 = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Rank-2 approximation:', A_rank2)"
  },
  {
    "input": "Use SVD to analyze a dataset of hotel reviews and identify the key aspects of hotel quality that customers value most.",
    "output": "import numpy as np\n\n# Hotel review matrix\nA = np.array([[5, 4], [3, 2], [4, 5]])\nU, S, Vt = np.linalg.svd(A)\nquality_factors = Vt[:2, :]\nprint('Key aspects of hotel quality:', quality_factors)"
  },
  {
    "input": "Apply SVD to detect fraudulent transactions in a financial dataset based on spending patterns.",
    "output": "import numpy as np\n\n# Simulated transaction matrix: rows = users, columns = categories\nA = np.array([\n    [100, 200, 300],\n    [90, 210, 310],\n    [5000, 20, 10]  # Anomalous transaction pattern\n])\n\n# Apply SVD\nU, S, Vt = np.linalg.svd(A, full_matrices=False)\n\n# Reconstruct using rank-1 approximation (normal behavior)\nk = 1\nA_approx = U[:, :k] @ np.diag(S[:k]) @ Vt[:k, :]\n\n# Compute residuals\nresiduals = np.linalg.norm(A - A_approx, axis=1)\n\n# Flag transactions with high reconstruction error\nthreshold = 1000\nfraudulent_indices = np.where(residuals > threshold)[0]\nprint('Potentially fraudulent transaction rows:', fraudulent_indices)"
  },
  {
    "input": "Given a large set of images, use SVD to reduce dimensionality and speed up facial recognition.",
    "output": "import numpy as np\n\n# Image data matrix\nA = np.array([[1, 0], [0, 1], [1, 1]])\nU, S, Vt = np.linalg.svd(A)\nreduced_images = U[:, :2] @ np.diag(S[:2]) @ Vt[:2, :]\nprint('Reduced image data for facial recognition:', reduced_images)"
  },
  {
    "input": "Given a dataset of handwritten digits, apply SVD to reduce dimensionality and improve classification accuracy.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\nfrom sklearn.datasets import load_digits\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import KNeighborsClassifier\n\n# Load dataset\ndigits = load_digits()\nX = digits.data\ny = digits.target\n\n# Split data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=40, random_state=42)\nX_train_svd = svd.fit_transform(X_train)\nX_test_svd = svd.transform(X_test)\n\n# Train classifier\nclf = KNeighborsClassifier(n_neighbors=3)\nclf.fit(X_train_svd, y_train)\n\n# Evaluate\naccuracy = clf.score(X_test_svd, y_test)\nprint('Classification accuracy:', accuracy)"
  },
  {
    "input": "Use SVD to identify latent factors in a recommender system based on user-item interaction data.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\nfrom sklearn.metrics import mean_squared_error\n\n# User-item interaction matrix\nR = np.array([[5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [1, 0, 0, 4], [0, 1, 5, 4]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nR_svd = svd.fit_transform(R)\nR_reconstructed = np.dot(R_svd, svd.components_)\n\n# Evaluate reconstruction\nmse = mean_squared_error(R, R_reconstructed)\nprint('Mean Squared Error of reconstruction:', mse)"
  },
  {
    "input": "Apply SVD to detect anomalies in sensor data collected from industrial equipment.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Sensor data matrix\nA = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [1.0, 1.1, 1.2]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\nA_reconstructed = np.dot(A_svd, svd.components_)\n\n# Compute reconstruction error\nreconstruction_error = np.linalg.norm(A - A_reconstructed, 'fro')\nprint('Reconstruction error:', reconstruction_error)"
  },
  {
    "input": "Use SVD to perform image compression on a grayscale image.",
    "output": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.decomposition import TruncatedSVD\nfrom sklearn.datasets import load_sample_image\n\n# Load image\nchina = load_sample_image('china.jpg')\nimage = china[:, :, 0]  # Grayscale\nimage = image / 255.0\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=50, random_state=42)\nimage_svd = svd.fit_transform(image)\nimage_reconstructed = np.dot(image_svd, svd.components_)\n\n# Display original and compressed images\nfig, axes = plt.subplots(1, 2, figsize=(10, 5))\naxes[0].imshow(image, cmap='gray')\naxes[0].set_title('Original Image')\naxes[1].imshow(image_reconstructed, cmap='gray')\naxes[1].set_title('Compressed Image')\nplt.show()"
  },
  {
    "input": "Apply SVD to reduce noise in a speech signal represented as a matrix of audio features.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Simulated speech signal matrix\nA = np.random.rand(100, 50)  # 100 time frames, 50 features\n\n# Add noise\nnoise = 0.1 * np.random.randn(100, 50)\nA_noisy = A + noise\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=30, random_state=42)\nA_svd = svd.fit_transform(A_noisy)\nA_denoised = np.dot(A_svd, svd.components_)\n\n# Display original and denoised signals\nimport matplotlib.pyplot as plt\nplt.plot(A[0, :], label='Original')\nplt.plot(A_denoised[0, :], label='Denoised')\nplt.legend()\nplt.show()"
  },
  {
    "input": "Use SVD to extract principal components from a dataset of gene expression levels.",
    "output": "import numpy as np\nfrom sklearn.decomposition import PCA\n\n# Simulated gene expression data (samples x genes)\nX = np.random.rand(100, 500)  # 100 samples, 500 genes\n\n# Apply PCA (SVD-based)\npca = PCA(n_components=50, random_state=42)\nX_pca = pca.fit_transform(X)\n\n# Display explained variance ratio\nprint('Explained variance ratio of first 50 components:', np.sum(pca.explained_variance_ratio_))"
  },
  {
    "input": "Apply SVD to identify latent semantic structures in a term-document matrix from a text corpus.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\nfrom sklearn.feature_extraction.text import TfidfVectorizer\n\n# Sample text corpus\ncorpus = ['Text mining is fun.', 'SVD is useful for dimensionality reduction.', 'Natural language processing with Python.']\n\n# Convert to TF-IDF matrix\nvectorizer = TfidfVectorizer(stop_words='english')\nX = vectorizer.fit_transform(corpus)\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nX_svd = svd.fit_transform(X)\n\n# Display terms associated with each component\nterms = vectorizer.get_feature_names_out()\nfor i, topic in enumerate(svd.components_):\n    print(f'Topic {i}:')\n    print([terms[j] for j in topic.argsort()[-3:]])"
  },
  {
    "input": "Use SVD to approximate a low-rank solution to an underdetermined linear system.",
    "output": "import numpy as np\n\n# Underdetermined system (more variables than equations)\nA = np.array([[1, 2], [3, 4], [5, 6]])  # 3x2 matrix\nb = np.array([1, 2, 3])  # 3x1 vector\n\n# Apply SVD\nU, S, Vt = np.linalg.svd(A, full_matrices=False)\nA_plus = np.dot(Vt.T, np.dot(np.diag(1/S), U.T))  # Pseudo-inverse\nx = np.dot(A_plus, b)\n\nprint('Solution to the linear system:', x)"
  },
  {
    "input": "Given a matrix of product reviews, use SVD to extract features that influence the overall sentiment of the reviews.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Product review matrix\nA = np.array([[5, 4, 2], [3, 2, 1], [4, 5, 3], [2, 3, 1]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\n\n# Extract influential features\nfeatures = svd.components_\nprint('Influential features:', features)"
  },
  {
    "input": "Use SVD to determine the underlying factors driving customer preferences in an online shopping dataset.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Online shopping customer data\nA = np.array([[5, 3, 4], [2, 4, 5], [3, 2, 4], [1, 5, 4]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\n\n# Display underlying factors\nfactors = svd.components_\nprint('Underlying factors driving preferences:', factors)"
  },
  {
    "input": "Apply SVD to analyze consumer preferences for various product categories based on transaction data.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Transaction data matrix (users x products)\nA = np.array([[5, 3, 2], [4, 5, 3], [3, 4, 2], [2, 1, 4]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\n\n# Identify product preference trends\nproduct_trends = svd.components_\nprint('Consumer preferences for product categories:', product_trends)"
  },
  {
    "input": "Use SVD to extract principal components from a social media dataset and identify latent factors affecting user engagement.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Social media engagement matrix\nA = np.array([[10, 5, 3], [4, 8, 2], [6, 3, 7], [8, 5, 6]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\n\n# Identify latent factors\nlatent_factors = svd.components_\nprint('Latent factors affecting engagement:', latent_factors)"
  },
  {
    "input": "Given a matrix of traffic data, use SVD to identify traffic flow patterns and predict future congestion.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Traffic flow data matrix\nA = np.array([[10, 15], [20, 25], [30, 35], [40, 45]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\n\n# Identify traffic flow patterns\nflow_patterns = svd.components_\nprint('Traffic flow patterns:', flow_patterns)"
  },
  {
    "input": "Use SVD to analyze a dataset of environmental variables and identify the factors contributing to climate change.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Environmental data matrix\nA = np.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6], [0.7, 0.8]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\n\n# Identify factors contributing to climate change\nclimate_factors = svd.components_\nprint('Factors contributing to climate change:', climate_factors)"
  },
  {
    "input": "Given a matrix of customer purchase history, use SVD to segment customers based on their shopping patterns.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Customer purchase history matrix\nA = np.array([[5, 3, 4], [2, 1, 5], [4, 3, 2], [1, 5, 4]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\n\n# Segment customers based on shopping patterns\ncustomer_segments = A_svd\nprint('Customer segments based on shopping patterns:', customer_segments)"
  },
  {
    "input": "Use SVD to process a dataset of movie ratings and recommend top movies to a user based on their preferences.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Movie rating matrix\nR = np.array([[5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [1, 0, 0, 4], [0, 1, 5, 4]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nR_svd = svd.fit_transform(R)\nR_reconstructed = np.dot(R_svd, svd.components_)\n\n# Recommend top movies to the user\nrecommended_movies = R_reconstructed[0]\nprint('Recommended movies:', recommended_movies)"
  },
  {
    "input": "Given a matrix of academic performance data, use SVD to identify key factors influencing student success.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Academic performance matrix\nA = np.array([[80, 90, 85], [70, 75, 80], [85, 95, 90], [65, 70, 60]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\n\n# Identify key factors\nkey_factors = svd.components_\nprint('Key factors influencing student success:', key_factors)"
  },
  {
    "input": "Use SVD to analyze a dataset of customer service interactions and identify the main drivers of customer satisfaction.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Customer service interaction matrix\nA = np.array([[5, 4, 3], [3, 5, 4], [4, 2, 5], [2, 4, 3]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\n\n# Identify drivers of satisfaction\nsatisfaction_drivers = svd.components_\nprint('Drivers of customer satisfaction:', satisfaction_drivers)"
  },
  {
    "input": "Apply SVD to extract factors from a matrix of political opinions to identify underlying voting trends.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Political opinion matrix\nA = np.array([[5, 3, 2], [4, 5, 3], [3, 4, 2], [2, 1, 4]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\n\n# Extract voting trends\nvoting_trends = svd.components_\nprint('Underlying voting trends:', voting_trends)"
  },
  {
    "input": "Use SVD to identify latent factors from a dataset of patient symptoms and help in the diagnosis of diseases.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Patient symptom matrix\nA = np.array([[5, 3, 2], [4, 5, 3], [3, 4, 2], [2, 1, 4]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\n\n# Identify latent factors influencing diagnosis\nlatent_factors = svd.components_\nprint('Latent factors influencing diagnosis:', latent_factors)"
  },
  {
    "input": "Given a dataset of financial transactions, apply SVD to identify fraudulent activity based on transaction patterns.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\n# Financial transaction matrix\nA = np.array([[100, 200], [150, 250], [200, 300], [50, 100]])\n\n# Apply SVD\nsvd = TruncatedSVD(n_components=2, random_state=42)\nA_svd = svd.fit_transform(A)\nA_reconstructed = np.dot(A_svd, svd.components_)\n\n# Detect fraudulent transactions based on reconstruction error\nfraudulent_transactions = A - A_reconstructed\nprint('Fraudulent transactions detected:', fraudulent_transactions)"
  },
  {
    "input": "Decompose the matrix A = [[9, 6], [3, 4]] using Singular Value Decomposition and display all three matrices U, \u00ce\u00a3, and V^T.",
    "output": "import numpy as np\n\nA = np.array([[9, 6], [3, 4]])\nU, S, Vt = np.linalg.svd(A)\nprint(\"U =\", U)\nprint(\"S =\", S)\nprint(\"V^T =\", Vt)"
  },
  {
    "input": "Find the smallest singular value of matrix A = [[1, 0, 0], [0, 1, 0], [0, 0, 0.001]].",
    "output": "import numpy as np\n\nA = np.diag([1, 1, 0.001])\nU, S, Vt = np.linalg.svd(A)\nprint(\"Smallest singular value:\", S[-1])"
  },
  {
    "input": "You are given a matrix of movie ratings by users: A = [[4, 5], [5, 3], [1, 2]]. Reduce its dimensionality using SVD to 1 component.",
    "output": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD\n\nA = np.array([[4, 5], [5, 3], [1, 2]])\nsvd = TruncatedSVD(n_components=1)\nA_reduced = svd.fit_transform(A)\nprint(\"Reduced matrix:\", A_reduced)"
  },
  {
    "input": "Given A = [[2, 3], [4, 5], [6, 7]], compute the Frobenius norm using its singular values.",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [4, 5], [6, 7]])\nU, S, Vt = np.linalg.svd(A)\nfrobenius_norm = np.sqrt(np.sum(S**2))\nprint(\"Frobenius norm:\", frobenius_norm)"
  },
  {
    "input": "Reconstruct the matrix A = [[5, 2], [1, 0]] using SVD components. Show your reconstruction.",
    "output": "import numpy as np\n\nA = np.array([[5, 2], [1, 0]])\nU, S, Vt = np.linalg.svd(A)\nS_full = np.zeros_like(A, dtype=float)\nnp.fill_diagonal(S_full, S)\nA_reconstructed = U @ S_full @ Vt\nprint(\"Reconstructed A:\", A_reconstructed)"
  },
  {
    "input": "Use SVD to calculate the rank of A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint(\"Rank:\", rank)"
  },
  {
    "input": "You are compressing an image stored as a 10x10 matrix. Use SVD to create a rank-2 approximation.",
    "output": "import numpy as np\n\nA = np.random.rand(10, 10)\nU, S, Vt = np.linalg.svd(A)\nS[2:] = 0\nA_approx = U @ np.diag(S) @ Vt\nprint(\"Rank-2 approximation:\\n\", A_approx)"
  },
  {
    "input": "A = [[7, 1], [2, 9]]. Compute the pseudoinverse of A using SVD.",
    "output": "import numpy as np\n\nA = np.array([[7, 1], [2, 9]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nprint(\"Pseudoinverse:\\n\", A_pinv)"
  },
  {
    "input": "You are working with a 3x2 matrix A = [[1, 0], [0, 1], [1, 1]]. Calculate its condition number using SVD.",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [0, 1], [1, 1]])\nU, S, Vt = np.linalg.svd(A)\ncondition_number = S[0] / S[-1]\nprint(\"Condition number:\", condition_number)"
  },
  {
    "input": "Find the nuclear norm of matrix A = [[3, 1], [1, 3]].",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [1, 3]])\nU, S, Vt = np.linalg.svd(A)\nnuclear_norm = np.sum(S)\nprint(\"Nuclear norm:\", nuclear_norm)"
  },
  {
    "input": "Let A be the 3x3 identity matrix. What are its singular values?",
    "output": "import numpy as np\n\nA = np.eye(3)\n_, S, _ = np.linalg.svd(A)\nprint(\"Singular values:\", S)"
  },
  {
    "input": "A scientist has recorded 2D sensor data as a matrix. Use SVD to remove noise by keeping only the top singular value of A = [[0.9, 0.1], [0.1, 0.8]].",
    "output": "import numpy as np\n\nA = np.array([[0.9, 0.1], [0.1, 0.8]])\nU, S, Vt = np.linalg.svd(A)\nS[1:] = 0\nA_denoised = U @ np.diag(S) @ Vt\nprint(\"Denoised matrix:\", A_denoised)"
  },
  {
    "input": "Using SVD, compress the following 5x5 matrix by keeping only 2 singular values. A = np.arange(25).reshape(5,5)",
    "output": "import numpy as np\n\nA = np.arange(25).reshape(5,5)\nU, S, Vt = np.linalg.svd(A)\nS[2:] = 0\nA_compressed = U @ np.diag(S) @ Vt\nprint(\"Compressed matrix:\\n\", A_compressed)"
  },
  {
    "input": "For matrix A = [[3, 4], [0, 0], [5, 12]], compute its singular values and print them.",
    "output": "import numpy as np\n\nA = np.array([[3, 4], [0, 0], [5, 12]])\n_, S, _ = np.linalg.svd(A)\nprint(\"Singular values:\", S)"
  },
  {
    "input": "Given a large sparse matrix of shape (1000, 1000), how would you use SVD to reduce its dimensionality efficiently in Python?",
    "output": "from scipy.sparse import random\nfrom sklearn.decomposition import TruncatedSVD\n\nA = random(1000, 1000, density=0.01, format='csr')\nsvd = TruncatedSVD(n_components=50)\nA_reduced = svd.fit_transform(A)\nprint(\"Reduced shape:\", A_reduced.shape)"
  },
  {
    "input": "What is the effect of zeroing out the smallest singular value in SVD? Try with A = [[1, 2], [3, 4]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A)\nS[-1] = 0\nA_modified = U @ np.diag(S) @ Vt\nprint(\"Modified A:\\n\", A_modified)"
  },
  {
    "input": "You are given A = [[10, 0], [0, 1]]. Perform SVD and print all outputs.",
    "output": "import numpy as np\n\nA = np.array([[10, 0], [0, 1]])\nU, S, Vt = np.linalg.svd(A)\nprint(\"U:\\n\", U)\nprint(\"S:\\n\", S)\nprint(\"Vt:\\n\", Vt)"
  },
  {
    "input": "Construct a rank-1 approximation of matrix A = [[1, 2], [3, 4], [5, 6]] using SVD.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(A)\n# Keep only the top singular value\nrank_1 = U[:, :1] @ np.diag(S[:1]) @ Vt[:1, :]\nprint(\"Rank-1 approximation:\\n\", rank_1)"
  },
  {
    "input": "Given a data matrix A = [[2, 3], [4, 6], [6, 9]], detect rank deficiency using SVD.",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [4, 6], [6, 9]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint(\"Rank:\", rank)"
  },
  {
    "input": "You are solving Ax = b where A = [[1, 2], [3, 4], [5, 6]] and b = [1, 2, 3]. Use SVD-based pseudoinverse to find x.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nb = np.array([1, 2, 3])\n\nU, S, Vt = np.linalg.svd(A)\n# Invert only non-zero singular values\nS_inv = np.zeros((Vt.shape[0], U.shape[0]))\nfor i in range(len(S)):\n    S_inv[i, i] = 1 / S[i]\n\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(\"x =\", x)"
  },
  {
    "input": "From matrix A = [[2, 0], [0, 1]], extract U only using SVD.",
    "output": "import numpy as np\n\nA = np.array([[2, 0], [0, 1]])\nU, _, _ = np.linalg.svd(A)\nprint(\"U =\", U)"
  },
  {
    "input": "Find how many singular values of A = [[4, 4], [4, 4]] are non-zero.",
    "output": "import numpy as np\n\nA = np.array([[4, 4], [4, 4]])\n_, S, _ = np.linalg.svd(A)\nprint(\"Non-zero count:\", np.sum(S > 1e-10))"
  },
  {
    "input": "Use SVD to orthonormalize the columns of A = [[1, 1], [1, -1]].",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [1, -1]])\nU, _, _ = np.linalg.svd(A)\nprint(\"Orthonormal basis (columns of U):\\n\", U)"
  },
  {
    "input": "A researcher stores image data as a matrix A = [[255, 0], [0, 255]]. Use SVD to perform a low-rank approximation and display the result.",
    "output": "import numpy as np\n\nA = np.array([[255, 0], [0, 255]])\nU, S, Vt = np.linalg.svd(A)\nS[1] = 0\nA_low_rank = U @ np.diag(S) @ Vt\nprint(\"Low-rank approximation:\\n\", A_low_rank)"
  },
  {
    "input": "Compute the SVD of matrix A = [[7, 2], [3, 4]] and print U only.",
    "output": "import numpy as np\n\nA = np.array([[7, 2], [3, 4]])\nU, _, _ = np.linalg.svd(A)\nprint(\"U =\", U)"
  },
  {
    "input": "Given matrix A = [[5, 6], [7, 8]], find the values of V^T using SVD.",
    "output": "import numpy as np\n\nA = np.array([[5, 6], [7, 8]])\n_, _, Vt = np.linalg.svd(A)\nprint(\"V^T =\", Vt)"
  },
  {
    "input": "Let A be a 4x3 matrix with linearly dependent columns. Check its rank using SVD. Use A = [[1, 2, 3], [2, 4, 6], [3, 6, 9], [4, 8, 12]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [2, 4, 6], [3, 6, 9], [4, 8, 12]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint(\"Rank:\", rank)"
  },
  {
    "input": "Matrix A = [[10, 5], [7, 3]]. Find its SVD and reconstruct the matrix using all components.",
    "output": "import numpy as np\n\nA = np.array([[10, 5], [7, 3]])\nU, S, Vt = np.linalg.svd(A)\nS_full = np.zeros_like(A, dtype=float)\nnp.fill_diagonal(S_full, S)\nA_reconstructed = U @ S_full @ Vt\nprint(\"Reconstructed A:\\n\", A_reconstructed)"
  },
  {
    "input": "Your data matrix A = [[3, 1], [1, 3]]. Use SVD to compute its eigenvalues approximately.",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [1, 3]])\nU, S, Vt = np.linalg.svd(A)\neigenvalues = S**2\nprint(\"Approximate eigenvalues:\", eigenvalues)"
  },
  {
    "input": "Given A = [[4, 0], [3, 0]], perform SVD and explain whether the second singular value is zero.",
    "output": "import numpy as np\n\nA = np.array([[4, 0], [3, 0]])\n_, S, _ = np.linalg.svd(A)\nprint(\"Singular values:\", S, \"\\nSecond singular value zero:\", S[1] < 1e-10)"
  },
  {
    "input": "You're solving a system of equations with more equations than unknowns. Use SVD to find the least-squares solution to Ax = b where A = [[1, 2], [3, 4], [5, 6]], b = [1, 2, 3].",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4], [5, 6]])\nb = np.array([1, 2, 3])\n\nU, S, Vt = np.linalg.svd(A)\n# Create S+ (pseudoinverse of S)\nS_inv = np.zeros((Vt.shape[0], U.shape[0]))\nfor i in range(len(S)):\n    S_inv[i, i] = 1 / S[i]\n\n# Compute pseudoinverse of A\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(\"Least-squares solution:\", x)"
  },
  {
    "input": "Using matrix A = [[1, 0], [0, 100]], demonstrate why the condition number is high.",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [0, 100]])\n_, S, _ = np.linalg.svd(A)\ncondition = S[0] / S[-1]\nprint(\"Condition number:\", condition)"
  },
  {
    "input": "Create a matrix with one very small singular value by modifying [[1, 2], [2, 4.0001]] and print all singular values.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 4.0001]])\n_, S, _ = np.linalg.svd(A)\nprint(\"Singular values:\", S)"
  },
  {
    "input": "You need to compress a grayscale image represented by a 20x20 matrix. Use SVD to keep top 3 singular values.",
    "output": "import numpy as np\n\nnp.random.seed(0)\nA = np.random.randint(0, 256, size=(20, 20))\nU, S, Vt = np.linalg.svd(A)\nS[3:] = 0\nA_compressed = U @ np.diag(S) @ Vt\nprint(\"Compressed matrix shape:\", A_compressed.shape)"
  },
  {
    "input": "Using TruncatedSVD, reduce the dimensionality of A = [[5, 2, 1], [3, 7, 6], [1, 1, 1]] to 2 features.",
    "output": "from sklearn.decomposition import TruncatedSVD\nimport numpy as np\n\nA = np.array([[5, 2, 1], [3, 7, 6], [1, 1, 1]])\nsvd = TruncatedSVD(n_components=2)\nA_reduced = svd.fit_transform(A)\nprint(\"Reduced matrix:\\n\", A_reduced)"
  },
  {
    "input": "True or False: The singular values of a symmetric matrix are always equal to the absolute values of its eigenvalues? Use A = [[2, -1], [-1, 2]] to verify.",
    "output": "import numpy as np\n\nA = np.array([[2, -1], [-1, 2]])\neigs = np.linalg.eigvals(A)\n_, S, _ = np.linalg.svd(A)\nprint(\"Eigenvalues:\", eigs)\nprint(\"Singular values:\", S)"
  },
  {
    "input": "Word Problem: A tech startup has user click data represented as matrix A = [[5, 3], [2, 2], [1, 0]]. They want to find dominant patterns. Use SVD to extract top singular value.",
    "output": "import numpy as np\n\nA = np.array([[5, 3], [2, 2], [1, 0]])\n_, S, _ = np.linalg.svd(A)\nprint(\"Top singular value:\", S[0])"
  },
  {
    "input": "In a physics simulation, the matrix A = [[0, -1], [1, 0]] represents rotation. Find its SVD and print V^T.",
    "output": "import numpy as np\n\nA = np.array([[0, -1], [1, 0]])\n_, _, Vt = np.linalg.svd(A)\nprint(\"V^T =\", Vt)"
  },
  {
    "input": "Use SVD to compute the Moore-Penrose pseudoinverse of A = [[1, 2], [3, 4]]. Verify by multiplying with A.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.diag(1/S)\nA_pinv = Vt.T @ S_inv @ U.T\nproduct = A @ A_pinv @ A\nprint(\"A * A+ * A =\\n\", product)"
  },
  {
    "input": "Given A = [[8, 6], [9, 7], [2, 1]], find the number of non-zero singular values.",
    "output": "import numpy as np\n\nA = np.array([[8, 6], [9, 7], [2, 1]])\n_, S, _ = np.linalg.svd(A)\ncount = np.sum(S > 1e-10)\nprint(\"Non-zero singular values:\", count)"
  },
  {
    "input": "Decompose matrix A = [[1, 2], [3, 4]] using SVD and manually verify reconstruction from U, S, V^T.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A)\nS_mat = np.zeros((2,2))\nnp.fill_diagonal(S_mat, S)\nA_reconstructed = U @ S_mat @ Vt\nprint(\"Reconstructed A:\\n\", A_reconstructed)"
  },
  {
    "input": "Your system logs store a time-series matrix with anomalies. Use SVD to isolate principal components of A = np.random.rand(10, 3).",
    "output": "import numpy as np\n\nA = np.random.rand(10, 3)\nU, S, Vt = np.linalg.svd(A)\nprint(\"Principal components (first column of U):\\n\", U[:, 0])"
  },
  {
    "input": "Estimate the numerical rank of A = [[1, 2], [2, 4.00001]] using singular values.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 4.00001]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint(\"Estimated rank:\", rank)"
  },
  {
    "input": "Let A = [[1, 1, 1], [1, 1, 1]]. Perform SVD and check how many non-zero singular values exist.",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 1], [1, 1, 1]])\n_, S, _ = np.linalg.svd(A)\nprint(\"Non-zero singular values:\", np.sum(S > 1e-10))"
  },
  {
    "input": "You're analyzing A = [[4, 2], [2, 1]]. Is it full rank? Use SVD.",
    "output": "import numpy as np\n\nA = np.array([[4, 2], [2, 1]])\n_, S, _ = np.linalg.svd(A)\nprint(\"Rank:\", np.sum(S > 1e-10))"
  },
  {
    "input": "Use SVD to find a basis for the column space of A = [[1, 0], [1, 1], [1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [1, 1], [1, 2]])\nU, S, _ = np.linalg.svd(A)\nbasis = U[:, :np.sum(S > 1e-10)]\nprint(\"Column space basis:\\n\", basis)"
  },
  {
    "input": "Let A = [[1, 0], [0, -1]]. Show that the singular values of A differ from its eigenvalues and explain why.",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [0, -1]])\neigvals = np.linalg.eigvals(A)\n_, S, _ = np.linalg.svd(A)\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Singular values:\", S)"
  },
  {
    "input": "Matrix A = [[1, 2, 3], [4, 5, 6]] is rank-deficient. Use SVD to verify its rank and reconstruct A using only non-zero singular values.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [4, 5, 6]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nA_reconstructed = U[:, :rank] @ np.diag(S[:rank]) @ Vt[:rank, :]\nprint(\"Rank:\", rank)\nprint(\"Reconstructed A:\\n\", A_reconstructed)"
  },
  {
    "input": "What happens to the SVD of a matrix with a repeated row? Let A = [[2, 3], [2, 3]].",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [2, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint(\"Singular values:\", S)\nprint(\"U:\\n\", U)"
  },
  {
    "input": "Matrix A = [[2, 2], [2, 2]] has rank 1. Use SVD to confirm and find its dominant direction.",
    "output": "import numpy as np\n\nA = np.array([[2, 2], [2, 2]])\nU, S, Vt = np.linalg.svd(A)\ndominant_direction = Vt[0]\nprint(\"Rank:\", np.sum(S > 1e-10))\nprint(\"Dominant direction:\", dominant_direction)"
  },
  {
    "input": "Use SVD to compute the pseudoinverse of a rank-deficient matrix A = [[1, 2], [2, 4]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 4]])\nU, S, Vt = np.linalg.svd(A)\nS_inv = np.zeros((2,2))\nfor i in range(len(S)):\n    if S[i] > 1e-10:\n        S_inv[i, i] = 1/S[i]\nA_pinv = Vt.T @ S_inv @ U.T\nprint(\"Pseudoinverse:\\n\", A_pinv)"
  },
  {
    "input": "True or False: The SVD of a matrix is unique? Test this using A = [[0, 1], [1, 0]].",
    "output": "import numpy as np\n\nA = np.array([[0, 1], [1, 0]])\nU1, S1, Vt1 = np.linalg.svd(A)\nU2, S2, Vt2 = np.linalg.svd(-A)\nprint(\"First U:\\n\", U1)\nprint(\"Second U (for -A):\\n\", U2)"
  },
  {
    "input": "Consider matrix A = [[1, 0, 0], [0, 2, 0], [0, 0, 0.0001]]. Show the sensitivity of its SVD by adding noise.",
    "output": "import numpy as np\n\nA = np.diag([1, 2, 0.0001])\nA_noisy = A + np.random.normal(0, 1e-4, A.shape)\n_, S, _ = np.linalg.svd(A_noisy)\nprint(\"Singular values of noisy A:\", S)"
  },
  {
    "input": "Let A = [[1, 2], [3, 4]]. Show that the sum of squares of singular values equals sum of squares of all elements in A.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4]])\n_, S, _ = np.linalg.svd(A)\nsum_squares_A = np.sum(A**2)\nsum_squares_S = np.sum(S**2)\nprint(\"Matrix sum of squares:\", sum_squares_A)\nprint(\"SVD sum of squares:\", sum_squares_S)"
  },
  {
    "input": "Matrix A = [[1, 2, 3], [4, 5, 6]]. Compute SVD and determine which singular values to retain for 90% energy.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [4, 5, 6]])\n_, S, _ = np.linalg.svd(A)\nenergy = np.cumsum(S**2) / np.sum(S**2)\nn = np.searchsorted(energy, 0.9) + 1\nprint(\"Number of singular values to retain:\", n)"
  },
  {
    "input": "Test SVD on an identity matrix A = np.eye(5). What do you expect the U and V^T matrices to look like?",
    "output": "import numpy as np\n\nA = np.eye(5)\nU, S, Vt = np.linalg.svd(A)\nprint(\"U =\\n\", U)\nprint(\"V^T =\\n\", Vt)"
  },
  {
    "input": "Apply SVD on a matrix of all ones: A = np.ones((3, 3)). What do the singular values tell you?",
    "output": "import numpy as np\n\nA = np.ones((3, 3))\n_, S, _ = np.linalg.svd(A)\nprint(\"Singular values:\", S)"
  },
  {
    "input": "Perform SVD on a skew-symmetric matrix A = [[0, -2], [2, 0]].",
    "output": "import numpy as np\n\nA = np.array([[0, -2], [2, 0]])\nU, S, Vt = np.linalg.svd(A)\nprint(\"SVD of skew-symmetric A:\\nU=\", U, \"\\nS=\", S, \"\\nV^T=\", Vt)"
  },
  {
    "input": "Let A = [[1, 1], [1, 1+1e-10]]. Check if SVD detects full rank.",
    "output": "import numpy as np\n\nA = np.array([[1, 1], [1, 1+1e-10]])\n_, S, _ = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint(\"Estimated rank:\", rank)"
  },
  {
    "input": "A = [[1, 2], [2, 4.000001]]. Try SVD and inspect how condition number behaves.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 4.000001]])\n_, S, _ = np.linalg.svd(A)\ncond = S[0] / S[-1]\nprint(\"Condition number:\", cond)"
  },
  {
    "input": "Use SVD to project a 3D point onto the best-fit 2D subspace using A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nU, S, Vt = np.linalg.svd(A)\nproj = A @ Vt[:2, :].T @ Vt[:2, :]\nprint(\"Projected points:\\n\", proj)"
  },
  {
    "input": "Perform dimensionality reduction with SVD on data matrix A = np.random.rand(50, 10) to retain 95% variance.",
    "output": "import numpy as np\n\nA = np.random.rand(50, 10)\n_, S, _ = np.linalg.svd(A)\nenergy = np.cumsum(S**2) / np.sum(S**2)\nk = np.searchsorted(energy, 0.95) + 1\nprint(\"Dimensions to retain 95% variance:\", k)"
  },
  {
    "input": "Is the SVD of A = [[1, 0], [0, 0]] the same as that of A.T? Check and compare.",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [0, 0]])\n_, S1, _ = np.linalg.svd(A)\n_, S2, _ = np.linalg.svd(A.T)\nprint(\"SVD of A:\", S1)\nprint(\"SVD of A^T:\", S2)"
  },
  {
    "input": "Check how SVD handles a matrix with one non-zero entry: A = [[0, 0], [0, 7]].",
    "output": "import numpy as np\n\nA = np.array([[0, 0], [0, 7]])\nU, S, Vt = np.linalg.svd(A)\nprint(\"SVD:\\nU=\", U, \"\\nS=\", S, \"\\nV^T=\", Vt)"
  },
  {
    "input": "Use SVD to solve the underdetermined system A = [[1, 2, 3]], b = [1].",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3]])\nb = np.array([1])\n\nU, S, Vt = np.linalg.svd(A)\n\n# Build the pseudoinverse of A manually\nS_inv = np.zeros((Vt.shape[0], U.shape[0]))\nfor i in range(len(S)):\n    S_inv[i, i] = 1 / S[i]\n\nA_pinv = Vt.T @ S_inv @ U.T\nx = A_pinv @ b\nprint(\"Least-norm solution:\", x)"
  },
  {
    "input": "Let A = [[1, 2], [2, 1]]. Show that the SVD gives orthogonal U and V^T.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 1]])\nU, _, Vt = np.linalg.svd(A)\nprint(\"U^T U =\\n\", U.T @ U)\nprint(\"V^T V =\\n\", Vt @ Vt.T)"
  },
  {
    "input": "Use SVD to find a rank-1 approximation of matrix A = [[1, 2], [3, 4]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A)\nA_approx = U[:, 0:1] @ np.diag(S[:1]) @ Vt[:1, :]\nprint(\"Rank-1 approximation:\\n\", A_approx)"
  },
  {
    "input": "What happens to SVD when all matrix values are tiny? Use A = [[1e-10, 0], [0, 1e-10]].",
    "output": "import numpy as np\n\nA = np.array([[1e-10, 0], [0, 1e-10]])\n_, S, _ = np.linalg.svd(A)\nprint(\"Singular values:\", S)"
  },
  {
    "input": "Decompose A = [[3, -1], [-1, 3]] via SVD and verify reconstruction.",
    "output": "import numpy as np\n\nA = np.array([[3, -1], [-1, 3]])\nU, S, Vt = np.linalg.svd(A)\nA_rec = U @ np.diag(S) @ Vt\nprint(\"Reconstructed A:\\n\", A_rec)"
  },
  {
    "input": "Explore SVD of Hilbert matrix A = [[1, 1/2], [1/2, 1/3]].",
    "output": "import numpy as np\n\nA = np.array([[1, 1/2], [1/2, 1/3]])\nU, S, Vt = np.linalg.svd(A)\nprint(\"Singular values:\", S)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of the matrix A = [[2, 0], [0, 3]].",
    "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Determine if the matrix B = [[4, 1], [2, 3]] is diagonalizable.",
    "output": "import numpy as np\nB = np.array([[4, 1], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(B)\nif np.linalg.matrix_rank(eigenvectors) == B.shape[0]:\n    print('Matrix B is diagonalizable.')\nelse:\n    print('Matrix B is not diagonalizable.')"
  },
  {
    "input": "Compute the diagonal form D and the matrix P such that P^(-1) * C * P = D for C = [[5, 4], [1, 2]].",
    "output": "import numpy as np\nC = np.array([[5, 4], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(C)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)\nprint('Verification (P_inv * C * P):\\n', np.dot(P_inv, np.dot(C, P)))"
  },
  {
    "input": "Find the spectral decomposition of the matrix D = [[3, 0], [0, -1]].",
    "output": "import numpy as np\nD = np.array([[3, 0], [0, -1]])\neigenvalues, eigenvectors = np.linalg.eig(D)\nP = eigenvectors\nD_diag = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nprint('Spectral decomposition: P * D_diag * P_inv =\\n', np.dot(P, np.dot(D_diag, P_inv)))"
  },
  {
    "input": "Check if the matrix E = [[2, -1], [-1, 2]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nE = np.array([[2, -1], [-1, 2]])\nif np.allclose(E, E.T):\n    print('Matrix E is symmetric.')\n    eigenvalues, _ = np.linalg.eig(E)\n    print('Eigenvalues:', eigenvalues)\nelse:\n    print('Matrix E is not symmetric.')"
  },
  {
    "input": "For the matrix F = [[1, 2], [2, 1]], find an orthogonal matrix P that diagonalizes it.",
    "output": "import numpy as np\nF = np.array([[1, 2], [2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(F)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nprint('Orthogonal matrix P:\\n', P)\nprint('Diagonal matrix D:\\n', D)\nprint('Verification (P_inv * F * P):\\n', np.dot(P_inv, np.dot(F, P)))"
  },
  {
    "input": "Determine the eigenvalues of the matrix G = [[0, -1], [1, 0]].",
    "output": "import numpy as np\nG = np.array([[0, -1], [1, 0]])\neigenvalues, _ = np.linalg.eig(G)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors corresponding to the eigenvalue 3 of the matrix H = [[3, 1], [0, 3]].",
    "output": "import numpy as np\nH = np.array([[3, 1], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(H)\neigenvalue = 3\nindices = np.where(np.isclose(eigenvalues, eigenvalue))[0]\ncorresponding_eigenvectors = eigenvectors[:, indices]\nprint('Eigenvectors corresponding to eigenvalue 3:\\n', corresponding_eigenvectors)"
  },
  {
    "input": "Verify if the matrix I = [[2, 1], [1, 2]] can be diagonalized by an orthogonal matrix.",
    "output": "import numpy as np\nI = np.array([[2, 1], [1, 2]])\nif np.allclose(I, I.T):\n    eigenvalues, eigenvectors = np.linalg.eig(I)\n    if np.allclose(eigenvectors.T @ eigenvectors, np.eye(I.shape[0])):\n        print('Matrix I can be diagonalized by an orthogonal matrix.')\n    else:\n        print('Matrix I cannot be diagonalized by an orthogonal matrix.')\nelse:\n    print('Matrix I is not symmetric and thus cannot be diagonalized by an orthogonal matrix.')"
  },
  {
    "input": "Compute the diagonalization of the matrix J = [[4, 0], [0, 1]].",
    "output": "import numpy as np\nJ = np.array([[4, 0], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(J)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)\nprint('Verification (P_inv * J * P):\\n', np.dot(P_inv, np.dot(J, P)))"
  },
  {
    "input": "Find the eigenvalues of the 2x2 matrix [[1, 0], [0, 2]].",
    "output": "import numpy as np\nA = np.array([[1, 0], [0, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Check if the matrix [[6, 0], [0, 6]] is diagonal and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[6, 0], [0, 6]])\neigenvalues = np.linalg.eigvals(A)\nprint('Matrix is diagonal:', np.allclose(A, np.diag(np.diag(A))))\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Determine if the matrix [[2, 0], [0, -2]] is orthogonally diagonalizable.",
    "output": "import numpy as np\nA = np.array([[2, 0], [0, -2]])\nif np.allclose(A, A.T):\n    print('Matrix is symmetric and hence orthogonally diagonalizable.')\nelse:\n    print('Matrix is not symmetric.')"
  },
  {
    "input": "Find the eigenvectors of the matrix [[3, 0], [0, 5]].",
    "output": "import numpy as np\nA = np.array([[3, 0], [0, 5]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the eigenvalues of the identity matrix I = [[1, 0], [0, 1]].",
    "output": "import numpy as np\nI = np.eye(2)\neigenvalues = np.linalg.eigvals(I)\nprint('Eigenvalues of identity matrix:', eigenvalues)"
  },
  {
    "input": "Diagonalize the matrix [[7, 0], [0, 2]].",
    "output": "import numpy as np\nA = np.array([[7, 0], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[0, 2], [2, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Check if matrix [[5, 1], [1, 5]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[5, 1], [1, 5]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvalues of a 2x2 zero matrix.",
    "output": "import numpy as np\nZ = np.zeros((2, 2))\neigenvalues = np.linalg.eigvals(Z)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "For matrix [[9, 0], [0, 4]], find P and D such that A = P D P^(-1).",
    "output": "import numpy as np\nA = np.array([[9, 0], [0, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nprint('Matrix P:\\n', P)\nprint('Diagonal matrix D:\\n', D)"
  },
  {
    "input": "Check whether the matrix [[1, 2], [2, 1]] can be orthogonally diagonalized.",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the trace and determinant of the matrix [[2, 0], [0, 3]] and verify with sum and product of eigenvalues.",
    "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\neigenvalues = np.linalg.eigvals(A)\ntrace = np.trace(A)\ndet = np.linalg.det(A)\nprint('Trace:', trace, 'Sum of eigenvalues:', sum(eigenvalues))\nprint('Determinant:', det, 'Product of eigenvalues:', np.prod(eigenvalues))"
  },
  {
    "input": "Find eigenvalues and eigenvectors of matrix [[0, 1], [-1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Given matrix [[3, 0], [0, 3]], show it has repeated eigenvalues and independent eigenvectors.",
    "output": "import numpy as np\nA = np.array([[3, 0], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)\nprint('Linearly independent eigenvectors:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the orthonormal eigenvectors of matrix [[2, 0], [0, 3]].",
    "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[2, 0], [0, 3]])\n_, eigenvectors = np.linalg.eig(A)\northonormal_vectors = [v / norm(v) for v in eigenvectors.T]\nprint('Orthonormal eigenvectors:\\n', np.array(orthonormal_vectors).T)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[4, 2], [1, 3]].",
    "output": "import numpy as np\nA = np.array([[4, 2], [1, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Check if the matrix [[2, 1], [1, 2]] is symmetric and find its eigenvectors.",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\nprint('Is symmetric:', np.allclose(A, A.T))\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Diagonalize the matrix [[8, 0], [0, 5]].",
    "output": "import numpy as np\nA = np.array([[8, 0], [0, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues of matrix [[1, -1], [1, 1]].",
    "output": "import numpy as np\nA = np.array([[1, -1], [1, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvalues of a diagonal matrix [[6, 0], [0, -3]].",
    "output": "import numpy as np\nA = np.array([[6, 0], [0, -3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[0, 2], [2, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the diagonal matrix D and matrix P for A = [[10, 0], [0, -2]].",
    "output": "import numpy as np\nA = np.array([[10, 0], [0, -2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
  },
  {
    "input": "Find eigenvalues and eigenvectors of the matrix [[1, 1], [0, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 1], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[3, 2], [2, 3]] is symmetric and compute its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[3, 2], [2, 3]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find eigenvalues of matrix [[0, 1], [1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Compute diagonalization of A = [[2, 0], [0, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 0], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Matrix P:\\n', P)\nprint('Diagonal matrix D:\\n', D)"
  },
  {
    "input": "Find the orthonormal eigenvectors of the matrix [[4, 0], [0, 9]].",
    "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.array([[4, 0], [0, 9]])\n_, eigenvectors = np.linalg.eig(A)\northonormal_vectors = [v / norm(v) for v in eigenvectors.T]\nprint('Orthonormal eigenvectors:\\n', np.array(orthonormal_vectors).T)"
  },
  {
    "input": "Check if the matrix [[1, 2], [2, 1]] can be diagonalized by an orthogonal matrix.",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\nif np.allclose(A, A.T):\n    eigenvalues, eigenvectors = np.linalg.eig(A)\n    print('Matrix is orthogonally diagonalizable.')\nelse:\n    print('Matrix is not symmetric.')"
  },
  {
    "input": "Verify eigen-decomposition A = P D P^(-1) for A = [[5, 0], [0, 1]].",
    "output": "import numpy as np\nA = np.array([[5, 0], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nprint('A from decomposition:\\n', P @ D @ P_inv)"
  },
  {
    "input": "Find the eigenvalues of matrix [[-1, 0], [0, -1]].",
    "output": "import numpy as np\nA = np.array([[-1, 0], [0, -1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[2, 1], [0, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1], [0, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Check if the matrix [[1, 0], [0, -1]] is symmetric and find its eigenvectors.",
    "output": "import numpy as np\nA = np.array([[1, 0], [0, -1]])\nprint('Is symmetric:', np.allclose(A, A.T))\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the trace and determinant of matrix [[3, 1], [1, 3]] and compare with sum and product of eigenvalues.",
    "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues = np.linalg.eigvals(A)\ntrace = np.trace(A)\ndet = np.linalg.det(A)\nprint('Trace:', trace, 'Sum of eigenvalues:', sum(eigenvalues))\nprint('Determinant:', det, 'Product of eigenvalues:', np.prod(eigenvalues))"
  },
  {
    "input": "Find the eigenvalues of matrix [[0, -1], [1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find eigenvalues and eigenvectors of matrix [[5, 0], [0, 0]].",
    "output": "import numpy as np\nA = np.array([[5, 0], [0, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if the matrix [[3, -1], [-1, 3]] is symmetric and orthogonally diagonalizable.",
    "output": "import numpy as np\nA = np.array([[3, -1], [-1, 3]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the diagonal form of matrix [[7, 0], [0, 1]].",
    "output": "import numpy as np\nA = np.array([[7, 0], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix D:\\n', D)"
  },
  {
    "input": "Verify eigen-decomposition A = P D P^(-1) for A = [[4, 0], [0, 9]].",
    "output": "import numpy as np\nA = np.array([[4, 0], [0, 9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nprint('A from decomposition:\\n', P @ D @ P_inv)"
  },
  {
    "input": "Find the eigenvalues of a 2x2 matrix with both rows [2, 2].",
    "output": "import numpy as np\nA = np.array([[2, 2], [2, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find eigenvectors of matrix [[1, 2], [2, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[-3, 0], [0, 4]].",
    "output": "import numpy as np\nA = np.array([[-3, 0], [0, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize the matrix [[6, 0], [0, 2]].",
    "output": "import numpy as np\nA = np.array([[6, 0], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
  },
  {
    "input": "Determine if the matrix [[0, 1], [1, 0]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the eigenvalues of matrix [[2, -1], [-1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvalues and check diagonalizability of matrix [[1, 1], [0, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 1], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the eigenvalues of the matrix [[3, 0], [0, 7]].",
    "output": "import numpy as np\nA = np.array([[3, 0], [0, 7]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Determine if the matrix [[2, 3], [3, 2]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[2, 3], [3, 2]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of the matrix [[0, -1], [1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Diagonalize the matrix [[5, 4], [4, 5]].",
    "output": "import numpy as np\nA = np.array([[5, 4], [4, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Matrix P:\\n', P)\nprint('Diagonal matrix D:\\n', D)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[1, 2], [2, 4]].",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Check if the matrix [[4, 1], [1, 4]] is symmetric and find its eigenvectors.",
    "output": "import numpy as np\nA = np.array([[4, 1], [1, 4]])\nprint('Is symmetric:', np.allclose(A, A.T))\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the diagonal form of the matrix [[3, -2], [-2, 3]].",
    "output": "import numpy as np\nA = np.array([[3, -2], [-2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix D:\\n', D)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of the matrix [[0, 2], [2, 3]].",
    "output": "import numpy as np\nA = np.array([[0, 2], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Determine if the matrix [[6, 2], [2, 6]] is orthogonally diagonalizable.",
    "output": "import numpy as np\nA = np.array([[6, 2], [2, 6]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[7, 0], [0, -1]].",
    "output": "import numpy as np\nA = np.array([[7, 0], [0, -1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Compute the eigenvectors of the matrix [[2, 0], [0, 5]].",
    "output": "import numpy as np\nA = np.array([[2, 0], [0, 5]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Verify the diagonalization of the matrix [[3, 1], [1, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_reconstructed = P @ D @ P_inv\nprint('Reconstructed A:\\n', A_reconstructed)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[0, -2], [2, 0]].",
    "output": "import numpy as np\nA = np.array([[0, -2], [2, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Check if the matrix [[1, 3], [3, 1]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[1, 3], [3, 1]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of the matrix [[4, 0], [0, 9]].",
    "output": "import numpy as np\nA = np.array([[4, 0], [0, 9]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the eigenvalues of matrix [[8, 0], [0, 2]].",
    "output": "import numpy as np\nA = np.array([[8, 0], [0, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find eigenvectors of the matrix [[6, 1], [1, 6]].",
    "output": "import numpy as np\nA = np.array([[6, 1], [1, 6]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check whether matrix [[3, 2], [2, 3]] is symmetric and diagonalizable.",
    "output": "import numpy as np\nA = np.array([[3, 2], [2, 3]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Diagonalize matrix [[4, 0], [0, -3]].",
    "output": "import numpy as np\nA = np.array([[4, 0], [0, -3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
  },
  {
    "input": "Find eigenvalues of matrix [[5, 5], [5, 5]].",
    "output": "import numpy as np\nA = np.array([[5, 5], [5, 5]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find eigenvectors of matrix [[10, 0], [0, 1]].",
    "output": "import numpy as np\nA = np.array([[10, 0], [0, 1]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[7, -3], [-3, 7]] is orthogonally diagonalizable.",
    "output": "import numpy as np\nA = np.array([[7, -3], [-3, 7]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, _ = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Verify A = PDP\u207b\u00b9 for A = [[6, 0], [0, 2]].",
    "output": "import numpy as np\nA = np.array([[6, 0], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nA_reconstructed = P @ D @ P_inv\nprint('A reconstructed:\\n', A_reconstructed)"
  },
  {
    "input": "Find the eigenvalues of matrix [[1, -1], [-1, 1]].",
    "output": "import numpy as np\nA = np.array([[1, -1], [-1, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[9, 0], [0, -4]].",
    "output": "import numpy as np\nA = np.array([[9, 0], [0, -4]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[1, 2], [2, 1]] is symmetric and diagonalizable.",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the diagonal form of matrix [[3, 0], [0, 6]].",
    "output": "import numpy as np\nA = np.array([[3, 0], [0, 6]])\neigenvalues, _ = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix D:\\n', D)"
  },
  {
    "input": "Compute eigenvalues of matrix [[0, 1], [1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find eigenvectors of matrix [[2, 3], [3, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 3], [3, 2]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Diagonalize the matrix [[1, 0], [0, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[2, 1], [1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of the matrix [[2, 1], [1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[0, 1], [1, 0]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize the matrix [[7, 0], [0, 5]].",
    "output": "import numpy as np\nA = np.array([[7, 0], [0, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Verify A = P D P\u207b\u00b9 for A = [[2, 0], [0, 3]].",
    "output": "import numpy as np\nA = np.array([[2, 0], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
  },
  {
    "input": "Find the eigenvalues of matrix [[1, 0], [0, -1]].",
    "output": "import numpy as np\nA = np.array([[1, 0], [0, -1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[1, 0], [0, -1]].",
    "output": "import numpy as np\nA = np.array([[1, 0], [0, -1]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Determine if matrix [[4, 2], [2, 4]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[4, 2], [2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Diagonalize the matrix [[2, -1], [-1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Compute the eigenvalues of matrix [[0, 1], [-1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[0, 1], [-1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 1], [-1, 0]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[3, 4], [4, 3]] is symmetric and find eigenvalues.",
    "output": "import numpy as np\nA = np.array([[3, 4], [4, 3]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize matrix [[1, 1], [1, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 1], [1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues of matrix [[-2, 0], [0, 3]].",
    "output": "import numpy as np\nA = np.array([[-2, 0], [0, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find eigenvectors of matrix [[-2, 0], [0, 3]].",
    "output": "import numpy as np\nA = np.array([[-2, 0], [0, 3]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the eigenvalues of matrix [[3, 0], [0, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 0], [0, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[3, 0], [0, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 0], [0, 3]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Is matrix [[5, 1], [1, 5]] symmetric and diagonalizable?",
    "output": "import numpy as np\nA = np.array([[5, 1], [1, 5]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Diagonalize the matrix [[4, 1], [1, 4]].",
    "output": "import numpy as np\nA = np.array([[4, 1], [1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Compute eigenvalues of matrix [[0, -2], [-2, 0]].",
    "output": "import numpy as np\nA = np.array([[0, -2], [-2, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find eigenvectors of matrix [[0, -2], [-2, 0]].",
    "output": "import numpy as np\nA = np.array([[0, -2], [-2, 0]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Verify that A = P D P\u207b\u00b9 for matrix A = [[2, 1], [1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
  },
  {
    "input": "Find the eigenvalues of matrix [[6, 0], [0, -2]].",
    "output": "import numpy as np\nA = np.array([[6, 0], [0, -2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[6, 0], [0, -2]].",
    "output": "import numpy as np\nA = np.array([[6, 0], [0, -2]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[2, 0], [0, 2]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[2, 0], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the diagonal form of matrix [[9, 0], [0, 1]].",
    "output": "import numpy as np\nA = np.array([[9, 0], [0, 1]])\neigenvalues, _ = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix D:\\n', D)"
  },
  {
    "input": "Diagonalize matrix [[5, 2], [2, 5]].",
    "output": "import numpy as np\nA = np.array([[5, 2], [2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Find the eigenvectors of matrix [[2, -1], [-1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, -1], [-1, 2]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Is matrix [[3, 1], [1, 3]] symmetric and orthogonally diagonalizable?",
    "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\northogonality = np.allclose(eigenvectors.T @ eigenvectors, np.eye(A.shape[0]))\nprint('Orthogonally diagonalizable:', orthogonality)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[1, 2], [2, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of the matrix [[1, 2], [2, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if the matrix [[2, 3], [3, 2]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[2, 3], [3, 2]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Verify A = P D P\u207b\u00b9 for A = [[3, 0], [0, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 0], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
  },
  {
    "input": "Find the eigenvalues of matrix [[0, 2], [2, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 2], [2, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Determine if matrix [[5, 4], [4, 5]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[5, 4], [4, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Diagonalize the matrix [[3, -1], [-1, 3]].",
    "output": "import numpy as np\nA = np.array([[3, -1], [-1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Compute the eigenvalues of matrix [[0, -3], [-3, 0]].",
    "output": "import numpy as np\nA = np.array([[0, -3], [-3, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[0, -3], [-3, 0]].",
    "output": "import numpy as np\nA = np.array([[0, -3], [-3, 0]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[4, 5], [5, 4]] is symmetric and find eigenvalues.",
    "output": "import numpy as np\nA = np.array([[4, 5], [5, 4]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize matrix [[2, 2], [2, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 2], [2, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues of matrix [[-3, 0], [0, 4]].",
    "output": "import numpy as np\nA = np.array([[-3, 0], [0, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find eigenvectors of matrix [[-3, 0], [0, 4]].",
    "output": "import numpy as np\nA = np.array([[-3, 0], [0, 4]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if the matrix [[4, 2], [2, 4]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[4, 2], [2, 4]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize the matrix [[3, 2], [2, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 2], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Verify A = P D P\u207b\u00b9 for A = [[5, 0], [0, 5]].",
    "output": "import numpy as np\nA = np.array([[5, 0], [0, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
  },
  {
    "input": "Find the eigenvalues of matrix [[1, 3], [3, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 3], [3, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[1, 3], [3, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 3], [3, 1]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Determine if matrix [[6, 5], [5, 6]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[6, 5], [5, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Diagonalize the matrix [[4, -1], [-1, 4]].",
    "output": "import numpy as np\nA = np.array([[4, -1], [-1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Compute the eigenvalues of matrix [[0, 4], [4, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 4], [4, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[0, 4], [4, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 4], [4, 0]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[7, 6], [6, 7]] is symmetric and find eigenvalues.",
    "output": "import numpy as np\nA = np.array([[7, 6], [6, 7]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize matrix [[3, 3], [3, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 3], [3, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[3, 1], [1, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of the matrix [[3, 1], [1, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if the matrix [[5, 2], [2, 5]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[5, 2], [2, 5]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize the matrix [[4, 2], [2, 4]].",
    "output": "import numpy as np\nA = np.array([[4, 2], [2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Verify A = P D P\u207b\u00b9 for A = [[6, 0], [0, 6]].",
    "output": "import numpy as np\nA = np.array([[6, 0], [0, 6]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
  },
  {
    "input": "Find the eigenvalues of matrix [[2, 4], [4, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 4], [4, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[2, 4], [4, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 4], [4, 2]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Determine if matrix [[7, 3], [3, 7]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[7, 3], [3, 7]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Diagonalize the matrix [[5, -1], [-1, 5]].",
    "output": "import numpy as np\nA = np.array([[5, -1], [-1, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Compute the eigenvalues of matrix [[0, 5], [5, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 5], [5, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[0, 5], [5, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 5], [5, 0]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[8, 7], [7, 8]] is symmetric and find eigenvalues.",
    "output": "import numpy as np\nA = np.array([[8, 7], [7, 8]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[6, 2], [2, 6]].",
    "output": "import numpy as np\nA = np.array([[6, 2], [2, 6]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of the matrix [[6, 2], [2, 6]].",
    "output": "import numpy as np\nA = np.array([[6, 2], [2, 6]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if the matrix [[3, -2], [-2, 3]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[3, -2], [-2, 3]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize the matrix [[2, 1], [1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Verify if A = PDP\u207b\u00b9 for A = [[7, 0], [0, 3]].",
    "output": "import numpy as np\nA = np.array([[7, 0], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nA_reconstructed = P @ D @ np.linalg.inv(P)\nprint('A reconstructed:\\n', A_reconstructed)"
  },
  {
    "input": "Find the eigenvalues of matrix [[1, 0], [0, 9]].",
    "output": "import numpy as np\nA = np.array([[1, 0], [0, 9]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[1, 0], [0, 9]].",
    "output": "import numpy as np\nA = np.array([[1, 0], [0, 9]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of the 3x3 matrix [[2, 0, 0], [0, 3, 4], [0, 4, 9]].",
    "output": "import numpy as np\nA = np.array([[2, 0, 0], [0, 3, 4], [0, 4, 9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Diagonalize the matrix [[1, 2, 0], [2, 3, 0], [0, 0, 4]].",
    "output": "import numpy as np\nA = np.array([[1, 2, 0], [2, 3, 0], [0, 0, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Check if the matrix [[6, 2, 1], [2, 3, 1], [1, 1, 1]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nrank = np.linalg.matrix_rank(eigenvectors)\nprint('Is diagonalizable:', rank == A.shape[0])"
  },
  {
    "input": "Find eigenvalues of the symmetric matrix [[5, 2, 1], [2, 3, 0], [1, 0, 4]].",
    "output": "import numpy as np\nA = np.array([[5, 2, 1], [2, 3, 0], [1, 0, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find a diagonal matrix similar to A = [[3, 1, 0], [1, 3, 0], [0, 0, 5]].",
    "output": "import numpy as np\nA = np.array([[3, 1, 0], [1, 3, 0], [0, 0, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix D:\\n', D)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of the symmetric matrix [[1, -1, 0], [-1, 2, -1], [0, -1, 1]].",
    "output": "import numpy as np\nA = np.array([[1, -1, 0], [-1, 2, -1], [0, -1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Determine if the matrix [[4, 1, 1], [1, 4, 1], [1, 1, 4]] is diagonalizable and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize the matrix [[7, 2, 0], [2, 5, 0], [0, 0, 3]].",
    "output": "import numpy as np\nA = np.array([[7, 2, 0], [2, 5, 0], [0, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Verify that A = P D P\u207b\u00b9 for A = [[6, 1, 0], [1, 6, 0], [0, 0, 2]].",
    "output": "import numpy as np\nA = np.array([[6, 1, 0], [1, 6, 0], [0, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nP_inv = np.linalg.inv(P)\nA_check = P @ D @ P_inv\nprint('A reconstructed:\\n', A_check)"
  },
  {
    "input": "Find the eigenvalues of matrix [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[5, 2, 2], [2, 5, 2], [2, 2, 5]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[5, 2, 2], [2, 5, 2], [2, 2, 5]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize the symmetric matrix [[10, 2, 3], [2, 6, 4], [3, 4, 8]].",
    "output": "import numpy as np\nA = np.array([[10, 2, 3], [2, 6, 4], [3, 4, 8]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Compute the eigenvalues of matrix [[2, 0, 0], [0, 3, 0], [0, 0, 5]].",
    "output": "import numpy as np\nA = np.array([[2, 0, 0], [0, 3, 0], [0, 0, 5]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Check if matrix [[2, -1, 0], [-1, 2, -1], [0, -1, 2]] is symmetric and diagonalize it.",
    "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix:\\n', D)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[4, 1, -1], [1, 4, -1], [-1, -1, 4]].",
    "output": "import numpy as np\nA = np.array([[4, 1, -1], [1, 4, -1], [-1, -1, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of the matrix [[4, 1, -1], [1, 4, -1], [-1, -1, 4]].",
    "output": "import numpy as np\nA = np.array([[4, 1, -1], [1, 4, -1], [-1, -1, 4]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Determine if the matrix [[3, 2, 2], [2, 3, 2], [2, 2, 3]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[3, 2, 2], [2, 3, 2], [2, 2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Diagonalize the matrix [[1, 2, 3], [2, 1, 2], [3, 2, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)\nprint('P:\\n', eigenvectors)"
  },
  {
    "input": "Find eigenvalues of the matrix [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find a diagonal matrix similar to [[1, 1, 0], [1, 1, 1], [0, 1, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 1, 0], [1, 1, 1], [0, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix:\\n', D)"
  },
  {
    "input": "Check if matrix [[9, 4, 1], [4, 6, 2], [1, 2, 5]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[9, 4, 1], [4, 6, 2], [1, 2, 5]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize the matrix [[5, 0, 2], [0, 3, 0], [2, 0, 5]].",
    "output": "import numpy as np\nA = np.array([[5, 0, 2], [0, 3, 0], [2, 0, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)\nprint('P:\\n', eigenvectors)"
  },
  {
    "input": "Find eigenvalues of the matrix [[6, 2, 0], [2, 3, 0], [0, 0, 1]].",
    "output": "import numpy as np\nA = np.array([[6, 2, 0], [2, 3, 0], [0, 0, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find eigenvectors of the matrix [[6, 2, 0], [2, 3, 0], [0, 0, 1]].",
    "output": "import numpy as np\nA = np.array([[6, 2, 0], [2, 3, 0], [0, 0, 1]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[8, 4, 2], [4, 8, 4], [2, 4, 8]] is symmetric and diagonalize it.",
    "output": "import numpy as np\nA = np.array([[8, 4, 2], [4, 8, 4], [2, 4, 8]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('Diagonal matrix:\\n', D)"
  },
  {
    "input": "Determine whether matrix [[3, -1, 1], [-1, 3, -1], [1, -1, 3]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[3, -1, 1], [-1, 3, -1], [1, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the eigenvalues of the matrix [[0, 1, 0], [1, 0, 1], [0, 1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of matrix [[0, 1, 0], [1, 0, 1], [0, 1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the diagonalization of [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[3, -2, 0], [-2, 3, 0], [0, 0, 1]].",
    "output": "import numpy as np\nA = np.array([[3, -2, 0], [-2, 3, 0], [0, 0, 1]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize the symmetric matrix [[4, -1, 0], [-1, 4, -1], [0, -1, 4]].",
    "output": "import numpy as np\nA = np.array([[4, -1, 0], [-1, 4, -1], [0, -1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)\nprint('P:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[2, 1, -1], [1, 2, 1], [-1, 1, 2]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, 2, 1], [-1, 1, 2]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Compute the eigenvectors of matrix [[2, 1, -1], [1, 2, 1], [-1, 1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1, -1], [1, 2, 1], [-1, 1, 2]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the eigenvalues of matrix [[7, 0, 0], [0, 3, 0], [0, 0, 5]].",
    "output": "import numpy as np\nA = np.array([[7, 0, 0], [0, 3, 0], [0, 0, 5]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of matrix [[1, 1, 1], [1, 1, 1], [1, 1, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 1, 1], [1, 1, 1], [1, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the diagonalization of matrix [[6, 2, 1], [2, 3, 1], [1, 1, 1]].",
    "output": "import numpy as np\nA = np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Check whether matrix [[3, 1, 1], [1, 3, 1], [1, 1, 3]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[3, 1, 1], [1, 3, 1], [1, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the eigenvalues of matrix [[5, 2, 1], [2, 4, 2], [1, 2, 3]].",
    "output": "import numpy as np\nA = np.array([[5, 2, 1], [2, 4, 2], [1, 2, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the diagonal matrix similar to A = [[1, 1, 0], [1, 2, 1], [0, 1, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 1, 0], [1, 2, 1], [0, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
  },
  {
    "input": "Check if matrix [[2, 0, 1], [0, 3, 0], [1, 0, 2]] is symmetric and diagonalizable.",
    "output": "import numpy as np\nA = np.array([[2, 0, 1], [0, 3, 0], [1, 0, 2]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Diagonalize matrix [[1, 2, 0], [2, 1, 0], [0, 0, 3]].",
    "output": "import numpy as np\nA = np.array([[1, 2, 0], [2, 1, 0], [0, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)\nprint('P:\\n', eigenvectors)"
  },
  {
    "input": "Find eigenvectors of the matrix [[1, 0, 2], [0, 3, 0], [2, 0, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 0, 2], [0, 3, 0], [2, 0, 1]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Determine if matrix [[1, -2, 0], [-2, 5, -2], [0, -2, 1]] is symmetric and diagonalizable.",
    "output": "import numpy as np\nA = np.array([[1, -2, 0], [-2, 5, -2], [0, -2, 1]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the eigenvalues of the matrix [[4, -2, 1], [-2, 4, -2], [1, -2, 4]].",
    "output": "import numpy as np\nA = np.array([[4, -2, 1], [-2, 4, -2], [1, -2, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Determine if the matrix [[2, -1, 0], [-1, 2, -1], [0, -1, 2]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the eigenvectors of the matrix [[3, 1, 1], [1, 3, 1], [1, 1, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 1, 1], [1, 3, 1], [1, 1, 3]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Diagonalize the matrix [[1, 2, 3], [2, 1, 2], [3, 2, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of the matrix [[5, 4, 2], [4, 5, 4], [2, 4, 5]].",
    "output": "import numpy as np\nA = np.array([[5, 4, 2], [4, 5, 4], [2, 4, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if the matrix [[2, -1, 0], [-1, 2, -1], [0, -1, 2]] is symmetric and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the diagonalization of the matrix [[4, 1, 1], [1, 4, 1], [1, 1, 4]].",
    "output": "import numpy as np\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Determine if the matrix [[3, -1, 0], [-1, 3, -1], [0, -1, 3]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[3, -1, 0], [-1, 3, -1], [0, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the eigenvalues of the matrix [[2, 0, 1], [0, 3, 0], [1, 0, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 0, 1], [0, 3, 0], [1, 0, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Compute the eigenvectors of the matrix [[2, 0, 1], [0, 3, 0], [1, 0, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 0, 1], [0, 3, 0], [1, 0, 2]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Diagonalize the matrix [[1, 1, 0], [1, 2, 1], [0, 1, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 1, 0], [1, 2, 1], [0, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of the matrix [[3, 2, 2], [2, 3, 2], [2, 2, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 2, 2], [2, 3, 2], [2, 2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[6, 1, 0], [1, 6, 1], [0, 1, 6]].",
    "output": "import numpy as np\nA = np.array([[6, 1, 0], [1, 6, 1], [0, 1, 6]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Diagonalize the symmetric matrix [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)\nprint('P:\\n', eigenvectors)"
  },
  {
    "input": "Find the eigenvectors of the matrix [[0, 1, 0], [1, 0, 1], [0, 1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if matrix [[1, 2, 3], [2, 1, 2], [3, 2, 1]] is diagonalizable and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[4, 1, 2], [1, 4, 1], [2, 1, 4]].",
    "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, 4, 1], [2, 1, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Check if matrix [[2, 0, 1], [0, 2, 0], [1, 0, 2]] is symmetric and diagonalizable.",
    "output": "import numpy as np\nA = np.array([[2, 0, 1], [0, 2, 0], [1, 0, 2]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the eigenvalues of the matrix [[7, 2, 1], [2, 7, 2], [1, 2, 7]].",
    "output": "import numpy as np\nA = np.array([[7, 2, 1], [2, 7, 2], [1, 2, 7]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the diagonal matrix similar to the matrix [[3, 1, 2], [1, 3, 1], [2, 1, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 1, 2], [1, 3, 1], [2, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of matrix [[3, 0, 0], [0, 5, 0], [0, 0, 7]].",
    "output": "import numpy as np\nA = np.array([[3, 0, 0], [0, 5, 0], [0, 0, 7]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Check if the matrix [[3, 1, 2], [1, 3, 1], [2, 1, 3]] is symmetric and diagonalizable.",
    "output": "import numpy as np\nA = np.array([[3, 1, 2], [1, 3, 1], [2, 1, 3]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find the eigenvalues of the matrix [[4, 0, 0], [0, 2, 0], [0, 0, 6]].",
    "output": "import numpy as np\nA = np.array([[4, 0, 0], [0, 2, 0], [0, 0, 6]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the diagonal matrix similar to the matrix [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
  },
  {
    "input": "Find the eigenvectors of the matrix [[1, 2, 0], [2, 1, 2], [0, 2, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 2, 0], [2, 1, 2], [0, 2, 1]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Diagonalize the matrix [[1, 0, 1], [0, 1, 0], [1, 0, 1]].",
    "output": "import numpy as np\nA = np.array([[1, 0, 1], [0, 1, 0], [1, 0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of matrix [[0, 1], [1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the diagonal matrix similar to the matrix [[3, 1], [1, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[5, 4], [4, 5]].",
    "output": "import numpy as np\nA = np.array([[5, 4], [4, 5]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the diagonalization of the matrix [[3, -1], [-1, 3]].",
    "output": "import numpy as np\nA = np.array([[3, -1], [-1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[2, 3, 1], [3, 2, 3], [1, 3, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 3, 1], [3, 2, 3], [1, 3, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Check if matrix [[1, 2], [2, 1]] is diagonalizable and find its eigenvalues.",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[4, 2, 2], [2, 4, 2], [2, 2, 4]].",
    "output": "import numpy as np\nA = np.array([[4, 2, 2], [2, 4, 2], [2, 2, 4]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the diagonal matrix similar to the matrix [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
  },
  {
    "input": "Find the eigenvectors of the matrix [[3, 0, 0], [0, 3, 0], [0, 0, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 0, 0], [0, 3, 0], [0, 0, 3]])\n_, eigenvectors = np.linalg.eig(A)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Diagonalize the matrix [[4, 1, 2], [1, 4, 1], [2, 1, 4]].",
    "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, 4, 1], [2, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of matrix [[2, 0, 1], [0, 2, 0], [1, 0, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 0, 1], [0, 2, 0], [1, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[3, 1, 2], [1, 3, 1], [2, 1, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 1, 2], [1, 3, 1], [2, 1, 3]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the diagonal matrix similar to the matrix [[2, 1], [1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
  },
  {
    "input": "Check if the matrix [[3, 2], [2, 3]] is symmetric and diagonalizable.",
    "output": "import numpy as np\nA = np.array([[3, 2], [2, 3]])\nprint('Is symmetric:', np.allclose(A, A.T))\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Is diagonalizable:', np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Diagonalize the matrix [[4, 0, 1], [0, 4, 0], [1, 0, 4]].",
    "output": "import numpy as np\nA = np.array([[4, 0, 1], [0, 4, 0], [1, 0, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint('D:\\n', D)\nprint('P:\\n', P)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[0, 1], [1, 0]].",
    "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Find the diagonal matrix similar to the matrix [[3, -1], [-1, 3]].",
    "output": "import numpy as np\nA = np.array([[3, -1], [-1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint('D:\\n', D)"
  },
  {
    "input": "Given the matrix A = [[4, 1], [6, -1]], find its eigenvalues and eigenvectors. Determine if A is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[4, 1], [6, -1]])\n\n# Compute eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eig(A)\n\n# Check if the matrix is diagonalizable\ndef is_diagonalizable(eigenvalues, eigenvectors):\n    # A matrix is diagonalizable if it has n linearly independent eigenvectors\n    return np.linalg.matrix_rank(eigenvectors) == A.shape[0]\n\nis_diag = is_diagonalizable(eigenvalues, eigenvectors)\n\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)\nprint('Is diagonalizable:', is_diag)"
  },
  {
    "input": "For the matrix A = [[2, 0, 0], [1, 3, 1], [0, 0, 3]], find the diagonal matrix D and the matrix P such that A = P D P^{-1}.",
    "output": "import numpy as np\n\nA = np.array([[2, 0, 0], [1, 3, 1], [0, 0, 3]])\n\n# Compute eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eig(A)\n\n# Form the diagonal matrix D\nD = np.diag(eigenvalues)\n\n# Form the matrix P\nP = eigenvectors\n\n# Compute P inverse\nP_inv = np.linalg.inv(P)\n\n# Verify the diagonalization\nA_reconstructed = P @ D @ P_inv\n\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)\nprint('P inverse:\\n', P_inv)\nprint('Reconstructed A:\\n', A_reconstructed)"
  },
  {
    "input": "Given the matrix A = [[1, 2], [4, 3]], diagonalize A and use it to compute A^{-1}, if it exists.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [4, 3]])\n\n# Compute eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eig(A)\n\n# Form the diagonal matrix D\nD = np.diag(eigenvalues)\n\n# Form the matrix P\nP = eigenvectors\n\n# Compute P inverse\nP_inv = np.linalg.inv(P)\n\n# Compute A inverse using diagonalization\nD_inv = np.diag(1 / eigenvalues)\nA_inv = P @ D_inv @ P_inv\n\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)\nprint('P inverse:\\n', P_inv)\nprint('A inverse:\\n', A_inv)"
  },
  {
    "input": "Consider the matrix A = [[6, -2], [2, 2]]. Check if it is diagonalizable, given that it has a repeated eigenvalue.",
    "output": "import numpy as np\n\nA = np.array([[6, -2], [2, 2]])\n\n# Compute eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eig(A)\n\n# Check if the matrix is diagonalizable\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\n\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)\nprint('Is diagonalizable:', is_diag)"
  },
  {
    "input": "For the matrix A = [[7, -4, 4], [-4, 8, -4], [4, -4, 7]], find the eigenvalues and eigenvectors. Determine P and D for diagonalization.",
    "output": "import numpy as np\n\nA = np.array([[7, -4, 4], [-4, 8, -4], [4, -4, 7]])\n\n# Compute eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eig(A)\n\n# Form the diagonal matrix D\nD = np.diag(eigenvalues)\n\n# Form the matrix P\nP = eigenvectors\n\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)\nprint('Diagonal matrix D:\\n', D)\nprint('Matrix P:\\n', P)"
  },
  {
    "input": "Given the matrix A = [[1, 0, -1], [1, 2, 1], [2, 2, 3]], find the diagonal matrix D using diagonalization.",
    "output": "import numpy as np\n\nA = np.array([[1, 0, -1], [1, 2, 1], [2, 2, 3]])\n\n# Compute eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eig(A)\n\n# Form the diagonal matrix D\nD = np.diag(eigenvalues)\n\nprint('Diagonal matrix D:\\n', D)"
  },
  {
    "input": "Compute the characteristic polynomial of the matrix A = [[3, -2], [1, 0]], and find its eigenvalues.",
    "output": "import numpy as np\n\nA = np.array([[3, -2], [1, 0]])\n\n# Compute the characteristic polynomial\nchar_poly = np.poly(A)\n\n# Compute the eigenvalues\neigenvalues = np.roots(char_poly)\n\nprint('Characteristic polynomial coefficients:', char_poly)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "For the matrix A = [[0, 1, 1], [1, 0, 1], [1, 1, 0]], compute the eigenvalues and determine if A is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]])\n\n# Compute eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eig(A)\n\n# Check if the matrix is diagonalizable\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\n\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)\nprint('Is diagonalizable:', is_diag)"
  },
  {
    "input": "Given the matrix A = [[3, 2, -2], [2, 2, -2], [2, 2, -1]], find the eigenvalues and check if it can be diagonalized.",
    "output": "import numpy as np\n\nA = np.array([[3, 2, -2], [2, 2, -2], [2, 2, -1]])\n\n# Compute eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eig(A)\n\n# Check diagonalizability\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\n\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)\nprint('Is diagonalizable:', is_diag)"
  },
  {
    "input": "Consider the matrix A = [[5, 4, 2], [0, 1, 0], [0, 0, 3]]. Determine its eigenvalues, and if possible, diagonalize it.",
    "output": "import numpy as np\n\nA = np.array([[5, 4, 2], [0, 1, 0], [0, 0, 3]])\n\n# Compute eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eig(A)\n\n# Form diagonal matrix D\nD = np.diag(eigenvalues)\n\n# Check diagonalizability\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\n\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)\nprint('Diagonal matrix D:\\n', D)\nprint('Is diagonalizable:', is_diag)"
  },
  {
    "input": "Given the matrix A = [[2, 1], [1, 2]], find the orthonormal eigenvectors and diagonalize A using the spectral theorem.",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [1, 2]])\n\n# Compute eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eigh(A)\n\n# Form diagonal matrix D\nD = np.diag(eigenvalues)\n\n# Orthonormal matrix P\nP = eigenvectors\n\n# Reconstruct A from spectral decomposition\nA_reconstructed = P @ D @ P.T\n\nprint('Eigenvalues:', eigenvalues)\nprint('Orthonormal eigenvectors (P):\\n', P)\nprint('Diagonal matrix D:\\n', D)\nprint('Reconstructed A:\\n', A_reconstructed)"
  },
  {
    "input": "Find the spectral decomposition of A = [[1, -1], [-1, 1]].",
    "output": "import numpy as np\n\nA = np.array([[1, -1], [-1, 1]])\n\n# Compute eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eigh(A)\n\n# Spectral decomposition: A = sum(lambda_i * v_i * v_i.T)\nspectral = sum(\n    eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i])\n    for i in range(len(eigenvalues))\n)\n\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)\nprint('Spectral decomposition result:\\n', spectral)"
  },
  {
    "input": "Let A = [[1, 2], [2, 1]]. Is A symmetric? Diagonalize it using the spectral theorem if possible.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 1]])\n\n# Check if A is symmetric\nis_symmetric = np.allclose(A, A.T)\n\n# Use eigh for symmetric matrices\neigenvalues, eigenvectors = np.linalg.eigh(A)\n\n# Form diagonal matrix D\nD = np.diag(eigenvalues)\n\n# Orthonormal matrix P\nP = eigenvectors\n\nprint('Is symmetric:', is_symmetric)\nprint('Eigenvalues:', eigenvalues)\nprint('Orthonormal eigenvectors (P):\\n', P)\nprint('Diagonal matrix D:\\n', D)"
  },
  {
    "input": "Given the matrix A = [[4, 2], [2, 4]], determine whether A is diagonalizable and find the diagonal matrix D if it is.",
    "output": "import numpy as np\n\nA = np.array([[4, 2], [2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of A = [[0, 1], [1, 0]] and verify if A is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[0, 1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Determine the eigenvalues and diagonal form of A = [[6, 2], [2, 3]].",
    "output": "import numpy as np\n\nA = np.array([[6, 2], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Compute the eigenvalues of the symmetric matrix A = [[2, -1], [-1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[2, -1], [-1, 2]])\neigenvalues = np.linalg.eigvalsh(A)\nprint(\"Eigenvalues:\", eigenvalues)"
  },
  {
    "input": "Diagonalize A = [[5, 0], [0, -1]].",
    "output": "import numpy as np\n\nA = np.array([[5, 0], [0, -1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "For A = [[3, 1], [0, 3]], determine whether it is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [0, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Given matrix A = [[1, 1, 0], [1, 1, 0], [0, 0, 2]], find its eigenvalues and check if it is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 0], [1, 1, 0], [0, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the eigenvalues of the 3x3 identity matrix and state if it is diagonalizable.",
    "output": "import numpy as np\n\nA = np.eye(3)\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the spectral decomposition of A = [[2, 0], [0, 5]].",
    "output": "import numpy as np\n\nA = np.array([[2, 0], [0, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspec_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(len(eigenvalues)))\nprint(\"Spectral decomposition:\\n\", spec_decomp)"
  },
  {
    "input": "Determine if A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]] is diagonalizable and provide the diagonal matrix if it is.",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Is diagonalizable:\", np.linalg.matrix_rank(eigenvectors) == A.shape[0])\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Diagonalize the matrix A = [[0, -1], [1, 0]].",
    "output": "import numpy as np\n\nA = np.array([[0, -1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Is the matrix A = [[2, 3], [3, 2]] symmetric and diagonalizable?",
    "output": "import numpy as np\n\nA = np.array([[2, 3], [3, 2]])\nis_symmetric = np.allclose(A, A.T)\neigenvalues, eigenvectors = np.linalg.eigh(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Is symmetric:\", is_symmetric)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the eigenvalues of A = [[4, 1, 0], [1, 4, 1], [0, 1, 4]].",
    "output": "import numpy as np\n\nA = np.array([[4, 1, 0], [1, 4, 1], [0, 1, 4]])\neigenvalues = np.linalg.eigvalsh(A)\nprint(\"Eigenvalues:\", eigenvalues)"
  },
  {
    "input": "Compute the eigenvalues and diagonal matrix D of A = [[6, 0, 0], [0, 3, 0], [0, 0, 2]].",
    "output": "import numpy as np\n\nA = np.array([[6, 0, 0], [0, 3, 0], [0, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Let A = [[1, 2], [2, 1]]. Find eigenvalues and verify orthogonality of eigenvectors.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\northogonal = np.allclose(eigenvectors.T @ eigenvectors, np.eye(2))\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)\nprint(\"Are eigenvectors orthogonal:\", orthogonal)"
  },
  {
    "input": "Given the matrix A = [[3, -2], [-2, 3]], determine if A is diagonalizable and find the diagonal matrix D if it is.",
    "output": "import numpy as np\n\nA = np.array([[3, -2], [-2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of A = [[1, 2], [2, 4]] and verify if A is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Determine the eigenvalues and diagonal form of A = [[7, 0], [0, -3]].",
    "output": "import numpy as np\n\nA = np.array([[7, 0], [0, -3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Compute the eigenvalues of the symmetric matrix A = [[5, 1], [1, 5]].",
    "output": "import numpy as np\n\nA = np.array([[5, 1], [1, 5]])\neigenvalues = np.linalg.eigvalsh(A)\nprint(\"Eigenvalues:\", eigenvalues)"
  },
  {
    "input": "Diagonalize A = [[2, -1], [-1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[2, -1], [-1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "For A = [[4, 1], [2, 3]], determine whether it is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[4, 1], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Given matrix A = [[2, 0, 0], [0, 3, 4], [0, 4, 9]], find its eigenvalues and check if it is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[2, 0, 0], [0, 3, 4], [0, 4, 9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the eigenvalues of the 2x2 zero matrix and state if it is diagonalizable.",
    "output": "import numpy as np\n\nA = np.zeros((2, 2))\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the spectral decomposition of A = [[1, 0], [0, -1]].",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [0, -1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspec_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(len(eigenvalues)))\nprint(\"Spectral decomposition:\\n\", spec_decomp)"
  },
  {
    "input": "Determine if A = [[4, 2, 2], [2, 4, 2], [2, 2, 4]] is diagonalizable and provide the diagonal matrix if it is.",
    "output": "import numpy as np\n\nA = np.array([[4, 2, 2], [2, 4, 2], [2, 2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Is diagonalizable:\", np.linalg.matrix_rank(eigenvectors) == A.shape[0])\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Diagonalize the matrix A = [[0, 1], [-1, 0]].",
    "output": "import numpy as np\n\nA = np.array([[0, 1], [-1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Is the matrix A = [[3, 2], [2, 3]] symmetric and diagonalizable?",
    "output": "import numpy as np\n\nA = np.array([[3, 2], [2, 3]])\nis_symmetric = np.allclose(A, A.T)\neigenvalues, eigenvectors = np.linalg.eigh(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Is symmetric:\", is_symmetric)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the eigenvalues of A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues = np.linalg.eigvalsh(A)\nprint(\"Eigenvalues:\", eigenvalues)"
  },
  {
    "input": "Compute the eigenvalues and diagonal matrix D of A = [[1, 1, 1], [1, 1, 1], [1, 1, 1]].",
    "output": "import numpy as np\n\nA = np.ones((3, 3))\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Let A = [[0, 2], [2, 3]]. Find the eigenvalues and verify if A is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[0, 2], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of the diagonal matrix A = [[7, 0, 0], [0, -2, 0], [0, 0, 5]].",
    "output": "import numpy as np\n\nA = np.diag([7, -2, 5])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Find the eigenvalues and check diagonalizability of A = [[1, 3], [3, 1]].",
    "output": "import numpy as np\n\nA = np.array([[1, 3], [3, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Diagonalize the matrix A = [[2, -2], [-2, 5]].",
    "output": "import numpy as np\n\nA = np.array([[2, -2], [-2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of A = [[0, 1, 0], [1, 0, 1], [0, 1, 0]].",
    "output": "import numpy as np\n\nA = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Determine whether A = [[3, 0, 0], [0, 3, 0], [0, 0, 3]] is diagonalizable.",
    "output": "import numpy as np\n\nA = 3 * np.eye(3)\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Diagonalize the matrix A = [[5, 4], [4, 5]].",
    "output": "import numpy as np\n\nA = np.array([[5, 4], [4, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Find the eigenvalues of the matrix A = [[1, 2, 1], [6, -1, 0], [-1, -2, -1]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 1], [6, -1, 0], [-1, -2, -1]])\neigenvalues = np.linalg.eigvals(A)\nprint(\"Eigenvalues:\", eigenvalues)"
  },
  {
    "input": "Check if matrix A = [[2, 1], [0, 2]] is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nrank = np.linalg.matrix_rank(eigenvectors)\nis_diag = rank == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the eigenvalues and verify if A = [[1, -1], [-1, 1]] is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[1, -1], [-1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the spectral decomposition of A = [[3, 0], [0, 7]].",
    "output": "import numpy as np\n\nA = np.array([[3, 0], [0, 7]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\ndecomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(2))\nprint(\"Spectral decomposition:\\n\", decomp)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of A = [[0, 2], [2, 0]] and confirm diagonalization.",
    "output": "import numpy as np\n\nA = np.array([[0, 2], [2, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Matrix P:\\n\", P)"
  },
  {
    "input": "Diagonalize A = [[6, -2], [-2, 3]].",
    "output": "import numpy as np\n\nA = np.array([[6, -2], [-2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors (P):\\n\", eigenvectors)"
  },
  {
    "input": "Determine the eigenvalues of A = [[4, 1], [1, 4]] and verify symmetry.",
    "output": "import numpy as np\n\nA = np.array([[4, 1], [1, 4]])\neigenvalues = np.linalg.eigvals(A)\nis_symmetric = np.allclose(A, A.T)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is symmetric:\", is_symmetric)"
  },
  {
    "input": "Check if the matrix A = [[0, 1], [-2, -3]] is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[0, 1], [-2, -3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the diagonal form of matrix A = [[2, 2, 1], [2, 3, 1], [1, 1, 1]].",
    "output": "import numpy as np\n\nA = np.array([[2, 2, 1], [2, 3, 1], [1, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Find the spectral decomposition of A = [[5, 0], [0, -2]].",
    "output": "import numpy as np\n\nA = np.array([[5, 0], [0, -2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(2))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of A = [[1, 4], [2, 3]].",
    "output": "import numpy as np\n\nA = np.array([[1, 4], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Is the matrix A = [[9, 0, 0], [0, 2, 0], [0, 0, 5]] diagonalizable?",
    "output": "import numpy as np\n\nA = np.diag([9, 2, 5])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the diagonal matrix D and P for matrix A = [[3, 1], [1, 3]].",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Matrix P:\\n\", P)"
  },
  {
    "input": "Compute the eigenvalues of matrix A = [[0, 1, 0], [1, 0, 1], [0, 1, 0]].",
    "output": "import numpy as np\n\nA = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\neigenvalues = np.linalg.eigvals(A)\nprint(\"Eigenvalues:\", eigenvalues)"
  },
  {
    "input": "Verify diagonalizability of A = [[1, 2], [0, 1]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Find the eigenvalues and diagonalize the matrix A = [[2, 1], [1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Determine if A = [[1, 1, 0], [0, 1, 0], [0, 0, 2]] is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 0], [0, 1, 0], [0, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Compute the eigenvalues and eigenvectors of matrix A = [[0, -1], [1, 0]].",
    "output": "import numpy as np\n\nA = np.array([[0, -1], [1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Diagonalize the matrix A = [[4, 1, 1], [1, 4, 1], [1, 1, 4]].",
    "output": "import numpy as np\n\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors (P):\\n\", eigenvectors)"
  },
  {
    "input": "Find the spectral decomposition of the symmetric matrix A = [[6, 2], [2, 3]].",
    "output": "import numpy as np\n\nA = np.array([[6, 2], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(2))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Let A = [[4, 1, 2], [1, 3, 1], [2, 1, 3]]. Compute the eigenvalues and determine if A is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[4, 1, 2], [1, 3, 1], [2, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Given A = [[0, 2, 2], [2, 0, 2], [2, 2, 0]], find the spectral decomposition of A.",
    "output": "import numpy as np\n\nA = np.array([[0, 2, 2], [2, 0, 2], [2, 2, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral_decomp)"
  },
  {
    "input": "For matrix A = [[5, 2, 1], [2, 5, 2], [1, 2, 5]], verify if A is unitarily diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[5, 2, 1], [2, 5, 2], [1, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_unitarily_diag = np.allclose(A @ eigenvectors, eigenvectors @ np.diag(eigenvalues)) and np.allclose(eigenvectors.conj().T @ eigenvectors, np.eye(A.shape[0]))\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is unitarily diagonalizable:\", is_unitarily_diag)"
  },
  {
    "input": "Compute the eigenvalues and eigenvectors of A = [[3, -1, 0], [-1, 3, -1], [0, -1, 3]].",
    "output": "import numpy as np\n\nA = np.array([[3, -1, 0], [-1, 3, -1], [0, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Let A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]]. Determine if A is diagonalizable and find the diagonal form if it is.",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nD = np.diag(eigenvalues) if is_diag else None\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)\nif is_diag:\n    print(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of A = [[1, 2, 3], [2, 1, 2], [3, 2, 1]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [2, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Given A = [[0, -1, 0], [1, 0, -1], [0, 1, 0]], determine if A is diagonalizable over the complex field.",
    "output": "import numpy as np\n\nA = np.array([[0, -1, 0], [1, 0, -1], [0, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable over complex field:\", is_diag)"
  },
  {
    "input": "For matrix A = [[4, -2, 2], [-2, 4, -2], [2, -2, 4]], find the orthogonal matrix P that diagonalizes A.",
    "output": "import numpy as np\n\nA = np.array([[4, -2, 2], [-2, 4, -2], [2, -2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Orthogonal matrix P:\\n\", P)"
  },
  {
    "input": "Compute the Jordan canonical form of A = [[5, 4, 2], [0, 5, 1], [0, 0, 5]] using symbolic computation.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, 4, 2], [0, 5, 1], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan canonical form J:\\n\", J)\nprint(\"Transformation matrix P:\\n\", P)"
  },
  {
    "input": "Let A = [[1, 2, 0], [0, 1, 2], [2, 0, 1]]. Determine if A is diagonalizable and find the diagonal matrix if it is.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 0], [0, 1, 2], [2, 0, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nD = np.diag(eigenvalues) if is_diag else None\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)\nif is_diag:\n    print(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Diagonalize A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Eigenvectors P:\\n\", eigenvectors)"
  },
  {
    "input": "Let A be the symmetric matrix [[6, -2, 0], [-2, 3, -1], [0, -1, 1]]. Find its spectral decomposition.",
    "output": "import numpy as np\n\nA = np.array([[6, -2, 0], [-2, 3, -1], [0, -1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Is the matrix A = [[0, 2, -2], [-2, 0, 2], [2, -2, 0]] diagonalizable over \u2102? Find eigenvalues.",
    "output": "import numpy as np\n\nA = np.array([[0, 2, -2], [-2, 0, 2], [2, -2, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonalizable over \u2102:\", is_diag)"
  },
  {
    "input": "Find an orthonormal basis of eigenvectors for A = [[4, 1, 1], [1, 4, 1], [1, 1, 4]].",
    "output": "import numpy as np\n\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\n_, eigenvectors = np.linalg.eigh(A)\nprint(\"Orthonormal basis (eigenvectors):\\n\", eigenvectors)"
  },
  {
    "input": "Compute the spectral decomposition of A = [[1, 0, 0], [0, 2, 1], [0, 1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[1, 0, 0], [0, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Given a symmetric matrix A = [[10, 2, 3], [2, 5, 1], [3, 1, 7]], diagonalize A and verify A = PDP\u207b\u00b9.",
    "output": "import numpy as np\n\nA = np.array([[10, 2, 3], [2, 5, 1], [3, 1, 7]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nreconstructed = P @ D @ P.T\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Reconstructed A:\\n\", reconstructed)\nprint(\"Close to original A:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Find the eigenvalues of matrix A = [[2, 2, 1], [2, 3, 2], [1, 2, 2]] and check multiplicity.",
    "output": "import numpy as np\nfrom collections import Counter\n\nA = np.array([[2, 2, 1], [2, 3, 2], [1, 2, 2]])\neigenvalues = np.linalg.eigvals(A)\nmultiplicities = Counter(np.round(eigenvalues, 6))\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Algebraic multiplicities:\", multiplicities)"
  },
  {
    "input": "Let A = [[3, 2, 0], [2, 3, 2], [0, 2, 3]]. Compute the eigenvalues and confirm symmetry.",
    "output": "import numpy as np\n\nA = np.array([[3, 2, 0], [2, 3, 2], [0, 2, 3]])\neigenvalues = np.linalg.eigvals(A)\nis_symmetric = np.allclose(A, A.T)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is symmetric:\", is_symmetric)"
  },
  {
    "input": "Determine if A = [[4, 1, -2], [1, 2, 0], [-2, 0, 3]] is orthogonally diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[4, 1, -2], [1, 2, 0], [-2, 0, 3]])\nissymmetric = np.allclose(A, A.T)\neigenvalues, eigenvectors = np.linalg.eigh(A)\nis_orth_diag = np.allclose(eigenvectors.T @ eigenvectors, np.eye(3)) and issymmetric\nprint(\"Is orthogonally diagonalizable:\", is_orth_diag)"
  },
  {
    "input": "Find the diagonal matrix and matrix P such that A = PDP\u207b\u00b9, for A = [[6, 2, 0], [2, 3, 1], [0, 1, 1]].",
    "output": "import numpy as np\n\nA = np.array([[6, 2, 0], [2, 3, 1], [0, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Matrix P:\\n\", P)"
  },
  {
    "input": "Let A = [[7, 2, 1], [2, 8, 3], [1, 3, 9]]. Find the eigenvalues and determine if A is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[7, 2, 1], [2, 8, 3], [1, 3, 9]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Given A = [[0, 1, -1], [1, 0, 1], [-1, 1, 0]], find the spectral decomposition of A.",
    "output": "import numpy as np\n\nA = np.array([[0, 1, -1], [1, 0, 1], [-1, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral_decomp)"
  },
  {
    "input": "For matrix A = [[4, 2, 2], [2, 4, 2], [2, 2, 4]], verify if A is unitarily diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[4, 2, 2], [2, 4, 2], [2, 2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_unitarily_diag = np.allclose(A @ eigenvectors, eigenvectors @ np.diag(eigenvalues)) and np.allclose(eigenvectors.conj().T @ eigenvectors, np.eye(A.shape[0]))\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is unitarily diagonalizable:\", is_unitarily_diag)"
  },
  {
    "input": "Compute the eigenvalues and eigenvectors of A = [[5, -2, 2], [-2, 5, -2], [2, -2, 5]].",
    "output": "import numpy as np\n\nA = np.array([[5, -2, 2], [-2, 5, -2], [2, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Let A = [[3, 1, 0], [1, 3, 1], [0, 1, 3]]. Determine if A is diagonalizable and find the diagonal form if it is.",
    "output": "import numpy as np\n\nA = np.array([[3, 1, 0], [1, 3, 1], [0, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nD = np.diag(eigenvalues) if is_diag else None\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)\nif is_diag:\n    print(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of A = [[2, -2, 1], [-2, 2, -2], [1, -2, 2]].",
    "output": "import numpy as np\n\nA = np.array([[2, -2, 1], [-2, 2, -2], [1, -2, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Given A = [[0, -2, 2], [2, 0, -2], [-2, 2, 0]], determine if A is diagonalizable over the complex field.",
    "output": "import numpy as np\n\nA = np.array([[0, -2, 2], [2, 0, -2], [-2, 2, 0]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable over complex field:\", is_diag)"
  },
  {
    "input": "For matrix A = [[6, -3, 2], [-3, 6, -3], [2, -3, 6]], find the orthogonal matrix P that diagonalizes A.",
    "output": "import numpy as np\n\nA = np.array([[6, -3, 2], [-3, 6, -3], [2, -3, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Orthogonal matrix P:\\n\", P)"
  },
  {
    "input": "Compute the Jordan canonical form of A = [[4, 3, 0], [0, 4, 1], [0, 0, 4]] using symbolic computation.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 3, 0], [0, 4, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan canonical form J:\\n\", J)\nprint(\"Transformation matrix P:\\n\", P)"
  },
  {
    "input": "Let A = [[2, 0, 1], [1, 2, 0], [0, 1, 2]]. Determine if A is diagonalizable and find the diagonal matrix if it is.",
    "output": "import numpy as np\n\nA = np.array([[2, 0, 1], [1, 2, 0], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nD = np.diag(eigenvalues) if is_diag else None\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)\nif is_diag:\n    print(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Let A = [[3, 1, 1], [1, 3, 1], [1, 1, 3]]. Diagonalize A and verify A = PDP\u207b\u00b9.",
    "output": "import numpy as np\n\nA = np.array([[3, 1, 1], [1, 3, 1], [1, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nreconstructed = P @ D @ P.T\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Reconstructed A:\\n\", reconstructed)\nprint(\"Is A = PDP\u207b\u00b9:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Compute the eigenvalues and check if the matrix A = [[2, 2, 1], [2, 3, 2], [1, 2, 2]] is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[2, 2, 1], [2, 3, 2], [1, 2, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Given the matrix A = [[1, 2, 3], [2, 1, 2], [3, 2, 1]], find its eigenvalues and diagonalize it if possible.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [2, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nif np.linalg.matrix_rank(eigenvectors) == A.shape[0]:\n    D = np.diag(eigenvalues)\n    print(\"Diagonal matrix D:\\n\", D)\nelse:\n    print(\"Matrix is not diagonalizable\")"
  },
  {
    "input": "Find the spectral decomposition of matrix A = [[1, -1, 0], [-1, 2, -1], [0, -1, 1]].",
    "output": "import numpy as np\n\nA = np.array([[1, -1, 0], [-1, 2, -1], [0, -1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Let A = [[5, 4, 2], [4, 5, 2], [2, 2, 2]]. Determine if A is diagonalizable and find the diagonal matrix.",
    "output": "import numpy as np\n\nA = np.array([[5, 4, 2], [4, 5, 2], [2, 2, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nD = np.diag(eigenvalues) if is_diag else None\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonalizable:\", is_diag)\nif is_diag:\n    print(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Let A = [[4, -1, 1], [-1, 3, -2], [1, -2, 3]]. Find the eigenvalues and an orthogonal matrix P that diagonalizes A.",
    "output": "import numpy as np\n\nA = np.array([[4, -1, 1], [-1, 3, -2], [1, -2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", P)"
  },
  {
    "input": "Given the matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]], verify if A is orthogonally diagonalizable and find the diagonal matrix D if it is.",
    "output": "import numpy as np\n\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nis_orthogonally_diag = np.allclose(A, eigenvectors @ D @ eigenvectors.T)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is orthogonally diagonalizable:\", is_orthogonally_diag)\nif is_orthogonally_diag:\n    print(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "For matrix A = [[1, 2, 2], [2, 1, 2], [2, 2, 1]], determine if A is diagonalizable and find the diagonal form if it is.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 2], [2, 1, 2], [2, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nD = np.diag(eigenvalues) if is_diag else None\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)\nif is_diag:\n    print(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Compute the spectral decomposition of A = [[3, 1, 0], [1, 3, 1], [0, 1, 3]].",
    "output": "import numpy as np\n\nA = np.array([[3, 1, 0], [1, 3, 1], [0, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral_decomp)"
  },
  {
    "input": "Let A = [[0, 1, 1], [1, 0, 1], [1, 1, 0]]. Find the eigenvalues and an orthogonal matrix P that diagonalizes A.",
    "output": "import numpy as np\n\nA = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", P)"
  },
  {
    "input": "Given the matrix A = [[2, 0, 1], [0, 3, 0], [1, 0, 2]], verify if A is orthogonally diagonalizable and find the diagonal matrix D if it is.",
    "output": "import numpy as np\n\nA = np.array([[2, 0, 1], [0, 3, 0], [1, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nis_orthogonally_diag = np.allclose(A, eigenvectors @ D @ eigenvectors.T)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is orthogonally diagonalizable:\", is_orthogonally_diag)\nif is_orthogonally_diag:\n    print(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "For matrix A = [[4, 2, 2], [2, 4, 2], [2, 2, 4]], determine if A is diagonalizable and find the diagonal form if it is.",
    "output": "import numpy as np\n\nA = np.array([[4, 2, 2], [2, 4, 2], [2, 2, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nD = np.diag(eigenvalues) if is_diag else None\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)\nif is_diag:\n    print(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Compute the spectral decomposition of A = [[5, -2, 2], [-2, 5, -2], [2, -2, 5]].",
    "output": "import numpy as np\n\nA = np.array([[5, -2, 2], [-2, 5, -2], [2, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral_decomp = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral_decomp)"
  },
  {
    "input": "Let A = [[3, -1, 1], [-1, 3, -1], [1, -1, 3]]. Find the eigenvalues and an orthogonal matrix P that diagonalizes A.",
    "output": "import numpy as np\n\nA = np.array([[3, -1, 1], [-1, 3, -1], [1, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", P)"
  },
  {
    "input": "Let A = [[1, -1, 0], [-1, 2, -1], [0, -1, 1]]. Verify if A is symmetric and find its spectral decomposition.",
    "output": "import numpy as np\n\nA = np.array([[1, -1, 0], [-1, 2, -1], [0, -1, 1]])\nis_symmetric = np.allclose(A, A.T)\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Is symmetric:\", is_symmetric)\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Let A = [[4, 1, -2], [1, 2, 0], [-2, 0, 3]]. Diagonalize A and verify the diagonalization.",
    "output": "import numpy as np\n\nA = np.array([[4, 1, -2], [1, 2, 0], [-2, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Reconstructed A:\\n\", reconstructed)\nprint(\"Verified:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Find eigenvalues and eigenvectors of A = [[6, 2, 0], [2, 3, 1], [0, 1, 1]] and check if it's diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[6, 2, 0], [2, 3, 1], [0, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", is_diag)"
  },
  {
    "input": "Let A = [[2, -2, 4], [-2, 5, -2], [4, -2, 2]]. Find the spectral decomposition.",
    "output": "import numpy as np\n\nA = np.array([[2, -2, 4], [-2, 5, -2], [4, -2, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Given symmetric matrix A = [[3, 1, 0], [1, 3, 1], [0, 1, 3]], find orthogonal matrix P such that A = PDP\u1d40.",
    "output": "import numpy as np\n\nA = np.array([[3, 1, 0], [1, 3, 1], [0, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint(\"PDP\u1d40 reconstruction check:\", np.allclose(A, P @ D @ P.T))"
  },
  {
    "input": "Diagonalize A = [[5, -2, -1], [-2, 6, -2], [-1, -2, 5]] and print the diagonal matrix.",
    "output": "import numpy as np\n\nA = np.array([[5, -2, -1], [-2, 6, -2], [-1, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Let A = [[1, 1, 0], [1, 2, 1], [0, 1, 1]]. Find eigenvalues and verify if A is symmetric and diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 0], [1, 2, 1], [0, 1, 1]])\nis_symmetric = np.allclose(A, A.T)\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint(\"Symmetric:\", is_symmetric)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonalizable:\", is_diag)"
  },
  {
    "input": "Given A = [[0, 2, 2], [2, 0, 2], [2, 2, 0]], find the orthogonal matrix P that diagonalizes A.",
    "output": "import numpy as np\n\nA = np.array([[0, 2, 2], [2, 0, 2], [2, 2, 0]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Orthogonal matrix P:\\n\", P)"
  },
  {
    "input": "Let A = [[2, 3, 1], [3, 0, -1], [1, -1, 4]]. Compute eigenvalues and diagonalize if possible.",
    "output": "import numpy as np\n\nA = np.array([[2, 3, 1], [3, 0, -1], [1, -1, 4]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diag = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nif is_diag:\n    D = np.diag(eigenvalues)\n    print(\"Diagonal matrix D:\\n\", D)\nelse:\n    print(\"Matrix is not diagonalizable\")"
  },
  {
    "input": "Find the spectral decomposition of A = [[4, 1, 1], [1, 4, 1], [1, 1, 4]].",
    "output": "import numpy as np\n\nA = np.array([[4, 1, 1], [1, 4, 1], [1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Let A = [[1, 2, 3], [2, 1, 2], [3, 2, 1]]. Diagonalize A and confirm the reconstruction.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [2, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nreconstructed = P @ D @ np.linalg.inv(P)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Reconstruction matches A:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Let A = [[5, 2, 0], [2, 3, 1], [0, 1, 4]]. Diagonalize A and verify your result.",
    "output": "import numpy as np\n\nA = np.array([[5, 2, 0], [2, 3, 1], [0, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Reconstructed A:\\n\", reconstructed)\nprint(\"Verified:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Given matrix A = [[6, -2, 2], [-2, 3, -1], [2, -1, 3]], find its spectral decomposition.",
    "output": "import numpy as np\n\nA = np.array([[6, -2, 2], [-2, 3, -1], [2, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Find eigenvalues of A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]] and determine if the matrix is orthogonally diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Orthogonally diagonalizable:\", np.allclose(A, eigenvectors @ np.diag(eigenvalues) @ eigenvectors.T))"
  },
  {
    "input": "Given A = [[1, 1, 1], [1, 2, 2], [1, 2, 3]], find eigenvalues and check if A is diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 1], [1, 2, 2], [1, 2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nrank = np.linalg.matrix_rank(eigenvectors)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Is diagonalizable:\", rank == A.shape[0])"
  },
  {
    "input": "Diagonalize A = [[2, 2, 1], [2, 3, 2], [1, 2, 2]] and confirm the diagonalization.",
    "output": "import numpy as np\n\nA = np.array([[2, 2, 1], [2, 3, 2], [1, 2, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Reconstructed A:\\n\", reconstructed)\nprint(\"Confirmed:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Given symmetric matrix A = [[4, 1, -1], [1, 4, 1], [-1, 1, 4]], find spectral decomposition.",
    "output": "import numpy as np\n\nA = np.array([[4, 1, -1], [1, 4, 1], [-1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Compute the spectral decomposition of matrix A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Find an orthogonal matrix P that diagonalizes A = [[1, 0, 0], [0, 2, 1], [0, 1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[1, 0, 0], [0, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nprint(\"Orthogonal matrix P:\\n\", P)"
  },
  {
    "input": "Verify if A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]] is symmetric and then compute its diagonal form.",
    "output": "import numpy as np\n\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\nis_symmetric = np.allclose(A, A.T)\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Is symmetric:\", is_symmetric)\nprint(\"Diagonal form D:\\n\", D)"
  },
  {
    "input": "Let A = [[1, 2, 3], [2, 5, 6], [3, 6, 9]]. Perform diagonalization and confirm the result.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [2, 5, 6], [3, 6, 9]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstruction = eigenvectors @ D @ eigenvectors.T\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Reconstructed A:\\n\", reconstruction)\nprint(\"Confirmed:\", np.allclose(A, reconstruction))"
  },
  {
    "input": "Let A = [[2, 1, 1], [1, 2, 1], [1, 1, 2]]. Find the spectral decomposition of A.",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Given matrix A = [[4, -2, 2], [-2, 2, 0], [2, 0, 3]], diagonalize A and verify the result.",
    "output": "import numpy as np\n\nA = np.array([[4, -2, 2], [-2, 2, 0], [2, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstruction = eigenvectors @ D @ eigenvectors.T\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Reconstructed A:\\n\", reconstruction)\nprint(\"Verified:\", np.allclose(A, reconstruction))"
  },
  {
    "input": "Let A = [[6, -2, 0], [-2, 3, -1], [0, -1, 1]]. Is A symmetric and what is its spectral form?",
    "output": "import numpy as np\n\nA = np.array([[6, -2, 0], [-2, 3, -1], [0, -1, 1]])\nis_symmetric = np.allclose(A, A.T)\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Symmetric:\", is_symmetric)\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Diagonalize A = [[7, 0, 1], [0, 4, 0], [1, 0, 7]] and check if the reconstruction is valid.",
    "output": "import numpy as np\n\nA = np.array([[7, 0, 1], [0, 4, 0], [1, 0, 7]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"D:\\n\", D)\nprint(\"Reconstructed A:\\n\", reconstructed)\nprint(\"Valid reconstruction:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Given symmetric matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]], find eigenvalues and confirm diagonalizability.",
    "output": "import numpy as np\n\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonalizable:\", np.linalg.matrix_rank(eigenvectors) == A.shape[0])"
  },
  {
    "input": "Find eigenvalues and orthogonal diagonalization for A = [[5, 2, 2], [2, 5, 2], [2, 2, 5]].",
    "output": "import numpy as np\n\nA = np.array([[5, 2, 2], [2, 5, 2], [2, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", eigenvectors)\nprint(\"D =\\n\", D)"
  },
  {
    "input": "Diagonalize A = [[3, -2, 4], [-2, 6, 2], [4, 2, 3]] using eigen decomposition.",
    "output": "import numpy as np\n\nA = np.array([[3, -2, 4], [-2, 6, 2], [4, 2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Let A = [[4, 1, 2], [1, 2, 0], [2, 0, 3]]. Find the spectral decomposition.",
    "output": "import numpy as np\n\nA = np.array([[4, 1, 2], [1, 2, 0], [2, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\ncomponents = [eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3)]\nspectral = sum(components)\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Determine if matrix A = [[3, -1, 1], [-1, 3, -1], [1, -1, 3]] is symmetric and compute its diagonal form.",
    "output": "import numpy as np\n\nA = np.array([[3, -1, 1], [-1, 3, -1], [1, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Symmetric:\", np.allclose(A, A.T))\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Find eigenvalues and verify spectral decomposition of A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nreconstruct = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Spectral decomposition matches A:\", np.allclose(A, reconstruct))"
  },
  {
    "input": "Diagonalize the symmetric matrix A = [[1, 2, 3], [2, 1, 2], [3, 2, 1]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [2, 1, 2], [3, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstruction = eigenvectors @ D @ eigenvectors.T\nprint(\"D:\\n\", D)\nprint(\"Reconstructed A:\\n\", reconstruction)\nprint(\"Verified:\", np.allclose(A, reconstruction))"
  },
  {
    "input": "Find the eigenvalues and verify the spectral theorem for A = [[2, 2, 1], [2, 3, 2], [1, 2, 2]].",
    "output": "import numpy as np\n\nA = np.array([[2, 2, 1], [2, 3, 2], [1, 2, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Spectral theorem holds:\", np.allclose(A, spectral))"
  },
  {
    "input": "Given symmetric matrix A = [[4, -2, 0], [-2, 4, -2], [0, -2, 4]], diagonalize it using orthogonal matrices.",
    "output": "import numpy as np\n\nA = np.array([[4, -2, 0], [-2, 4, -2], [0, -2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nP = eigenvectors\nprint(\"Orthogonal matrix P:\\n\", P)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Find eigenvalues and perform spectral decomposition of A = [[5, 3, 1], [3, 5, 3], [1, 3, 5]].",
    "output": "import numpy as np\n\nA = np.array([[5, 3, 1], [3, 5, 3], [1, 3, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Let A = [[2, 0, 1], [0, 3, 0], [1, 0, 2]]. Find its eigenvalues and verify diagonalization.",
    "output": "import numpy as np\n\nA = np.array([[2, 0, 1], [0, 3, 0], [1, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstruct = eigenvectors @ D @ eigenvectors.T\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Reconstruction valid:\", np.allclose(A, reconstruct))"
  },
  {
    "input": "Compute spectral decomposition of symmetric matrix A = [[3, 1, 1], [1, 3, 1], [1, 1, 3]].",
    "output": "import numpy as np\n\nA = np.array([[3, 1, 1], [1, 3, 1], [1, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Check whether A = [[3, -2, 0], [-2, 3, -2], [0, -2, 3]] can be diagonalized using orthogonal matrices.",
    "output": "import numpy as np\n\nA = np.array([[3, -2, 0], [-2, 3, -2], [0, -2, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nP = eigenvectors\nD = np.diag(eigenvalues)\nprint(\"Orthogonal diagonalization possible:\", np.allclose(A, P @ D @ P.T))"
  },
  {
    "input": "Given A = [[6, -1, 0], [-1, 6, -1], [0, -1, 6]], perform eigen decomposition and validate reconstruction.",
    "output": "import numpy as np\n\nA = np.array([[6, -1, 0], [-1, 6, -1], [0, -1, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Reconstructed A:\\n\", reconstructed)\nprint(\"Matches original:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Determine if matrix A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]] satisfies the spectral theorem.",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral theorem valid:\", np.allclose(A, spectral))"
  },
  {
    "input": "Diagonalize the symmetric matrix A = [[7, 4, 1], [4, 6, 2], [1, 2, 5]] using orthogonal transformation.",
    "output": "import numpy as np\n\nA = np.array([[7, 4, 1], [4, 6, 2], [1, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", eigenvectors)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Given A = [[4, 1, 2], [1, 3, 0], [2, 0, 5]], compute its eigenvalues and verify the spectral theorem.",
    "output": "import numpy as np\n\nA = np.array([[4, 1, 2], [1, 3, 0], [2, 0, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral theorem holds:\", np.allclose(A, spectral))"
  },
  {
    "input": "Diagonalize A = [[5, 2, 1], [2, 6, 2], [1, 2, 7]] and check reconstruction.",
    "output": "import numpy as np\n\nA = np.array([[5, 2, 1], [2, 6, 2], [1, 2, 7]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"Reconstructed A:\\n\", reconstructed)\nprint(\"Matches original:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Verify that symmetric matrix A = [[2, -1, 1], [-1, 2, -1], [1, -1, 2]] satisfies the spectral theorem.",
    "output": "import numpy as np\n\nA = np.array([[2, -1, 1], [-1, 2, -1], [1, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral theorem valid:\", np.allclose(A, spectral))"
  },
  {
    "input": "Find the spectral decomposition of matrix A = [[1, 1, 1], [1, 1, 1], [1, 1, 1]].",
    "output": "import numpy as np\n\nA = np.array([[1, 1, 1], [1, 1, 1], [1, 1, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\ncomponents = [eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3)]\nspectral = sum(components)\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Let A = [[10, -2, 3], [-2, 5, 0], [3, 0, 6]]. Diagonalize and validate the reconstruction.",
    "output": "import numpy as np\n\nA = np.array([[10, -2, 3], [-2, 5, 0], [3, 0, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nA_reconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"Valid reconstruction:\", np.allclose(A, A_reconstructed))"
  },
  {
    "input": "Diagonalize symmetric matrix A = [[6, 2, 1], [2, 5, 2], [1, 2, 4]] using eigen decomposition.",
    "output": "import numpy as np\n\nA = np.array([[6, 2, 1], [2, 5, 2], [1, 2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Given A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]], compute its eigenvalues and validate orthogonal diagonalization.",
    "output": "import numpy as np\n\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Orthogonal diagonalization valid:\", np.allclose(A, eigenvectors @ D @ eigenvectors.T))"
  },
  {
    "input": "Perform spectral decomposition of A = [[9, 4, 2], [4, 9, 4], [2, 4, 9]].",
    "output": "import numpy as np\n\nA = np.array([[9, 4, 2], [4, 9, 4], [2, 4, 9]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Check if symmetric matrix A = [[5, 3, 0], [3, 5, 3], [0, 3, 5]] is orthogonally diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[5, 3, 0], [3, 5, 3], [0, 3, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Orthogonal diagonalization possible:\", np.allclose(A, eigenvectors @ D @ eigenvectors.T))"
  },
  {
    "input": "Diagonalize A = [[3, 1, 2], [1, 3, 1], [2, 1, 3]] and verify its reconstruction.",
    "output": "import numpy as np\n\nA = np.array([[3, 1, 2], [1, 3, 1], [2, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nA_reconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"Reconstruction valid:\", np.allclose(A, A_reconstructed))"
  },
  {
    "input": "Find the eigenvalues and diagonalize A = [[4, 1, -2], [1, 2, 1], [-2, 1, 3]].",
    "output": "import numpy as np\n\nA = np.array([[4, 1, -2], [1, 2, 1], [-2, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Diagonalize the symmetric matrix A = [[7, -3, 1], [-3, 5, 2], [1, 2, 6]] using orthogonal matrix.",
    "output": "import numpy as np\n\nA = np.array([[7, -3, 1], [-3, 5, 2], [1, 2, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Orthogonal matrix P:\\n\", eigenvectors)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Compute the spectral decomposition of A = [[8, 1, -1], [1, 6, 2], [-1, 2, 5]].",
    "output": "import numpy as np\n\nA = np.array([[8, 1, -1], [1, 6, 2], [-1, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\\n\", spectral)"
  },
  {
    "input": "Diagonalize A = [[6, 3, 1], [3, 6, 3], [1, 3, 6]] and verify orthogonality.",
    "output": "import numpy as np\n\nA = np.array([[6, 3, 1], [3, 6, 3], [1, 3, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"P^T P = I:\", np.allclose(eigenvectors.T @ eigenvectors, np.eye(3)))"
  },
  {
    "input": "Verify the spectral theorem for symmetric matrix A = [[4, 2, 2], [2, 4, 2], [2, 2, 4]].",
    "output": "import numpy as np\n\nA = np.array([[4, 2, 2], [2, 4, 2], [2, 2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral theorem valid:\", np.allclose(A, spectral))"
  },
  {
    "input": "Let A = [[9, 3, 0], [3, 9, 3], [0, 3, 9]]. Diagonalize and check reconstruction.",
    "output": "import numpy as np\n\nA = np.array([[9, 3, 0], [3, 9, 3], [0, 3, 9]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"Reconstruction correct:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Find eigenvalues and eigenvectors of symmetric matrix A = [[3, -1, -1], [-1, 3, -1], [-1, -1, 3]].",
    "output": "import numpy as np\n\nA = np.array([[3, -1, -1], [-1, 3, -1], [-1, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Eigenvalues:\\n\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)"
  },
  {
    "input": "Given A = [[2, -2, 1], [-2, 5, -2], [1, -2, 2]], diagonalize and validate the result.",
    "output": "import numpy as np\n\nA = np.array([[2, -2, 1], [-2, 5, -2], [1, -2, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"Diagonalization valid:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Diagonalize A = [[10, 4, 2], [4, 10, 4], [2, 4, 10]] and verify spectral decomposition.",
    "output": "import numpy as np\n\nA = np.array([[10, 4, 2], [4, 10, 4], [2, 4, 10]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition accurate:\", np.allclose(A, spectral))"
  },
  {
    "input": "Verify the orthogonal diagonalization of symmetric matrix A = [[7, -2, 1], [-2, 7, -2], [1, -2, 7]].",
    "output": "import numpy as np\n\nA = np.array([[7, -2, 1], [-2, 7, -2], [1, -2, 7]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Orthogonal diagonalization holds:\", np.allclose(A, eigenvectors @ D @ eigenvectors.T))"
  },
  {
    "input": "Given A = [[4, 2, 2], [2, 4, 2], [2, 2, 4]], find its spectral decomposition and verify correctness.",
    "output": "import numpy as np\n\nA = np.array([[4, 2, 2], [2, 4, 2], [2, 2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nreconstructed = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition correct:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Diagonalize the matrix A = [[2, 0, 1], [0, 3, 0], [1, 0, 2]] and check if the eigenvectors form an orthonormal basis.",
    "output": "import numpy as np\n\nA = np.array([[2, 0, 1], [0, 3, 0], [1, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Orthonormal eigenvectors:\", np.allclose(eigenvectors.T @ eigenvectors, np.eye(3)))"
  },
  {
    "input": "Find the eigenvalues and diagonalize A = [[5, -2, 2], [-2, 5, -2], [2, -2, 5]].",
    "output": "import numpy as np\n\nA = np.array([[5, -2, 2], [-2, 5, -2], [2, -2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Given a symmetric matrix A = [[6, 2, -1], [2, 6, 2], [-1, 2, 6]], perform its spectral decomposition.",
    "output": "import numpy as np\n\nA = np.array([[6, 2, -1], [2, 6, 2], [-1, 2, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition successful:\", np.allclose(A, spectral))"
  },
  {
    "input": "Check if matrix A = [[7, 3, 2], [3, 7, 3], [2, 3, 7]] is orthogonally diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[7, 3, 2], [3, 7, 3], [2, 3, 7]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Orthogonally diagonalizable:\", np.allclose(A, eigenvectors @ D @ eigenvectors.T))"
  },
  {
    "input": "For A = [[10, 5, 0], [5, 10, 5], [0, 5, 10]], diagonalize and validate spectral theorem.",
    "output": "import numpy as np\n\nA = np.array([[10, 5, 0], [5, 10, 5], [0, 5, 10]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral theorem holds:\", np.allclose(A, spectral))"
  },
  {
    "input": "Diagonalize A = [[3, -1, 0], [-1, 3, -1], [0, -1, 3]] and check orthogonality of eigenvectors.",
    "output": "import numpy as np\n\nA = np.array([[3, -1, 0], [-1, 3, -1], [0, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Eigenvectors orthogonal:\", np.allclose(eigenvectors.T @ eigenvectors, np.eye(3)))"
  },
  {
    "input": "Find the spectral decomposition of matrix A = [[12, -6, 0], [-6, 12, -6], [0, -6, 12]].",
    "output": "import numpy as np\n\nA = np.array([[12, -6, 0], [-6, 12, -6], [0, -6, 12]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition valid:\", np.allclose(A, spectral))"
  },
  {
    "input": "Diagonalize A = [[1, 2, 3], [2, 5, 4], [3, 4, 6]] and verify the reconstruction of A from D and P.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [2, 5, 4], [3, 4, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nA_reconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"Reconstruction successful:\", np.allclose(A, A_reconstructed))"
  },
  {
    "input": "Given A = [[4, 0, -2], [0, 5, 0], [-2, 0, 4]], diagonalize and show eigenvectors are orthonormal.",
    "output": "import numpy as np\n\nA = np.array([[4, 0, -2], [0, 5, 0], [-2, 0, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Orthonormal eigenvectors:\", np.allclose(eigenvectors.T @ eigenvectors, np.eye(3)))"
  },
  {
    "input": "Diagonalize the symmetric matrix A = [[6, 2, -2], [2, 3, 1], [-2, 1, 3]].",
    "output": "import numpy as np\n\nA = np.array([[6, 2, -2], [2, 3, 1], [-2, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Orthogonal matrix P:\\n\", eigenvectors)"
  },
  {
    "input": "Given A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]], perform diagonalization and verify reconstruction.",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 0], [1, 2, 1], [0, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nA_check = eigenvectors @ D @ eigenvectors.T\nprint(\"Reconstructed correctly:\", np.allclose(A, A_check))"
  },
  {
    "input": "Compute eigenvalues and diagonalize A = [[5, 2, 0], [2, 3, 1], [0, 1, 4]].",
    "output": "import numpy as np\n\nA = np.array([[5, 2, 0], [2, 3, 1], [0, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\\n\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Verify the spectral theorem for A = [[6, -2, 0], [-2, 3, -1], [0, -1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[6, -2, 0], [-2, 3, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nA_spec = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral theorem valid:\", np.allclose(A, A_spec))"
  },
  {
    "input": "Find the spectral decomposition of matrix A = [[3, 0, 1], [0, 4, 0], [1, 0, 3]].",
    "output": "import numpy as np\n\nA = np.array([[3, 0, 1], [0, 4, 0], [1, 0, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition accurate:\", np.allclose(A, spectral))"
  },
  {
    "input": "Given symmetric matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]], diagonalize it and check orthogonality.",
    "output": "import numpy as np\n\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Orthonormal eigenvectors:\", np.allclose(eigenvectors.T @ eigenvectors, np.eye(3)))"
  },
  {
    "input": "Diagonalize A = [[4, -2, 2], [-2, 4, -2], [2, -2, 4]] and confirm its reconstruction from P and D.",
    "output": "import numpy as np\n\nA = np.array([[4, -2, 2], [-2, 4, -2], [2, -2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nA_check = eigenvectors @ D @ eigenvectors.T\nprint(\"Diagonalization valid:\", np.allclose(A, A_check))"
  },
  {
    "input": "Find the eigenvalues and spectral decomposition of A = [[7, 1, -2], [1, 6, 1], [-2, 1, 7]].",
    "output": "import numpy as np\n\nA = np.array([[7, 1, -2], [1, 6, 1], [-2, 1, 7]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition:\", np.allclose(A, spectral))"
  },
  {
    "input": "Diagonalize symmetric matrix A = [[8, -3, 1], [-3, 8, -3], [1, -3, 8]] and confirm spectral theorem.",
    "output": "import numpy as np\n\nA = np.array([[8, -3, 1], [-3, 8, -3], [1, -3, 8]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nA_spec = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral theorem holds:\", np.allclose(A, A_spec))"
  },
  {
    "input": "Check orthogonal diagonalizability of A = [[3, 1, 1], [1, 3, 1], [1, 1, 3]].",
    "output": "import numpy as np\n\nA = np.array([[3, 1, 1], [1, 3, 1], [1, 1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nreconstructed = eigenvectors @ D @ eigenvectors.T\nprint(\"Orthogonally diagonalizable:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Diagonalize the matrix A = [[2, 1, 1], [1, 2, 1], [1, 1, 2]].",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Find eigenvalues and verify spectral theorem for A = [[9, 3, -3], [3, 9, 3], [-3, 3, 9]].",
    "output": "import numpy as np\n\nA = np.array([[9, 3, -3], [3, 9, 3], [-3, 3, 9]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nreconstructed = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral theorem valid:\", np.allclose(A, reconstructed))"
  },
  {
    "input": "Given symmetric matrix A = [[5, -1, 0], [-1, 5, -1], [0, -1, 5]], compute its spectral decomposition.",
    "output": "import numpy as np\n\nA = np.array([[5, -1, 0], [-1, 5, -1], [0, -1, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition correct:\", np.allclose(A, spectral))"
  },
  {
    "input": "Diagonalize the matrix A = [[3, 0, 0], [0, 4, 1], [0, 1, 4]].",
    "output": "import numpy as np\n\nA = np.array([[3, 0, 0], [0, 4, 1], [0, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Check if A = [[6, 4, 2], [4, 6, 4], [2, 4, 6]] is orthogonally diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[6, 4, 2], [4, 6, 4], [2, 4, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Orthogonally diagonalizable:\", np.allclose(A, eigenvectors @ np.diag(eigenvalues) @ eigenvectors.T))"
  },
  {
    "input": "Find the spectral decomposition of A = [[4, 2, 0], [2, 4, 2], [0, 2, 4]].",
    "output": "import numpy as np\n\nA = np.array([[4, 2, 0], [2, 4, 2], [0, 2, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nA_spec = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition matches:\", np.allclose(A, A_spec))"
  },
  {
    "input": "Diagonalize A = [[2, 2, 1], [2, 3, 2], [1, 2, 2]] and check the orthogonality of eigenvectors.",
    "output": "import numpy as np\n\nA = np.array([[2, 2, 1], [2, 3, 2], [1, 2, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint(\"Eigenvectors are orthogonal:\", np.allclose(eigenvectors.T @ eigenvectors, np.eye(3)))"
  },
  {
    "input": "Compute eigenvalues and spectral form of matrix A = [[5, 1, 1], [1, 5, 1], [1, 1, 5]].",
    "output": "import numpy as np\n\nA = np.array([[5, 1, 1], [1, 5, 1], [1, 1, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nA_spec = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral form holds:\", np.allclose(A, A_spec))"
  },
  {
    "input": "Given A = [[7, 2, -1], [2, 6, 2], [-1, 2, 5]], find its spectral decomposition.",
    "output": "import numpy as np\n\nA = np.array([[7, 2, -1], [2, 6, 2], [-1, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspec = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition correct:\", np.allclose(A, spec))"
  },
  {
    "input": "Diagonalize symmetric matrix A = [[10, -3, 0], [-3, 10, -3], [0, -3, 10]].",
    "output": "import numpy as np\n\nA = np.array([[10, -3, 0], [-3, 10, -3], [0, -3, 10]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Diagonalize the symmetric matrix A = [[5, 2, 2], [2, 5, 2], [2, 2, 5]].",
    "output": "import numpy as np\n\nA = np.array([[5, 2, 2], [2, 5, 2], [2, 2, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Compute eigenvalues and spectral decomposition for A = [[1, 2, 2], [2, 1, 2], [2, 2, 1]].",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 2], [2, 1, 2], [2, 2, 1]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nspectral = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral decomposition accurate:\", np.allclose(A, spectral))"
  },
  {
    "input": "Diagonalize A = [[2, 0, 1], [0, 3, 0], [1, 0, 2]].",
    "output": "import numpy as np\n\nA = np.array([[2, 0, 1], [0, 3, 0], [1, 0, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nD = np.diag(eigenvalues)\nprint(\"Eigenvalues:\\n\", eigenvalues)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Given A = [[6, 1, 0], [1, 6, 1], [0, 1, 6]], find the spectral decomposition and verify it.",
    "output": "import numpy as np\n\nA = np.array([[6, 1, 0], [1, 6, 1], [0, 1, 6]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nA_spec = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral theorem holds:\", np.allclose(A, A_spec))"
  },
  {
    "input": "Check orthogonal diagonalizability of symmetric matrix A = [[7, 2, 1], [2, 7, 2], [1, 2, 7]].",
    "output": "import numpy as np\n\nA = np.array([[7, 2, 1], [2, 7, 2], [1, 2, 7]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nA_diag = eigenvectors @ np.diag(eigenvalues) @ eigenvectors.T\nprint(\"Orthogonally diagonalizable:\", np.allclose(A, A_diag))"
  },
  {
    "input": "Find eigenvalues and verify reconstruction of A = [[4, 1, -1], [1, 4, 1], [-1, 1, 4]].",
    "output": "import numpy as np\n\nA = np.array([[4, 1, -1], [1, 4, 1], [-1, 1, 4]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nA_recon = eigenvectors @ np.diag(eigenvalues) @ eigenvectors.T\nprint(\"Reconstruction correct:\", np.allclose(A, A_recon))"
  },
  {
    "input": "Determine if A = [[1, 1, 0], [0, 1, 1], [0, 0, 1]] is diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1, 0], [0, 1, 1], [0, 0, 1]])\neigenvals = A.eigenvals()\ndiagonalizable = A.is_diagonalizable()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Is A diagonalizable?:\", diagonalizable)"
  },
  {
    "input": "Given A = [[2, 1, 0], [0, 2, 1], [0, 0, 2]], find its Jordan form and explain if it's diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\ndiagonalizable = A.is_diagonalizable()\nprint(\"Jordan form:\\n\", J)\nprint(\"Is A diagonalizable?:\", diagonalizable)"
  },
  {
    "input": "Let A = [[4, -2], [1, 1]]. Find its eigenvalues and determine whether the geometric multiplicity equals algebraic multiplicity.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, -2], [1, 1]])\neigenvals = A.eigenvals(multiple=True)\neigenspaces = [A.eigenvects()]\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Eigenspace info:\", eigenspaces)"
  },
  {
    "input": "Given matrix A = [[3, 1], [0, 3]], is A diagonalizable over \u211d? Also find its Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 1], [0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "For symmetric matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]], find eigenvectors and check orthogonality.",
    "output": "import numpy as np\n\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\northogonality = np.allclose(eigenvectors.T @ eigenvectors, np.eye(3))\nprint(\"Eigenvectors are orthogonal:\", orthogonality)"
  },
  {
    "input": "Diagonalize A = [[6, -2, 2], [-2, 3, -1], [2, -1, 3]] and verify spectral theorem manually.",
    "output": "import numpy as np\n\nA = np.array([[6, -2, 2], [-2, 3, -1], [2, -1, 3]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nA_reconstructed = sum(eigenvalues[i] * np.outer(eigenvectors[:, i], eigenvectors[:, i]) for i in range(3))\nprint(\"Spectral theorem holds:\", np.allclose(A, A_reconstructed))"
  },
  {
    "input": "Let A = [[1, 0, 0], [0, 1, 1], [0, 0, 1]]. Find eigenvalues and test diagonalizability.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 0, 0], [0, 1, 1], [0, 0, 1]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())"
  },
  {
    "input": "Given matrix A = [[0, 1], [0, 0]], explain whether it's diagonalizable and find its Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan Form:\\n\", J)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Let A = [[1, 1], [0, 1]] and B = [[1, 0], [1, 1]]. Are both diagonalizable? Justify.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1], [0, 1]])\nB = sp.Matrix([[1, 0], [1, 1]])\nprint(\"A diagonalizable:\", A.is_diagonalizable())\nprint(\"B diagonalizable:\", B.is_diagonalizable())"
  },
  {
    "input": "Construct a matrix that has eigenvalues 2, 2, and 3, but is not diagonalizable. Then confirm its Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1, 0], [0, 2, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Matrix A:\\n\", A)\nprint(\"Jordan form:\\n\", J)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Create a 3x3 matrix that is diagonalizable but has a repeated eigenvalue.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 0, 0], [0, 2, 1], [0, 0, 3]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())"
  },
  {
    "input": "Given matrix A = [[2, 2], [0, 2]], find a basis of generalized eigenvectors.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 2], [0, 2]])\ngevecs = A.jordan_form(calc_transform=True)[1]\nprint(\"Generalized eigenvectors basis (columns of P):\\n\", gevecs)"
  },
  {
    "input": "Is the matrix A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]] diagonalizable? Explain using its Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a symmetric matrix with repeated eigenvalues and verify eigenvectors are still orthogonal.",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigvals, eigvecs = np.linalg.eigh(A)\northogonal = np.allclose(eigvecs.T @ eigvecs, np.eye(3))\nprint(\"Eigenvectors orthogonal:\", orthogonal)"
  },
  {
    "input": "Diagonalize A = [[4, 0, 0], [0, 4, 1], [0, 0, 4]] and explain if it\u2019s defective.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 0, 0], [0, 4, 1], [0, 0, 4]])\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())\nprint(\"Jordan form:\\n\", A.jordan_form()[0])"
  },
  {
    "input": "Does matrix A = [[3, 0, 0], [0, 3, 0], [0, 1, 3]] have a full set of eigenvectors?",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 0, 0], [0, 3, 0], [0, 1, 3]])\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())\nprint(\"Eigenvectors:\\n\", A.eigenvects())"
  },
  {
    "input": "Given A = [[1, 2, 3], [0, 1, 4], [0, 0, 1]], show that it is not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 2, 3], [0, 1, 4], [0, 0, 1]])\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())\nprint(\"Jordan form:\\n\", A.jordan_form()[0])"
  },
  {
    "input": "Find a 3x3 matrix with eigenvalue 5 of multiplicity 3 that is not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, 1, 0], [0, 5, 1], [0, 0, 5]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Given symmetric matrix A = [[1, -1, 0], [-1, 2, -1], [0, -1, 1]], verify it\u2019s orthogonally diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[1, -1, 0], [-1, 2, -1], [0, -1, 1]])\neigvals, eigvecs = np.linalg.eigh(A)\nA_diag = eigvecs @ np.diag(eigvals) @ eigvecs.T\nprint(\"Orthogonally diagonalizable:\", np.allclose(A, A_diag))"
  },
  {
    "input": "For matrix A = [[0, 1], [-2, -3]], compute its eigenvalues and determine if it\u2019s diagonalizable over \u211d.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [-2, -3]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable over \u211d?:\", A.is_diagonalizable())"
  },
  {
    "input": "Given matrix A = [[0, -1], [1, 0]], check if it's diagonalizable over \u211d and \u2102.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -1], [1, 0]])\nprint(\"Diagonalizable over \u211d:\", A.is_diagonalizable(domain=sp.S.Reals))\nprint(\"Diagonalizable over \u2102:\", A.is_diagonalizable(domain=sp.S.Complexes))"
  },
  {
    "input": "Construct a real matrix with complex eigenvalues and verify it is still diagonalizable over \u2102.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -1], [1, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Diagonalizable over \u2102:\", A.is_diagonalizable(domain=sp.S.Complexes))"
  },
  {
    "input": "For A = [[1, 2, 3], [0, 1, 4], [0, 0, 1]], check if it's diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 2, 3], [0, 1, 4], [0, 0, 1]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Find a matrix with eigenvalues 1 and -1, but it is not diagonalizable over \u211d.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1], [0, 1]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Given matrix A = [[2, 1, 0], [0, 2, 0], [0, 0, 3]], compute the eigenspaces and determine if A is defective.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1, 0], [0, 2, 0], [0, 0, 3]])\nprint(\"Eigenvectors:\\n\", A.eigenvects())\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())"
  },
  {
    "input": "Let A = [[2, 0], [0, 2]] and B = [[2, 1], [0, 2]]. Both have same eigenvalues. Are both diagonalizable?",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 0], [0, 2]])\nB = sp.Matrix([[2, 1], [0, 2]])\nprint(\"A diagonalizable:\", A.is_diagonalizable())\nprint(\"B diagonalizable:\", B.is_diagonalizable())"
  },
  {
    "input": "Is the identity matrix I\u2084 diagonalizable? Construct it and prove using Python.",
    "output": "import sympy as sp\n\nA = sp.eye(4)\nprint(\"Is I\u2084 diagonalizable?:\", A.is_diagonalizable())"
  },
  {
    "input": "Diagonalize A = [[1, 2], [2, 1]] and verify the diagonalization using inverse transformation.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 1]])\neigvals, eigvecs = np.linalg.eig(A)\nP = eigvecs\nD = np.diag(eigvals)\nA_check = P @ D @ np.linalg.inv(P)\nprint(\"Diagonalization correct:\", np.allclose(A, A_check))"
  },
  {
    "input": "Construct a diagonalizable matrix whose eigenvectors are not orthogonal. Prove with code.",
    "output": "import numpy as np\n\nA = np.array([[3, 1], [0, 2]])\neigvals, eigvecs = np.linalg.eig(A)\northogonality = np.allclose(eigvecs.T @ eigvecs, np.eye(2))\nprint(\"Eigenvectors orthogonal:\", orthogonality)\nprint(\"Is A diagonalizable:\", np.linalg.matrix_rank(eigvecs) == 2)"
  },
  {
    "input": "Let A be a 3x3 matrix with distinct real eigenvalues. Construct such a matrix and show it's diagonalizable.",
    "output": "import numpy as np\n\nA = np.array([[1, 2, 3], [0, 4, 5], [0, 0, 6]])\neigvals, eigvecs = np.linalg.eig(A)\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Is A diagonalizable:\", np.linalg.matrix_rank(eigvecs) == 3)"
  },
  {
    "input": "Given matrix A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]], prove it is not diagonalizable and find its Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())"
  },
  {
    "input": "Find a matrix with all eigenvalues 0 but still not diagonalizable. Show eigenvectors.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [0, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())\nprint(\"Eigenvectors:\\n\", A.eigenvects())"
  },
  {
    "input": "Let A = [[6, 2], [2, 3]]. Diagonalize it and verify the orthogonality of eigenvectors.",
    "output": "import numpy as np\n\nA = np.array([[6, 2], [2, 3]])\neigvals, eigvecs = np.linalg.eigh(A)\northogonal = np.allclose(eigvecs.T @ eigvecs, np.eye(2))\nprint(\"Orthogonality:\", orthogonal)"
  },
  {
    "input": "Construct a 3x3 nilpotent matrix and check if it's diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nprint(\"A^3 =\\n\", A**3)\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())"
  },
  {
    "input": "Given A = [[4, 1], [0, 4]], determine if it\u2019s diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 1], [0, 4]])\neigenvals = A.eigenvals()\ndiagonalizable = A.is_diagonalizable()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Is diagonalizable?:\", diagonalizable)"
  },
  {
    "input": "Let A be a matrix with algebraic multiplicity greater than geometric multiplicity. Give such a matrix and prove it\u2019s not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 1], [0, 3]])\nprint(\"Eigenvectors:\\n\", A.eigenvects())\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())"
  },
  {
    "input": "For A = [[2, 2], [0, 2]], diagonalize it if possible and give the transformation matrix.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 2], [0, 2]])\nif A.is_diagonalizable():\n    D, P = A.diagonalize()\n    print(\"Diagonal matrix D:\\n\", D)\n    print(\"Transformation matrix P:\\n\", P)\nelse:\n    print(\"Matrix is not diagonalizable.\")"
  },
  {
    "input": "Check if A = [[0, 1], [-1, 0]] is orthogonally diagonalizable over \u211d.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [-1, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable over \u211d?:\", A.is_diagonalizable(domain=sp.S.Reals))"
  },
  {
    "input": "Construct a symmetric 3x3 matrix with repeated eigenvalues and verify diagonalization is possible via orthogonal matrix.",
    "output": "import numpy as np\n\nA = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\neigvals, eigvecs = np.linalg.eigh(A)\nP = eigvecs\nD = np.diag(eigvals)\nA_check = P @ D @ P.T\nprint(\"Orthogonal diagonalization successful:\", np.allclose(A, A_check))"
  },
  {
    "input": "Create a 3x3 matrix with complex eigenvalues and check diagonalizability over \u2102.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -1, 0], [1, 0, 0], [0, 0, 2]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable over \u2102?:\", A.is_diagonalizable(domain=sp.S.Complexes))"
  },
  {
    "input": "Construct a 3x3 matrix A that is not diagonalizable but has only one eigenvalue.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())"
  },
  {
    "input": "Find the matrix exponential of a diagonalizable matrix A = [[2, 0], [0, 3]] using its diagonal form.",
    "output": "import numpy as np\nfrom scipy.linalg import expm\n\nA = np.array([[2, 0], [0, 3]])\nexpA = expm(A)\nprint(\"Matrix exponential of A:\\n\", expA)"
  },
  {
    "input": "Find a matrix whose minimal polynomial has higher degree than its characteristic polynomial.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\n\n# Characteristic polynomial\nchar_poly = A.charpoly().as_expr()\n\n# Check when A^k = 0 to determine minimal polynomial\nk = 1\npower = A\nwhile not power.equals(sp.zeros(*A.shape)):\n    k += 1\n    power = A**k\n\nprint(\"Characteristic polynomial:\", char_poly)\nprint(f\"Minimal polynomial: x^{k}\")"
  },
  {
    "input": "Given A = [[1, 2], [2, 1]], verify that it is symmetric and find an orthonormal basis of eigenvectors.",
    "output": "import numpy as np\n\nA = np.array([[1, 2], [2, 1]])\neigvals, eigvecs = np.linalg.eigh(A)\nprint(\"Orthonormal basis (columns of eigvecs):\\n\", eigvecs)"
  },
  {
    "input": "Create a matrix with complex eigenvalues and demonstrate diagonalization over \u2102 using sympy.",
    "output": "import sympy as sp\n\nA = sp.ImmutableMatrix([[0, -1], [1, 0]])\neigenvals = A.eigenvals()\nD, P = A.diagonalize()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Transformation matrix P:\\n\", P)"
  },
  {
    "input": "Check if a matrix A = [[1, 2], [3, 4]] is diagonalizable and return the diagonal form if it is.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 2], [3, 4]])\nif A.is_diagonalizable():\n    D, P = A.diagonalize()\n    print(\"Diagonal form:\\n\", D)\nelse:\n    print(\"Matrix is not diagonalizable\")"
  },
  {
    "input": "Construct a 3x3 matrix with linearly dependent eigenvectors and verify it's not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, 4, 2], [0, 5, 1], [0, 0, 5]])\nprint(\"Eigenvectors:\\n\", A.eigenvects())\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())"
  },
  {
    "input": "Given A = [[1, 0], [0, -1]], confirm it's orthogonally diagonalizable and verify with eigen-decomposition.",
    "output": "import numpy as np\n\nA = np.array([[1, 0], [0, -1]])\neigvals, eigvecs = np.linalg.eigh(A)\nA_reconstructed = eigvecs @ np.diag(eigvals) @ eigvecs.T\nprint(\"Orthogonally diagonalizable:\", np.allclose(A, A_reconstructed))"
  },
  {
    "input": "Create a defective matrix and show that its geometric multiplicity is less than algebraic multiplicity.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 1], [0, 3]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Eigenvectors:\\n\", A.eigenvects())"
  },
  {
    "input": "Show that any orthogonal matrix with real entries and determinant 1 is diagonalizable over \u2102.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -1], [1, 0]])\nprint(\"Determinant:\", A.det())\nprint(\"Diagonalizable over \u2102:\", A.is_diagonalizable(domain=sp.S.Complexes))"
  },
  {
    "input": "Construct a real matrix with complex eigenvalues but with a real minimal polynomial.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -1], [1, 0]])\n\n# Eigenvalues\nprint(\"Eigenvalues:\", A.eigenvals())\n\n# Check minimal polynomial manually\nA2 = A**2\nif A2 == -sp.eye(2):\n    print(\"Minimal polynomial: x^2 + 1\")\nelse:\n    print(\"Minimal polynomial is of higher degree\")"
  },
  {
    "input": "Diagonalize a 2x2 matrix with repeated eigenvalues and verify if it's still diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 0], [0, 2]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is A diagonalizable?:\", A.is_diagonalizable())"
  },
  {
    "input": "Check if a stochastic matrix A = [[0.5, 0.5], [0.5, 0.5]] is diagonalizable and find its eigenvalues.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0.5, 0.5], [0.5, 0.5]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a Hermitian matrix and show it's always diagonalizable with real eigenvalues.",
    "output": "import numpy as np\n\nA = np.array([[2, 1+1j], [1-1j, 3]])\neigvals, eigvecs = np.linalg.eigh(A)\nprint(\"Eigenvalues:\", eigvals)\nprint(\"Is Hermitian:\", np.allclose(A, A.conj().T))"
  },
  {
    "input": "Construct a matrix with algebraic multiplicity 3 for eigenvalue 5, but geometric multiplicity 1.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, 1, 0], [0, 5, 1], [0, 0, 5]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Given A = [[2, 1], [0, 2]], compute its exponential using Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1], [0, 2]])\nJ, P = A.jordan_form()\nexpJ = (J * sp.Symbol('t')).exp()\nexpA = P * expJ * P.inv()\nprint(\"Matrix exponential e^(At):\\n\", expA)"
  },
  {
    "input": "Create a 2x2 matrix with real entries that has complex eigenvalues, and diagonalize it over \u2102.",
    "output": "import sympy as sp\n\nA = sp.ImmutableMatrix([[0, -2], [2, 0]])\neigenvals = A.eigenvals()\nD, P = A.diagonalize()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Diagonal form over \u2102:\\n\", D)\nprint(\"Transformation matrix:\\n\", P)"
  },
  {
    "input": "Show that a matrix with orthonormal eigenvectors must be symmetric.",
    "output": "import numpy as np\n\nA = np.array([[2, -1], [-1, 2]])\neigvals, eigvecs = np.linalg.eigh(A)\nprint(\"Orthonormal eigenvectors (columns of V):\\n\", eigvecs)\nprint(\"Is A symmetric:\", np.allclose(A, A.T))"
  },
  {
    "input": "Let A be a matrix such that A^2 = I but A \u2260 I. Construct such a matrix and verify its eigenvalues.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [1, 0]])\nprint(\"A^2:\", A**2)\nprint(\"Eigenvalues:\", A.eigenvals())"
  },
  {
    "input": "Given a projection matrix A = [[1, 0], [0, 0]], show it is diagonalizable and find eigenvalues.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 0], [0, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a non-symmetric matrix with real eigenvalues and diagonalize it.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 2], [0, 1]])\nD, P = A.diagonalize()\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Transformation matrix P:\\n\", P)"
  },
  {
    "input": "Let A = [[0, 2], [-2, 0]]. Show that the eigenvalues are purely imaginary and it\u2019s diagonalizable over \u2102.",
    "output": "import sympy as sp\n\nA = sp.ImmutableMatrix([[0, 2], [-2, 0]])\neigenvals = A.eigenvals()\nD, P = A.diagonalize()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Find a matrix that is similar to a diagonal matrix but not orthogonally diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1], [0, 2]])\nprint(\"Is similar to diagonal (diagonalizable)?:\", A.is_diagonalizable())\nprint(\"Is symmetric (orthogonally diagonalizable)?:\", A == A.T)"
  },
  {
    "input": "Create a diagonalizable matrix with repeated eigenvalues and linearly independent eigenvectors.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 0, 0], [0, 2, 1], [0, 0, 2]])\nprint(\"Eigenvectors:\\n\", A.eigenvects())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a real matrix with eigenvalues 0 and 1 that is not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1], [0, 1]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Diagonalize a matrix A = [[1, 1, 0], [0, 1, 0], [0, 0, 2]] and verify similarity transformation.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1, 0], [0, 1, 0], [0, 0, 2]])\nif A.is_diagonalizable():\n    D, P = A.diagonalize()\n    A_check = P * D * P.inv()\n    print(\"Similarity transformation correct:\", A.equals(A_check))"
  },
  {
    "input": "Verify that a projection matrix satisfies A^2 = A and find its eigenvalues.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 0], [0, 0]])\nprint(\"A^2 == A:\", A**2 == A)\nprint(\"Eigenvalues:\", A.eigenvals())"
  },
  {
    "input": "Let A be a matrix where every vector is an eigenvector. Construct such a matrix and justify.",
    "output": "import sympy as sp\n\nA = sp.eye(3)\nprint(\"Is A scalar multiple of identity:\", A == sp.eye(3))\nprint(\"Eigenvalues:\", A.eigenvals())"
  },
  {
    "input": "Create a matrix with no real eigenvalues and show it's not diagonalizable over \u211d.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -1], [1, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable over \u211d:\", A.is_diagonalizable(domain=sp.S.Reals))"
  },
  {
    "input": "Verify that an upper triangular matrix has its eigenvalues on the diagonal and attempt diagonalization.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 2, 1], [0, 4, 2], [0, 0, 4]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a 3x3 matrix that is diagonalizable but not symmetric.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1, 0], [0, 2, 0], [0, 0, 3]])\nprint(\"Is symmetric:\", A == A.T)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Let A = [[3, 0, 0], [0, 3, 1], [0, 0, 3]]. Show that it's not diagonalizable and find its Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 0, 0], [0, 3, 1], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Create a non-zero matrix with all eigenvalues equal to zero and check its diagonalizability.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [0, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Given A = [[4, 1], [0, 4]], verify that it's not diagonalizable and compute its exponential using Jordan form.",
    "output": "import sympy as sp\n\nt = sp.Symbol('t')\nA = sp.Matrix([[4, 1], [0, 4]])\nJ, P = A.jordan_form()\nexpJ = (J * t).exp()\nexpA = P * expJ * P.inv()\nprint(\"e^(At):\\n\", expA)"
  },
  {
    "input": "Let A = [[1, 2], [-2, 1]]. Show it's a rotation matrix and verify complex eigenvalues.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 2], [-2, 1]])\nprint(\"Determinant:\", A.det())\nprint(\"Eigenvalues:\", A.eigenvals())"
  },
  {
    "input": "Construct a 2x2 nilpotent matrix and verify that its minimal polynomial is x^2.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [0, 0]])\n\n# Check nilpotency\nA_squared = A**2\nprint(\"A^2 =\\n\", A_squared)\nprint(\"Nilpotency (A^2 == 0):\", A_squared == sp.zeros(2))\n\n# Since A \u2260 0 and A^2 = 0, the minimal polynomial is x^2\nprint(\"Minimal polynomial: x^2\")"
  },
  {
    "input": "Create a matrix whose eigenvectors form a non-orthogonal basis and verify it's still diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, -2], [2, 1]])\nprint(\"Is diagonalizable:\", A.is_diagonalizable())\nprint(\"Is symmetric:\", A == A.T)"
  },
  {
    "input": "Let A be a real matrix with complex eigenvalues. Compute its real Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -1], [1, 0]])\nJ, P = A.jordan_form()\nprint(\"Real Jordan form:\\n\", J)"
  },
  {
    "input": "Construct a 3x3 diagonal matrix with distinct eigenvalues and verify its diagonalizability.",
    "output": "import sympy as sp\n\nA = sp.diag(2, 4, 6)\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Verify that any matrix with n distinct eigenvalues is diagonalizable by constructing one.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 0, 0], [0, 2, 0], [0, 0, 3]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a 3x3 real matrix with a complex conjugate pair of eigenvalues and one real eigenvalue.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, -1, 0], [1, 1, 0], [0, 0, 2]])\nprint(\"Eigenvalues:\", A.eigenvals())"
  },
  {
    "input": "Let A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]]. Verify that it's nilpotent and not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nprint(\"Is nilpotent (A^3 = 0):\", A**3 == sp.zeros(3))\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Diagonalize A = [[2, 0, 0], [0, 3, 4], [0, 0, 3]] and verify eigenvalue multiplicity and eigenspace dimension.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 0, 0], [0, 3, 4], [0, 0, 3]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Diagonalizable:\", A.is_diagonalizable())\nprint(\"Eigenvectors:\\n\", A.eigenvects())"
  },
  {
    "input": "Construct a matrix with minimal polynomial (x-2)^2 and characteristic polynomial (x-2)^3.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\n\n# Characteristic polynomial\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\n\n# Check powers to determine minimal polynomial\nI = sp.eye(3)\nB = A - 2 * I\nprint(\"(A - 2I)^1 =\\n\", B)\nprint(\"(A - 2I)^2 =\\n\", B**2)\nprint(\"(A - 2I)^3 =\\n\", B**3)\n\n# Since (A - 2I)^2 != 0 but (A - 2I)^3 == 0, minimal polynomial is (x - 2)^3\nprint(\"Minimal polynomial: (x - 2)^3\")"
  },
  {
    "input": "Create a 2x2 orthogonal matrix with determinant -1 and find its eigenvalues.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [1, 0]])\nprint(\"Is orthogonal:\", A.T * A == sp.eye(2))\nprint(\"Determinant:\", A.det())\nprint(\"Eigenvalues:\", A.eigenvals())"
  },
  {
    "input": "Let A = [[3, -4], [1, -1]]. Check if it's diagonalizable over \u211d or \u2102.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, -4], [1, -1]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Diagonalizable over \u2102:\", A.is_diagonalizable(domain=sp.S.Complexes))"
  },
  {
    "input": "Construct a matrix with an eigenvalue of multiplicity 2 but a 1D eigenspace.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 1], [0, 4]])\nprint(\"Eigenvectors:\", A.eigenvects())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Given A = [[6, 2], [0, 6]], show that A is not symmetric but is similar to a diagonal matrix.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[6, 2], [0, 6]])\nprint(\"Is symmetric:\", A == A.T)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Diagonalize a matrix A = [[1, 0], [1, 1]] and show it has one eigenvector.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 0], [1, 1]])\nprint(\"Eigenvectors:\", A.eigenvects())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a non-diagonalizable matrix with a non-trivial Jordan block.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan Form:\\n\", J)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a real 3x3 matrix that is defective (i.e., not diagonalizable).",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, 1, 0], [0, 5, 1], [0, 0, 5]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Given A = [[2, 1], [0, 2]], compute the matrix exponential using its Jordan form.",
    "output": "import sympy as sp\n\nt = sp.Symbol('t')\nA = sp.Matrix([[2, 1], [0, 2]])\nJ, P = A.jordan_form()\nexpJ = (J * t).exp()\nexpA = P * expJ * P.inv()\nprint(\"e^(At):\\n\", expA.simplify())"
  },
  {
    "input": "Create a real matrix with complex eigenvalues and check that it is not diagonalizable over \u211d.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -2], [2, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Diagonalizable over \u211d:\", A.is_diagonalizable(domain=sp.S.Reals))"
  },
  {
    "input": "Find a matrix with a single eigenvalue and no basis of eigenvectors.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[7, 1, 0], [0, 7, 1], [0, 0, 7]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a 2x2 symmetric matrix and verify it's orthogonally diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 1], [1, 3]])\nQ, D = A.diagonalize()\nprint(\"Orthogonal?:\", Q.T * Q == sp.eye(2))\nprint(\"Diagonal matrix D:\\n\", D)"
  },
  {
    "input": "Diagonalize a symmetric matrix with repeated eigenvalues and show eigenvectors are orthogonal.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 0], [0, 2]])\nQ, D = A.diagonalize()\nprint(\"Q^T * Q = I:\", Q.T * Q == sp.eye(2))"
  },
  {
    "input": "Find a matrix whose minimal polynomial equals its characteristic polynomial and diagonalize it.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 0], [0, 2]])\n\n# Characteristic polynomial\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\n\n# Since A is diagonal with distinct eigenvalues, it is diagonalizable\nprint(\"Minimal polynomial:\", char_poly)\nprint(\"Diagonalizable:\", A.is_diagonalizable())\n\n# Diagonalization\nP, D = A.diagonalize()\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Transformation matrix P:\\n\", P)"
  },
  {
    "input": "Let A = [[3, 2], [2, 3]]. Show that it's symmetric and find orthonormal eigenvectors.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 2], [2, 3]])\nQ, D = A.diagonalize()\nprint(\"Orthonormal Q?:\", Q.T * Q == sp.eye(2))\nprint(\"Eigenvectors matrix Q:\\n\", Q)"
  },
  {
    "input": "Find a matrix that is diagonalizable but not over the reals.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -1], [1, 0]])\nprint(\"Diagonalizable over \u2102:\", A.is_diagonalizable(domain=sp.S.Complexes))\nprint(\"Diagonalizable over \u211d:\", A.is_diagonalizable(domain=sp.S.Reals))"
  },
  {
    "input": "Construct a matrix A such that A^2 = I but A \u2260 I and diagonalize it.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [1, 0]])\nprint(\"A^2 == I:\", A**2 == sp.eye(2))\nD, P = A.diagonalize()\nprint(\"Diagonal form:\\n\", D)"
  },
  {
    "input": "Construct a matrix with a repeated eigenvalue but a complete basis of eigenvectors.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 0], [0, 2]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Let A = [[1, 1], [0, 1]]. Show its minimal polynomial and that it's not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1], [0, 1]])\n\n# Characteristic polynomial\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\n\n# Try diagonalizing\nprint(\"Is diagonalizable:\", A.is_diagonalizable())\n\n# Manually check the minimal polynomial:\n# Try (A - I)^2\nI = sp.eye(2)\nM = A - I\nprint(\"(A - I)^2:\", (M @ M))\n\nprint(\"Minimal polynomial is (x - 1)^2\")"
  },
  {
    "input": "Construct a 3x3 matrix with eigenvalues 1 (multiplicity 2) and 2, but not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1, 0], [0, 1, 0], [0, 0, 2]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Create a matrix that is diagonalizable over \u2102 but not over \u211d.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -1], [1, 0]])\nprint(\"Diagonalizable over \u2102:\", A.is_diagonalizable(domain=sp.S.Complexes))\nprint(\"Diagonalizable over \u211d:\", A.is_diagonalizable(domain=sp.S.Reals))"
  },
  {
    "input": "Find a 2x2 matrix where eigenvectors are not orthogonal, even though it is diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 1], [0, 2]])\nprint(\"Is symmetric:\", A == A.T)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Let A = [[5, 1, 0], [0, 5, 0], [0, 0, 3]]. Check if it is diagonalizable and compute eigenvectors.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, 1, 0], [0, 5, 0], [0, 0, 3]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Eigenvectors:\", A.eigenvects())\nprint(\"Diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a symmetric matrix whose eigenvectors form an orthonormal basis.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, -1], [-1, 2]])\nQ, D = A.diagonalize()\nprint(\"Orthogonal Q:\", Q.T * Q == sp.eye(2))"
  },
  {
    "input": "Let A = [[1, 2], [0, 1]]. Compute its Jordan form and verify it's not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 2], [0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Create a real 2x2 matrix whose eigenvalues are purely imaginary and diagonalize it over \u2102.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -2], [2, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Diagonalizable over \u2102:\", A.is_diagonalizable(domain=sp.S.Complexes))"
  },
  {
    "input": "Construct a non-zero nilpotent matrix and find its minimal polynomial.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nprint(\"A^3 == 0:\", A**3 == sp.zeros(3))\nprint(\"A^2 == 0:\", A**2 == sp.zeros(3))\n\n# Since A^3 = 0 but A^2 \u2260 0, minimal polynomial is x^3\nprint(\"Minimal polynomial is x^3\")"
  },
  {
    "input": "Create a 3x3 matrix with a 2-dimensional eigenspace for a repeated eigenvalue.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 0, 0], [0, 2, 0], [0, 0, 3]])\nprint(\"Eigenvectors:\", A.eigenvects())"
  },
  {
    "input": "Let A = [[6, 1, 0], [0, 6, 0], [0, 0, 5]]. Determine if A is diagonalizable and compute its Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[6, 1, 0], [0, 6, 0], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Find a matrix A such that A^2 = 0 but A \u2260 0 and is not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [0, 0]])\nprint(\"A^2 = 0:\", A**2 == sp.zeros(2))\nprint(\"Diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a symmetric matrix with distinct eigenvalues and verify orthogonal diagonalization.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 1], [1, 2]])\nQ, D = A.diagonalize()\nprint(\"Q^T * Q = I:\", Q.T * Q == sp.eye(2))\nprint(\"Diagonal D:\\n\", D)"
  },
  {
    "input": "Let A = [[1, 2], [0, 1]]. Find the minimal polynomial and Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 2], [0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\n\n# Manually deduce minimal polynomial\n# Since (A - I)^2 = 0 but (A - I) \u2260 0, minimal polynomial is (x - 1)^2\nprint(\"Minimal polynomial is (x - 1)^2\")"
  },
  {
    "input": "Construct a matrix with all zero eigenvalues but not the zero matrix.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [0, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())"
  },
  {
    "input": "Diagonalize a 3x3 matrix with distinct eigenvalues and verify the result.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 0, 0], [0, 5, 0], [0, 0, 6]])\nP, D = A.diagonalize()\nprint(\"D:\\n\", D)\nprint(\"P:\\n\", P)\nprint(\"P\u207b\u00b9AP = D:\", P.inv() * A * P == D)"
  },
  {
    "input": "Construct a matrix with a single eigenvalue but a full set of linearly independent eigenvectors.",
    "output": "import sympy as sp\n\nA = sp.eye(3) * 2\nprint(\"Eigenvectors:\", A.eigenvects())\nprint(\"Diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Find a 2x2 matrix that is both nilpotent and not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [0, 0]])\nprint(\"A^2 = 0:\", A**2 == sp.zeros(2))\nprint(\"Diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Let A = [[2, 1, 0], [0, 2, 0], [0, 0, 3]]. Find its eigenvalues and Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1, 0], [0, 2, 0], [0, 0, 3]])\nprint(\"Eigenvalues:\", A.eigenvals())\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)"
  },
  {
    "input": "Let A = [[2, 1], [0, 2]]. Verify that A is not diagonalizable but compute its Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1], [0, 2]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a 3x3 matrix with two Jordan blocks for the same eigenvalue.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, 1, 0], [0, 5, 0], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)"
  },
  {
    "input": "Find a 2x2 matrix with purely imaginary complex eigenvalues and show it\u2019s diagonalizable over \u2102.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -1], [1, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Diagonalizable over \u2102:\", A.is_diagonalizable(domain=sp.S.Complexes))"
  },
  {
    "input": "Construct a 2x2 matrix with one eigenvalue and algebraic multiplicity 2, geometric multiplicity 1.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 1], [0, 3]])\nprint(\"Eigenvectors:\", A.eigenvects())\nprint(\"Diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Find the minimal polynomial of a matrix A = [[2, 1, 0], [0, 2, 1], [0, 0, 2]].",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\n\n# Since A is upper triangular with repeated eigenvalue 2,\n# and (A - 2*I)^3 = 0 but (A - 2*I)^2 \u2260 0,\n# the minimal polynomial is (x - 2)^3\n\nx = sp.symbols('x')\nchar_poly = A.charpoly(x)\nprint(\"Characteristic polynomial:\", char_poly.as_expr())\n\nprint(\"Minimal polynomial is (x - 2)^3\")"
  },
  {
    "input": "Diagonalize the matrix A = [[1, 1], [0, 2]] and verify A = PDP\u207b\u00b9.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1], [0, 2]])\nP, D = A.diagonalize()\nprint(\"D =\\n\", D)\nprint(\"A = PDP\u207b\u00b9:\", (P * D * P.inv()).equals(A))"
  },
  {
    "input": "Let A = [[0, 1], [-2, -3]]. Find the eigenvalues and check diagonalizability.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [-2, -3]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a symmetric matrix and confirm eigenvectors are orthogonal.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 2], [2, 3]])\nQ, D = A.diagonalize()\nprint(\"Q^T * Q = I:\", Q.T * Q == sp.eye(2))"
  },
  {
    "input": "Let A = [[1, 1, 0], [0, 1, 0], [0, 0, 2]]. Find its eigenvalues and Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1, 0], [0, 1, 0], [0, 0, 2]])\nprint(\"Eigenvalues:\", A.eigenvals())\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)"
  },
  {
    "input": "Create a non-diagonalizable matrix with all eigenvalues equal and show its minimal polynomial.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[7, 1], [0, 7]])\nx = sp.symbols('x')\nchar_poly = A.charpoly(x)\nprint(\"Characteristic polynomial:\", char_poly.as_expr())\n\n# Since (A - 7*I)^2 = 0, but (A - 7*I) \u2260 0, the minimal polynomial is (x - 7)^2\nprint(\"Minimal polynomial is (x - 7)^2\")\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a matrix with real entries and complex eigenvalues.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -3], [3, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())"
  },
  {
    "input": "Create a matrix that is not symmetric but still diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 1], [0, 2]])\nprint(\"Is symmetric:\", A == A.T)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Let A = [[0, 1], [-1, 0]]. Verify it has purely imaginary eigenvalues and is unitary.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [-1, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"A^T * A = I:\", (A.T * A).equals(sp.eye(2)))"
  },
  {
    "input": "Construct a nilpotent matrix of order 3 and verify its minimal polynomial.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nprint(\"A^3 = 0:\", A**3 == sp.zeros(3))\nprint(\"A^2 = 0:\", A**2 == sp.zeros(3))\nprint(\"A \u2260 0:\", A != sp.zeros(3))\n\n# Since A^3 = 0, A^2 \u2260 0, and A \u2260 0, the minimal polynomial is x^3\nprint(\"Minimal polynomial is x^3\")"
  },
  {
    "input": "Diagonalize a 3x3 matrix with repeated eigenvalues and independent eigenvectors.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 0, 0], [0, 2, 0], [0, 0, 3]])\nP, D = A.diagonalize()\nprint(\"D:\\n\", D)"
  },
  {
    "input": "Create a real matrix that is not diagonalizable over \u211d but is over \u2102.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -2], [2, 0]])\nprint(\"Diagonalizable over \u211d:\", A.is_diagonalizable(domain=sp.S.Reals))\nprint(\"Diagonalizable over \u2102:\", A.is_diagonalizable(domain=sp.S.Complexes))"
  },
  {
    "input": "Find a 2x2 matrix with minimal polynomial different from its characteristic polynomial.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 1], [0, 4]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\n\n# Check powers to deduce minimal polynomial\nI = sp.eye(2)\nprint(\"(A - 4I)^2 = 0:\", (A - 4*I)**2 == sp.zeros(2))\nprint(\"(A - 4I) \u2260 0:\", (A - 4*I) != sp.zeros(2))\n\n# Since (A - 4I)^2 = 0 and (A - 4I) \u2260 0, minimal polynomial is (x - 4)^2\nprint(\"Minimal polynomial is (x - 4)^2\")"
  },
  {
    "input": "Construct a matrix that is diagonalizable but not normal.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 1], [0, 2]])\nprint(\"Is diagonalizable:\", A.is_diagonalizable())\nprint(\"Is normal:\", (A * A.T).equals(A.T * A))"
  },
  {
    "input": "Let A = [[1, 1, 1], [0, 1, 1], [0, 0, 1]]. Compute its Jordan form and verify it is not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1, 1], [0, 1, 1], [0, 0, 1]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Find a matrix with eigenvalues 1, 1, 1 but only one linearly independent eigenvector.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1, 0], [0, 1, 1], [0, 0, 1]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Eigenvectors:\", A.eigenvects())"
  },
  {
    "input": "Construct a 3x3 matrix that is nilpotent and has only one eigenvalue.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"A^3 = 0:\", A**3 == sp.zeros(3))"
  },
  {
    "input": "Let A = [[2, 1, 0], [0, 2, 1], [0, 0, 2]]. Check if A is diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1, 0], [0, 2, 1], [0, 0, 2]])\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Create a matrix with eigenvalue 0 and verify if it's diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.ImmutableMatrix([[0, 1], [0, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Let A = [[1, 2], [2, 1]]. Verify if it is symmetric and compute eigenvalues.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 2], [2, 1]])\nprint(\"Is symmetric:\", A == A.T)\nprint(\"Eigenvalues:\", A.eigenvals())"
  },
  {
    "input": "Find the Jordan form of A = [[6, 1, 0], [0, 6, 1], [0, 0, 6]].",
    "output": "import sympy as sp\n\nA = sp.ImmutableMatrix([[6, 1, 0], [0, 6, 1], [0, 0, 6]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Transformation matrix P:\\n\", P)"
  },
  {
    "input": "Create a 3x3 matrix with one eigenvalue and three linearly independent eigenvectors.",
    "output": "import sympy as sp\n\nA = sp.eye(3) * 4\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Eigenvectors:\", A.eigenvects())"
  },
  {
    "input": "Construct a matrix whose characteristic and minimal polynomials are equal.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 0], [0, 4]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\n\n# Since A is diagonal with distinct eigenvalues, minimal polynomial equals characteristic polynomial\nprint(\"Minimal polynomial:\", char_poly)"
  },
  {
    "input": "Find a real matrix with complex eigenvalues and verify it's not diagonalizable over \u211d.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -2], [2, 0]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Diagonalizable over \u211d:\", A.is_diagonalizable(domain=sp.S.Reals))"
  },
  {
    "input": "Let A = [[1, 1], [0, 1]]. Show its minimal polynomial is different from characteristic.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 1], [0, 1]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\n\n# Since A is not diagonalizable and has a single Jordan block, the minimal polynomial is (x - 1)^2\nmin_poly = (sp.Symbol('x') - 1)**2\nprint(\"Minimal polynomial:\", min_poly)"
  },
  {
    "input": "Let A = [[2, 1, 0], [0, 2, 0], [0, 0, 3]]. Compute the Jordan canonical form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1, 0], [0, 2, 0], [0, 0, 3]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)"
  },
  {
    "input": "Construct a real matrix that is orthogonally diagonalizable and verify the property.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, -1], [-1, 2]])\nprint(\"Is symmetric:\", A == A.T)\nprint(\"Orthogonally diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Find a matrix with algebraic multiplicity 3 and geometric multiplicity 1 for its eigenvalue.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, 1, 0], [0, 5, 1], [0, 0, 5]])\nprint(\"Eigenvectors:\", A.eigenvects())"
  },
  {
    "input": "Let A = [[4, 1], [0, 4]]. Compute the Jordan form and check diagonalizability.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 1], [0, 4]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Construct a matrix with repeated eigenvalues that is still diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[6, 0, 0], [0, 6, 0], [0, 0, 6]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Let A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]]. Verify it's not diagonalizable but nilpotent.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nprint(\"Is diagonalizable:\", A.is_diagonalizable())\nprint(\"Nilpotent (A^3 = 0):\", A**3 == sp.zeros(3))"
  },
  {
    "input": "Construct a 3x3 matrix with eigenvalues 2 (multiplicity 2) and 3, but not diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1, 0], [0, 2, 0], [0, 0, 3]])\nprint(\"Eigenvalues:\", A.eigenvals())\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Let A = [[2, 1], [0, 2]]. Find the characteristic and minimal polynomials.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 1], [0, 2]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\n\n# A is not diagonalizable, so minimal polynomial is (x - 2)^2\nx = sp.Symbol('x')\nmin_poly = (x - 2)**2\nprint(\"Minimal polynomial:\", min_poly)"
  },
  {
    "input": "Let A = [[3, 0], [0, 5]]. Show that minimal polynomial equals characteristic polynomial.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 0], [0, 5]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\n\n# A is diagonalizable with distinct eigenvalues\nx = sp.Symbol('x')\nmin_poly = (x - 3)*(x - 5)\nprint(\"Minimal polynomial:\", min_poly)"
  },
  {
    "input": "Let A = [[0, 1], [-1, 0]]. Find the characteristic and minimal polynomials.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1], [-1, 0]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\n\n# Eigenvalues are \u00b1i, matrix is diagonalizable over C\nx = sp.Symbol('x')\nmin_poly = x**2 + 1\nprint(\"Minimal polynomial:\", min_poly)"
  },
  {
    "input": "Let A = [[0, 1, 0], [0, 0, 1], [0, 0, 0]]. Verify A is nilpotent and find its minimal polynomial.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, 1, 0], [0, 0, 1], [0, 0, 0]])\nprint(\"A^3 = 0:\", A**3 == sp.zeros(3))\n\n# A is nilpotent of index 3\nx = sp.Symbol('x')\nmin_poly = x**3\nprint(\"Minimal polynomial:\", min_poly)"
  },
  {
    "input": "Let A = [[5, 0], [0, 5]]. Find characteristic and minimal polynomials.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, 0], [0, 5]])\nchar_poly = A.charpoly().as_expr()\nprint(\"Characteristic polynomial:\", char_poly)\n\n# Matrix is already diagonal, so minimal polynomial is (x - 5)\nx = sp.Symbol('x')\nmin_poly = (x - 5)\nprint(\"Minimal polynomial:\", min_poly)"
  },
  {
    "input": "Given the matrix A = [[4, 1], [2, 3]], find the eigenvalues and eigenvectors, and verify if A is diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 1], [2, 3]])\neigenvals = A.eigenvals()\neigenvects = A.eigenvects()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Eigenvectors:\", eigenvects)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "For the matrix A = [[0, -1], [1, 0]], determine its eigenvalues and eigenvectors, and check if it is diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[0, -1], [1, 0]])\neigenvals = A.eigenvals()\neigenvects = A.eigenvects()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Eigenvectors:\", eigenvects)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Let A = [[2, 0, 0], [0, 3, 4], [0, 4, 9]]. Find the eigenvalues and eigenvectors, and verify if A is diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, 0, 0], [0, 3, 4], [0, 4, 9]])\neigenvals = A.eigenvals()\neigenvects = A.eigenvects()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Eigenvectors:\", eigenvects)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Given the matrix A = [[1, 2, 3], [0, 1, 4], [0, 0, 1]], determine its eigenvalues and eigenvectors, and check if it is diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[1, 2, 3], [0, 1, 4], [0, 0, 1]])\neigenvals = A.eigenvals()\neigenvects = A.eigenvects()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Eigenvectors:\", eigenvects)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "For the matrix A = [[5, 2], [2, 5]], find the eigenvalues and eigenvectors, and verify if A is diagonalizable.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, 2], [2, 5]])\neigenvals = A.eigenvals()\neigenvects = A.eigenvects()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Eigenvectors:\", eigenvects)\nprint(\"Is diagonalizable:\", A.is_diagonalizable())"
  },
  {
    "input": "Given a symmetric matrix A = [[6, 2, 1], [2, 3, 1], [1, 1, 1]], diagonalize it using the spectral theorem.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[6, 2, 1], [2, 3, 1], [1, 1, 1]])\nP, D = A.diagonalize()\nprint(\"Orthogonal matrix P:\\n\", P)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Check: P * D * P.T = A -->\", P * D * P.T == A)"
  },
  {
    "input": "Find the eigenvalues, eigenvectors, and the Jordan canonical form of A = [[5, 4, 2], [0, 5, 2], [0, 0, 5]].",
    "output": "import sympy as sp\n\nA = sp.Matrix([[5, 4, 2], [0, 5, 2], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint(\"Jordan form:\\n\", J)\nprint(\"Transformation matrix:\\n\", P)"
  },
  {
    "input": "Let A = [[3, 2, 4], [2, 0, 2], [4, 2, 3]]. Verify it is symmetric and diagonalize it.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[3, 2, 4], [2, 0, 2], [4, 2, 3]])\nprint(\"Is symmetric:\", A == A.T)\nP, D = A.diagonalize()\nprint(\"P (eigenvectors):\\n\", P)\nprint(\"D (diagonal):\\n\", D)\nprint(\"Check P * D * P.inv() == A:\", P * D * P.inv() == A)"
  },
  {
    "input": "Construct a 3x3 real matrix with repeated eigenvalues but not diagonalizable. Find its Jordan form.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[4, 1, 0], [0, 4, 1], [0, 0, 4]])\nJ, P = A.jordan_form()\nprint(\"Matrix A:\\n\", A)\nprint(\"Jordan form:\\n\", J)\nprint(\"P (Jordan basis):\\n\", P)"
  },
  {
    "input": "Given A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]], find its eigenvalues, eigenvectors and verify diagonalization.",
    "output": "import sympy as sp\n\nA = sp.Matrix([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvals = A.eigenvals()\neigenvects = A.eigenvects()\nP, D = A.diagonalize()\nprint(\"Eigenvalues:\", eigenvals)\nprint(\"Eigenvectors:\", eigenvects)\nprint(\"Diagonal matrix D:\\n\", D)\nprint(\"Transformation matrix P:\\n\", P)\nprint(\"Check A == P * D * P.inv():\", A.equals(P * D * P.inv()))"
  },
  {
    "input": "Compute the dot product of vectors [1, 2, 3] and [4, 5, 6].",
    "output": "import numpy as np\nvector_a = np.array([1, 2, 3])\nvector_b = np.array([4, 5, 6])\ndot_product = np.dot(vector_a, vector_b)\nprint(dot_product)"
  },
  {
    "input": "Compute the cross product of vectors [1, 0, 0] and [0, 1, 0].",
    "output": "import numpy as np\nvector_a = np.array([1, 0, 0])\nvector_b = np.array([0, 1, 0])\ncross_product = np.cross(vector_a, vector_b)\nprint(cross_product)"
  },
  {
    "input": "Compute the Hadamard product (element-wise multiplication) of matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]].",
    "output": "import numpy as np\nmatrix_a = np.array([[1, 2], [3, 4]])\nmatrix_b = np.array([[5, 6], [7, 8]])\nhadamard_product = np.multiply(matrix_a, matrix_b)\nprint(hadamard_product)"
  },
  {
    "input": "Compute the trace of the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ntrace = np.trace(matrix)\nprint(trace)"
  },
  {
    "input": "Reshape the vector [1, 2, 3, 4, 5, 6] into a 2x3 matrix.",
    "output": "import numpy as np\nvector = np.array([1, 2, 3, 4, 5, 6])\nreshaped_matrix = vector.reshape(2, 3)\nprint(reshaped_matrix)"
  },
  {
    "input": "Flatten the matrix [[1, 2], [3, 4]] into a vector.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nflattened_vector = matrix.flatten()\nprint(flattened_vector)"
  },
  {
    "input": "Compute the rank of the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(rank)"
  },
  {
    "input": "Compute the Frobenius norm of the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nfrobenius_norm = np.linalg.norm(matrix, 'fro')\nprint(frobenius_norm)"
  },
  {
    "input": "Compute the singular value decomposition (SVD) of the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(matrix)\nprint('U:', U)\nprint('Singular values:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Compute the Moore-Penrose pseudoinverse of the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\npseudoinverse = np.linalg.pinv(matrix)\nprint(pseudoinverse)"
  },
  {
    "input": "Compute the sum of the elements in the vector [1, 2, 3, 4, 5].",
    "output": "import numpy as np\nvector = np.array([1, 2, 3, 4, 5])\nsum_of_elements = np.sum(vector)\nprint(sum_of_elements)"
  },
  {
    "input": "Compute the outer product of vectors [1, 2, 3] and [4, 5, 6].",
    "output": "import numpy as np\nvector_a = np.array([1, 2, 3])\nvector_b = np.array([4, 5, 6])\nouter_product = np.outer(vector_a, vector_b)\nprint(outer_product)"
  },
  {
    "input": "Extract the diagonal elements from the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ndiagonal_elements = np.diag(matrix)\nprint(diagonal_elements)"
  },
  {
    "input": "Create a 3x3 identity matrix.",
    "output": "import numpy as np\nidentity_matrix = np.eye(3)\nprint(identity_matrix)"
  },
  {
    "input": "Compute the upper triangular part of the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nupper_triangular = np.triu(matrix)\nprint(upper_triangular)"
  },
  {
    "input": "Compute the determinant of the matrix [[2, 3], [1, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[2, 3], [1, 4]])\ndeterminant = np.linalg.det(matrix)\nprint(determinant)"
  },
  {
    "input": "Compute the inverse of the matrix [[2, 3], [1, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[2, 3], [1, 4]])\ninverse_matrix = np.linalg.inv(matrix)\nprint(inverse_matrix)"
  },
  {
    "input": "Compute the eigenvalues and eigenvectors of the matrix [[2, -1], [-1, 2]].",
    "output": "import numpy as np\nmatrix = np.array([[2, -1], [-1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(matrix)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Compute the Kronecker product of matrices [[1, 2], [3, 4]] and [[0, 5], [6, 7]].",
    "output": "import numpy as np\nmatrix_a = np.array([[1, 2], [3, 4]])\nmatrix_b = np.array([[0, 5], [6, 7]])\nkronecker_product = np.kron(matrix_a, matrix_b)\nprint(kronecker_product)"
  },
  {
    "input": "Create a 3x3 tensor filled with the value 7.",
    "output": "import numpy as np\ntensor = np.full((3, 3), 7)\nprint(tensor)"
  },
  {
    "input": "Check if the matrix [[1, 2], [2, 1]] is symmetric.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [2, 1]])\nis_symmetric = np.array_equal(matrix, matrix.T)\nprint(is_symmetric)"
  },
  {
    "input": "Compute the element-wise square of matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nsquared_matrix = np.square(matrix)\nprint(squared_matrix)"
  },
  {
    "input": "Create a 3D tensor of shape (2, 2, 2) with sequential values starting from 1.",
    "output": "import numpy as np\ntensor = np.arange(1, 9).reshape((2, 2, 2))\nprint(tensor)"
  },
  {
    "input": "Compute the transpose of the 2D matrix [[1, 2, 3], [4, 5, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\ntransposed = matrix.T\nprint(transposed)"
  },
  {
    "input": "Generate a 4x4 diagonal matrix with diagonal values [1, 2, 3, 4].",
    "output": "import numpy as np\ndiagonal_matrix = np.diag([1, 2, 3, 4])\nprint(diagonal_matrix)"
  },
  {
    "input": "Create a 3x3x3 tensor with random integers between 1 and 10.",
    "output": "import numpy as np\ntensor = np.random.randint(1, 11, (3, 3, 3))\nprint(tensor)"
  },
  {
    "input": "Find the maximum value in the tensor [[[1, 5], [3, 9]], [[2, 4], [6, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 5], [3, 9]], [[2, 4], [6, 8]]])\nmax_val = np.max(tensor)\nprint(max_val)"
  },
  {
    "input": "Compute the mean of all elements in a tensor of shape (2, 2, 2) with values from 1 to 8.",
    "output": "import numpy as np\ntensor = np.arange(1, 9).reshape((2, 2, 2))\nmean_val = np.mean(tensor)\nprint(mean_val)"
  },
  {
    "input": "Add two 3x3 tensors: one filled with 1s and another with 2s.",
    "output": "import numpy as np\na = np.ones((3, 3))\nb = np.full((3, 3), 2)\nresult = a + b\nprint(result)"
  },
  {
    "input": "Compute the sum along the first axis of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nsum_axis0 = np.sum(tensor, axis=0)\nprint(sum_axis0)"
  },
  {
    "input": "Compute the sum along the second axis of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nsum_axis1 = np.sum(tensor, axis=1)\nprint(sum_axis1)"
  },
  {
    "input": "Compute the mean along the last axis of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nmean_last_axis = np.mean(tensor, axis=-1)\nprint(mean_last_axis)"
  },
  {
    "input": "Create a tensor of shape (2, 2, 2) filled with zeros.",
    "output": "import numpy as np\ntensor = np.zeros((2, 2, 2))\nprint(tensor)"
  },
  {
    "input": "Create a tensor of shape (2, 2, 2) filled with ones.",
    "output": "import numpy as np\ntensor = np.ones((2, 2, 2))\nprint(tensor)"
  },
  {
    "input": "Replace all elements greater than 5 in the tensor [[2, 6], [7, 4]] with 0.",
    "output": "import numpy as np\ntensor = np.array([[2, 6], [7, 4]])\ntensor[tensor > 5] = 0\nprint(tensor)"
  },
  {
    "input": "Stack two matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]] vertically.",
    "output": "import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nstacked = np.vstack((a, b))\nprint(stacked)"
  },
  {
    "input": "Stack two matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]] horizontally.",
    "output": "import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nstacked = np.hstack((a, b))\nprint(stacked)"
  },
  {
    "input": "Split the matrix [[1, 2, 3, 4], [5, 6, 7, 8]] into two along the columns.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\nsplit = np.hsplit(matrix, 2)\nfor part in split:\n    print(part)"
  },
  {
    "input": "Find the indices of non-zero elements in the matrix [[0, 1], [2, 0]].",
    "output": "import numpy as np\nmatrix = np.array([[0, 1], [2, 0]])\nindices = np.nonzero(matrix)\nprint(indices)"
  },
  {
    "input": "Round each element in the tensor [[1.2, 3.8], [4.5, 6.1]] to the nearest integer.",
    "output": "import numpy as np\ntensor = np.array([[1.2, 3.8], [4.5, 6.1]])\nrounded = np.rint(tensor)\nprint(rounded)"
  },
  {
    "input": "Compute the cumulative sum of elements in the vector [1, 2, 3, 4].",
    "output": "import numpy as np\nvector = np.array([1, 2, 3, 4])\ncumsum = np.cumsum(vector)\nprint(cumsum)"
  },
  {
    "input": "Sort each row of the matrix [[3, 1], [4, 2]].",
    "output": "import numpy as np\nmatrix = np.array([[3, 1], [4, 2]])\nsorted_matrix = np.sort(matrix, axis=1)\nprint(sorted_matrix)"
  },
  {
    "input": "Compute the standard deviation of all elements in the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nstd_dev = np.std(tensor)\nprint(std_dev)"
  },
  {
    "input": "Clip the values in the matrix [[1, 8], [3, 10]] to be between 2 and 9.",
    "output": "import numpy as np\nmatrix = np.array([[1, 8], [3, 10]])\nclipped = np.clip(matrix, 2, 9)\nprint(clipped)"
  },
  {
    "input": "Get the shape of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nshape = tensor.shape\nprint(shape)"
  },
  {
    "input": "Check if the matrix [[1, 0], [0, 1]] is an identity matrix.",
    "output": "import numpy as np\nmatrix = np.array([[1, 0], [0, 1]])\nis_identity = np.array_equal(matrix, np.eye(2))\nprint(is_identity)"
  },
  {
    "input": "Find the minimum value in the tensor [[3, 7], [1, 5]].",
    "output": "import numpy as np\ntensor = np.array([[3, 7], [1, 5]])\nmin_val = np.min(tensor)\nprint(min_val)"
  },
  {
    "input": "Broadcast a 1D array [1, 2] to match the shape of a 2x2 matrix.",
    "output": "import numpy as np\nvector = np.array([1, 2])\nresult = vector + np.zeros((2, 2))\nprint(result)"
  },
  {
    "input": "Reshape a 3x2 matrix [[1, 2], [3, 4], [5, 6]] into a 2x3 matrix.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\nreshaped = matrix.reshape(2, 3)\nprint(reshaped)"
  },
  {
    "input": "Check if all elements in the tensor [[1, 2], [3, 4]] are greater than 0.",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nresult = np.all(tensor > 0)\nprint(result)"
  },
  {
    "input": "Create an identity matrix of size 4x4.",
    "output": "import numpy as np\nidentity = np.eye(4)\nprint(identity)"
  },
  {
    "input": "Generate a 5x5 matrix of random floats between 0 and 1.",
    "output": "import numpy as np\nmatrix = np.random.rand(5, 5)\nprint(matrix)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[2, 0], [0, 3]].",
    "output": "import numpy as np\nmatrix = np.array([[2, 0], [0, 3]])\neigenvalues, _ = np.linalg.eig(matrix)\nprint(eigenvalues)"
  },
  {
    "input": "Find the eigenvectors of the matrix [[2, 0], [0, 3]].",
    "output": "import numpy as np\nmatrix = np.array([[2, 0], [0, 3]])\n_, eigenvectors = np.linalg.eig(matrix)\nprint(eigenvectors)"
  },
  {
    "input": "Repeat the vector [1, 2, 3] two times along a new axis.",
    "output": "import numpy as np\nvector = np.array([1, 2, 3])\nrepeated = np.tile(vector, (2, 1))\nprint(repeated)"
  },
  {
    "input": "Compute the inverse of the matrix [[4, 7], [2, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[4, 7], [2, 6]])\ninverse = np.linalg.inv(matrix)\nprint(inverse)"
  },
  {
    "input": "Compute the determinant of the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ndet = np.linalg.det(matrix)\nprint(det)"
  },
  {
    "input": "Create a 1D tensor with values from 10 to 100 in steps of 10.",
    "output": "import numpy as np\ntensor = np.arange(10, 101, 10)\nprint(tensor)"
  },
  {
    "input": "Reshape a 1D array of size 12 into shape (3, 2, 2).",
    "output": "import numpy as np\narray = np.arange(1, 13)\nreshaped = array.reshape((3, 2, 2))\nprint(reshaped)"
  },
  {
    "input": "Swap the axes 0 and 1 of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nswapped = np.swapaxes(tensor, 0, 1)\nprint(swapped)"
  },
  {
    "input": "Reverse the elements of the vector [1, 2, 3, 4, 5].",
    "output": "import numpy as np\nvector = np.array([1, 2, 3, 4, 5])\nreversed_vector = vector[::-1]\nprint(reversed_vector)"
  },
  {
    "input": "Check if any element in the tensor [[0, 0], [1, 0]] is non-zero.",
    "output": "import numpy as np\ntensor = np.array([[0, 0], [1, 0]])\nresult = np.any(tensor != 0)\nprint(result)"
  },
  {
    "input": "Multiply a 2x2 matrix [[1, 2], [3, 4]] by scalar 3.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nresult = matrix * 3\nprint(result)"
  },
  {
    "input": "Generate a tensor of shape (2, 3) with values drawn from a standard normal distribution.",
    "output": "import numpy as np\ntensor = np.random.randn(2, 3)\nprint(tensor)"
  },
  {
    "input": "Flatten the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nflattened = tensor.flatten()\nprint(flattened)"
  },
  {
    "input": "Convert a list [[1, 2], [3, 4]] into a NumPy array.",
    "output": "import numpy as np\narray = np.array([[1, 2], [3, 4]])\nprint(array)"
  },
  {
    "input": "Get the number of dimensions of tensor [[1, 2], [3, 4]].",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\ndimensions = tensor.ndim\nprint(dimensions)"
  },
  {
    "input": "Get the data type of elements in the array [1, 2, 3].",
    "output": "import numpy as np\narray = np.array([1, 2, 3])\ndtype = array.dtype\nprint(dtype)"
  },
  {
    "input": "Set the diagonal of a 3x3 zero matrix to [1, 2, 3].",
    "output": "import numpy as np\nmatrix = np.zeros((3, 3))\nnp.fill_diagonal(matrix, [1, 2, 3])\nprint(matrix)"
  },
  {
    "input": "Compute the outer product of vectors [1, 2] and [3, 4].",
    "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nouter = np.outer(a, b)\nprint(outer)"
  },
  {
    "input": "Compute the inner product of vectors [1, 2] and [3, 4].",
    "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\ninner = np.inner(a, b)\nprint(inner)"
  },
  {
    "input": "Convert the tensor [[1.0, 2.5], [3.7, 4.2]] to integers.",
    "output": "import numpy as np\ntensor = np.array([[1.0, 2.5], [3.7, 4.2]])\nint_tensor = tensor.astype(int)\nprint(int_tensor)"
  },
  {
    "input": "Pad a 2x2 matrix [[1, 2], [3, 4]] with zeros on all sides.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\npadded = np.pad(matrix, pad_width=1, mode='constant')\nprint(padded)"
  },
  {
    "input": "Check if two tensors [[1, 2]] and [[1, 2]] are equal.",
    "output": "import numpy as np\na = np.array([[1, 2]])\nb = np.array([[1, 2]])\nresult = np.array_equal(a, b)\nprint(result)"
  },
  {
    "input": "Create a 2x3 matrix with all elements set to 9.",
    "output": "import numpy as np\nmatrix = np.full((2, 3), 9)\nprint(matrix)"
  },
  {
    "input": "Create a 3x3 matrix with random integers from 0 to 20.",
    "output": "import numpy as np\nmatrix = np.random.randint(0, 21, size=(3, 3))\nprint(matrix)"
  },
  {
    "input": "Extract the diagonal of the matrix [[4, 5], [6, 7]].",
    "output": "import numpy as np\nmatrix = np.array([[4, 5], [6, 7]])\ndiagonal = np.diag(matrix)\nprint(diagonal)"
  },
  {
    "input": "Check if the shape of tensor [[[1], [2]], [[3], [4]]] is (2, 2, 1).",
    "output": "import numpy as np\ntensor = np.array([[[1], [2]], [[3], [4]]])\nresult = tensor.shape == (2, 2, 1)\nprint(result)"
  },
  {
    "input": "Find the maximum value in the matrix [[1, 9], [4, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 9], [4, 6]])\nmax_val = np.max(matrix)\nprint(max_val)"
  },
  {
    "input": "Create a 1D array with 8 evenly spaced values between 0 and 1.",
    "output": "import numpy as np\narray = np.linspace(0, 1, 8)\nprint(array)"
  },
  {
    "input": "Count the number of non-zero elements in the array [[0, 1, 2], [3, 0, 4]].",
    "output": "import numpy as np\narray = np.array([[0, 1, 2], [3, 0, 4]])\ncount = np.count_nonzero(array)\nprint(count)"
  },
  {
    "input": "Convert a 3x3 matrix of ones to boolean type.",
    "output": "import numpy as np\nmatrix = np.ones((3, 3))\nbool_matrix = matrix.astype(bool)\nprint(bool_matrix)"
  },
  {
    "input": "Compute the sum of diagonal elements in the matrix [[2, 1], [4, 3]].",
    "output": "import numpy as np\nmatrix = np.array([[2, 1], [4, 3]])\ndiag_sum = np.trace(matrix)\nprint(diag_sum)"
  },
  {
    "input": "Create a 4x4 identity matrix using np.identity.",
    "output": "import numpy as np\nidentity = np.identity(4)\nprint(identity)"
  },
  {
    "input": "Repeat each element of the array [1, 2, 3] three times.",
    "output": "import numpy as np\narray = np.array([1, 2, 3])\nrepeated = np.repeat(array, 3)\nprint(repeated)"
  },
  {
    "input": "Extract elements from [10, 20, 30, 40, 50] at even indices.",
    "output": "import numpy as np\narray = np.array([10, 20, 30, 40, 50])\nevens = array[::2]\nprint(evens)"
  },
  {
    "input": "Tile the array [1, 2] to form a 2x4 matrix.",
    "output": "import numpy as np\narray = np.array([1, 2])\ntiled = np.tile(array, (2, 2))\nprint(tiled)"
  },
  {
    "input": "Get the index of the maximum element in the array [4, 9, 1, 7].",
    "output": "import numpy as np\narray = np.array([4, 9, 1, 7])\nindex = np.argmax(array)\nprint(index)"
  },
  {
    "input": "Get the index of the minimum element in the array [4, 9, 1, 7].",
    "output": "import numpy as np\narray = np.array([4, 9, 1, 7])\nindex = np.argmin(array)\nprint(index)"
  },
  {
    "input": "Round down all elements in [1.2, 3.8, 4.5] to nearest lower integer.",
    "output": "import numpy as np\narray = np.array([1.2, 3.8, 4.5])\nfloored = np.floor(array)\nprint(floored)"
  },
  {
    "input": "Round up all elements in [1.2, 3.8, 4.5] to nearest higher integer.",
    "output": "import numpy as np\narray = np.array([1.2, 3.8, 4.5])\nceiled = np.ceil(array)\nprint(ceiled)"
  },
  {
    "input": "Create a diagonal matrix from the list [5, 10, 15].",
    "output": "import numpy as np\nvalues = np.array([5, 10, 15])\ndiagonal_matrix = np.diag(values)\nprint(diagonal_matrix)"
  },
  {
    "input": "Check if all elements in [1, 2, 3] are less than 5.",
    "output": "import numpy as np\narray = np.array([1, 2, 3])\nresult = np.all(array < 5)\nprint(result)"
  },
  {
    "input": "Create a 1D array of 6 zeros.",
    "output": "import numpy as np\narray = np.zeros(6)\nprint(array)"
  },
  {
    "input": "Create a 2D tensor filled with the value 7 of shape (3, 3).",
    "output": "import numpy as np\ntensor = np.full((3, 3), 7)\nprint(tensor)"
  },
  {
    "input": "Convert a NumPy array [1, 2, 3] to a Python list.",
    "output": "import numpy as np\narray = np.array([1, 2, 3])\npy_list = array.tolist()\nprint(py_list)"
  },
  {
    "input": "Generate a 1D array of 5 random integers between 1 and 10.",
    "output": "import numpy as np\nrandom_array = np.random.randint(1, 11, size=5)\nprint(random_array)"
  },
  {
    "input": "Transpose the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ntransposed = matrix.T\nprint(transposed)"
  },
  {
    "input": "Create a 1D array of 10 linearly spaced numbers from 0 to 5.",
    "output": "import numpy as np\narray = np.linspace(0, 5, 10)\nprint(array)"
  },
  {
    "input": "Stack arrays [1, 2] and [3, 4] vertically.",
    "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nstacked = np.vstack((a, b))\nprint(stacked)"
  },
  {
    "input": "Stack arrays [1, 2] and [3, 4] horizontally.",
    "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nstacked = np.hstack((a, b))\nprint(stacked)"
  },
  {
    "input": "Element-wise divide matrix [[4, 8], [6, 2]] by 2.",
    "output": "import numpy as np\nmatrix = np.array([[4, 8], [6, 2]])\nresult = matrix / 2\nprint(result)"
  },
  {
    "input": "Add two matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]].",
    "output": "import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nsum_matrix = a + b\nprint(sum_matrix)"
  },
  {
    "input": "Subtract matrix [[2, 1], [0, 3]] from [[5, 4], [2, 6]].",
    "output": "import numpy as np\na = np.array([[5, 4], [2, 6]])\nb = np.array([[2, 1], [0, 3]])\ndiff = a - b\nprint(diff)"
  },
  {
    "input": "Multiply matrices [[1, 2], [3, 4]] and [[2, 0], [1, 2]].",
    "output": "import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[2, 0], [1, 2]])\nproduct = np.dot(a, b)\nprint(product)"
  },
  {
    "input": "Create a 2x2 matrix from flat list [1, 2, 3, 4].",
    "output": "import numpy as np\nflat_list = [1, 2, 3, 4]\nmatrix = np.array(flat_list).reshape(2, 2)\nprint(matrix)"
  },
  {
    "input": "Clip values in [0, 5, 10, 15] to be between 3 and 12.",
    "output": "import numpy as np\narray = np.array([0, 5, 10, 15])\nclipped = np.clip(array, 3, 12)\nprint(clipped)"
  },
  {
    "input": "Normalize the array [2, 4, 6] by dividing each value by the max.",
    "output": "import numpy as np\narray = np.array([2, 4, 6])\nnormalized = array / np.max(array)\nprint(normalized)"
  },
  {
    "input": "Check if any element in [0, 0, 1, 0] is non-zero.",
    "output": "import numpy as np\narray = np.array([0, 0, 1, 0])\nresult = np.any(array)\nprint(result)"
  },
  {
    "input": "Find the mean of the array [4, 8, 6, 10].",
    "output": "import numpy as np\narray = np.array([4, 8, 6, 10])\nmean_val = np.mean(array)\nprint(mean_val)"
  },
  {
    "input": "Find the standard deviation of [2, 4, 4, 4, 5, 5, 7, 9].",
    "output": "import numpy as np\narray = np.array([2, 4, 4, 4, 5, 5, 7, 9])\nstd_dev = np.std(array)\nprint(std_dev)"
  },
  {
    "input": "Find the median of the array [3, 5, 1, 2, 4].",
    "output": "import numpy as np\narray = np.array([3, 5, 1, 2, 4])\nmedian_val = np.median(array)\nprint(median_val)"
  },
  {
    "input": "Replace all values > 10 in [5, 12, 7, 15] with 10.",
    "output": "import numpy as np\narray = np.array([5, 12, 7, 15])\narray[array > 10] = 10\nprint(array)"
  },
  {
    "input": "Reshape a 1D array [1, 2, 3, 4, 5, 6] into shape (2, 3).",
    "output": "import numpy as np\narray = np.array([1, 2, 3, 4, 5, 6])\nreshaped = array.reshape(2, 3)\nprint(reshaped)"
  },
  {
    "input": "Sort the array [4, 2, 9, 1] in ascending order.",
    "output": "import numpy as np\narray = np.array([4, 2, 9, 1])\nsorted_array = np.sort(array)\nprint(sorted_array)"
  },
  {
    "input": "Reverse the array [1, 2, 3, 4].",
    "output": "import numpy as np\narray = np.array([1, 2, 3, 4])\nreversed_array = array[::-1]\nprint(reversed_array)"
  },
  {
    "input": "Find unique elements in [1, 2, 2, 3, 4, 4, 4].",
    "output": "import numpy as np\narray = np.array([1, 2, 2, 3, 4, 4, 4])\nunique_vals = np.unique(array)\nprint(unique_vals)"
  },
  {
    "input": "Broadcast scalar 3 over a 2x2 zero matrix.",
    "output": "import numpy as np\nmatrix = np.zeros((2, 2))\nresult = matrix + 3\nprint(result)"
  },
  {
    "input": "Square each element in [1, 2, 3, 4].",
    "output": "import numpy as np\narray = np.array([1, 2, 3, 4])\nsquared = np.square(array)\nprint(squared)"
  },
  {
    "input": "Check if the shape of [[1, 2], [3, 4]] is (2, 2).",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nresult = matrix.shape == (2, 2)\nprint(result)"
  },
  {
    "input": "Create an array with values from 5 to 14.",
    "output": "import numpy as np\narray = np.arange(5, 15)\nprint(array)"
  },
  {
    "input": "Compute the cumulative sum of [1, 2, 3, 4].",
    "output": "import numpy as np\narray = np.array([1, 2, 3, 4])\ncumsum = np.cumsum(array)\nprint(cumsum)"
  },
  {
    "input": "Compute the cumulative product of [1, 2, 3, 4].",
    "output": "import numpy as np\narray = np.array([1, 2, 3, 4])\ncumprod = np.cumprod(array)\nprint(cumprod)"
  },
  {
    "input": "Check if all elements in [2, 4, 6, 8] are even.",
    "output": "import numpy as np\narray = np.array([2, 4, 6, 8])\nresult = np.all(array % 2 == 0)\nprint(result)"
  },
  {
    "input": "Create a 3x3 matrix with values from 1 to 9.",
    "output": "import numpy as np\nmatrix = np.arange(1, 10).reshape(3, 3)\nprint(matrix)"
  },
  {
    "input": "Replace all odd numbers in [1, 2, 3, 4, 5] with -1.",
    "output": "import numpy as np\narray = np.array([1, 2, 3, 4, 5])\narray[array % 2 == 1] = -1\nprint(array)"
  },
  {
    "input": "Flatten the matrix [[1, 2], [3, 4]] into 1D.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nflattened = matrix.flatten()\nprint(flattened)"
  },
  {
    "input": "Find the shape of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nprint(tensor.shape)"
  },
  {
    "input": "Create a 3x1 column vector with values [1, 2, 3].",
    "output": "import numpy as np\nvector = np.array([1, 2, 3]).reshape(3, 1)\nprint(vector)"
  },
  {
    "input": "Create a 1x3 row vector with values [1, 2, 3].",
    "output": "import numpy as np\nvector = np.array([1, 2, 3]).reshape(1, 3)\nprint(vector)"
  },
  {
    "input": "Generate a 3x3 matrix with random integers between 0 and 5.",
    "output": "import numpy as np\nmatrix = np.random.randint(0, 6, (3, 3))\nprint(matrix)"
  },
  {
    "input": "Find the sum of each column in [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ncol_sum = np.sum(matrix, axis=0)\nprint(col_sum)"
  },
  {
    "input": "Find the sum of each row in [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nrow_sum = np.sum(matrix, axis=1)\nprint(row_sum)"
  },
  {
    "input": "Find the dot product of [1, 2] and [3, 4].",
    "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\ndot = np.dot(a, b)\nprint(dot)"
  },
  {
    "input": "Check if two arrays [1, 2, 3] and [1, 2, 4] are equal.",
    "output": "import numpy as np\na = np.array([1, 2, 3])\nb = np.array([1, 2, 4])\nresult = np.array_equal(a, b)\nprint(result)"
  },
  {
    "input": "Find the element-wise maximum of [1, 5, 3] and [2, 4, 6].",
    "output": "import numpy as np\na = np.array([1, 5, 3])\nb = np.array([2, 4, 6])\nresult = np.maximum(a, b)\nprint(result)"
  },
  {
    "input": "Find the element-wise minimum of [1, 5, 3] and [2, 4, 6].",
    "output": "import numpy as np\na = np.array([1, 5, 3])\nb = np.array([2, 4, 6])\nresult = np.minimum(a, b)\nprint(result)"
  },
  {
    "input": "Compute the sum of the vector [1, 2, 3, 4, 5].",
    "output": "import numpy as np\nvector = np.array([1, 2, 3, 4, 5])\nresult = np.sum(vector)\nprint(result)"
  },
  {
    "input": "Compute the outer product of vectors [1, 2, 3] and [4, 5, 6].",
    "output": "import numpy as np\nvector1 = np.array([1, 2, 3])\nvector2 = np.array([4, 5, 6])\nresult = np.outer(vector1, vector2)\nprint(result)"
  },
  {
    "input": "Extract the diagonal elements of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nresult = np.diag(matrix)\nprint(result)"
  },
  {
    "input": "Create a 3x3 identity matrix.",
    "output": "import numpy as np\nresult = np.eye(3)\nprint(result)"
  },
  {
    "input": "Compute the upper triangular part of a 3x3 matrix filled with ones.",
    "output": "import numpy as np\nmatrix = np.ones((3, 3))\nresult = np.triu(matrix)\nprint(result)"
  },
  {
    "input": "Compute the determinant of the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nresult = np.linalg.det(matrix)\nprint(result)"
  },
  {
    "input": "Compute the eigenvalues and eigenvectors of the matrix [[4, -2], [1, 1]].",
    "output": "import numpy as np\nmatrix = np.array([[4, -2], [1, 1]])\neigenvalues, eigenvectors = np.linalg.eig(matrix)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
  },
  {
    "input": "Compute the cross product of vectors [1, 0, 0] and [0, 1, 0].",
    "output": "import numpy as np\nvector1 = np.array([1, 0, 0])\nvector2 = np.array([0, 1, 0])\nresult = np.cross(vector1, vector2)\nprint(result)"
  },
  {
    "input": "Solve the system of linear equations: x + y = 2 and x - y = 0.",
    "output": "import numpy as np\nA = np.array([[1, 1], [1, -1]])\nB = np.array([2, 0])\nresult = np.linalg.solve(A, B)\nprint(result)"
  },
  {
    "input": "Compute the inverse of the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nresult = np.linalg.inv(matrix)\nprint(result)"
  },
  {
    "input": "Create a 2x3 tensor filled with zeros.",
    "output": "import numpy as np\ntensor = np.zeros((2, 3))\nprint(tensor)"
  },
  {
    "input": "Create a 3-dimensional tensor of shape (2, 2, 2) filled with random integers from 0 to 9.",
    "output": "import numpy as np\ntensor = np.random.randint(0, 10, size=(2, 2, 2))\nprint(tensor)"
  },
  {
    "input": "Reshape the array [1, 2, 3, 4, 5, 6] into a 2x3 tensor.",
    "output": "import numpy as np\narray = np.array([1, 2, 3, 4, 5, 6])\ntensor = array.reshape(2, 3)\nprint(tensor)"
  },
  {
    "input": "Transpose the matrix [[1, 2, 3], [4, 5, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\nresult = np.transpose(matrix)\nprint(result)"
  },
  {
    "input": "Compute the dot product of vectors [1, 3] and [2, 4].",
    "output": "import numpy as np\nvector1 = np.array([1, 3])\nvector2 = np.array([2, 4])\nresult = np.dot(vector1, vector2)\nprint(result)"
  },
  {
    "input": "Broadcast a 1D tensor [1, 2, 3] to a 3x3 tensor.",
    "output": "import numpy as np\narray = np.array([1, 2, 3])\nbroadcasted = np.tile(array, (3, 1))\nprint(broadcasted)"
  },
  {
    "input": "Flatten a 2x3 tensor [[1, 2, 3], [4, 5, 6]] into a 1D array.",
    "output": "import numpy as np\ntensor = np.array([[1, 2, 3], [4, 5, 6]])\nflattened = tensor.flatten()\nprint(flattened)"
  },
  {
    "input": "Multiply each element of the tensor [[1, 2], [3, 4]] by 5.",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nresult = tensor * 5\nprint(result)"
  },
  {
    "input": "Find the shape of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nshape = tensor.shape\nprint(shape)"
  },
  {
    "input": "Add two tensors [[1, 2], [3, 4]] and [[5, 6], [7, 8]].",
    "output": "import numpy as np\ntensor1 = np.array([[1, 2], [3, 4]])\ntensor2 = np.array([[5, 6], [7, 8]])\nresult = tensor1 + tensor2\nprint(result)"
  },
  {
    "input": "Compute the Frobenius norm of the matrix [[1, -2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, -2], [3, 4]])\nresult = np.linalg.norm(matrix, 'fro')\nprint(result)"
  },
  {
    "input": "Find the rank of the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nresult = np.linalg.matrix_rank(matrix)\nprint(result)"
  },
  {
    "input": "Compute the Kronecker product of matrices [[1, 2], [3, 4]] and [[0, 5], [6, 7]].",
    "output": "import numpy as np\nmatrix1 = np.array([[1, 2], [3, 4]])\nmatrix2 = np.array([[0, 5], [6, 7]])\nresult = np.kron(matrix1, matrix2)\nprint(result)"
  },
  {
    "input": "Calculate the trace of the matrix [[5, 1, 2], [0, 3, -1], [4, 6, 8]].",
    "output": "import numpy as np\nmatrix = np.array([[5, 1, 2], [0, 3, -1], [4, 6, 8]])\nresult = np.trace(matrix)\nprint(result)"
  },
  {
    "input": "Solve the system of equations: 2x + 3y + z = 1, 4x + y - z = -1, -x + 2y + 5z = 2.",
    "output": "import numpy as np\nA = np.array([[2, 3, 1], [4, 1, -1], [-1, 2, 5]])\nB = np.array([1, -1, 2])\nresult = np.linalg.solve(A, B)\nprint(result)"
  },
  {
    "input": "Compute the singular value decomposition (SVD) of the matrix [[3, 2, 2], [2, 3, -2]].",
    "output": "import numpy as np\nmatrix = np.array([[3, 2, 2], [2, 3, -2]])\nU, S, Vt = np.linalg.svd(matrix)\nprint('U:', U)\nprint('Singular values:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Find the Moore-Penrose pseudoinverse of the matrix [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\nresult = np.linalg.pinv(matrix)\nprint(result)"
  },
  {
    "input": "Compute the determinant of the 3x3 matrix [[2, -1, 0], [1, 3, 2], [0, 1, 1]].",
    "output": "import numpy as np\nmatrix = np.array([[2, -1, 0], [1, 3, 2], [0, 1, 1]])\nresult = np.linalg.det(matrix)\nprint(result)"
  },
  {
    "input": "Calculate the eigenvalues and eigenvectors of the matrix [[4, -2, 1], [-2, 4, -2], [1, -2, 3]].",
    "output": "import numpy as np\nmatrix = np.array([[4, -2, 1], [-2, 4, -2], [1, -2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(matrix)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
  },
  {
    "input": "Compute the Cholesky decomposition of the matrix [[4, 12, -16], [12, 37, -43], [-16, -43, 98]].",
    "output": "import numpy as np\nmatrix = np.array([[4, 12, -16], [12, 37, -43], [-16, -43, 98]])\nresult = np.linalg.cholesky(matrix)\nprint(result)"
  },
  {
    "input": "Find the LU decomposition of the matrix [[7, 8], [3, 5]].",
    "output": "import numpy as np\nfrom scipy.linalg import lu\nmatrix = np.array([[7, 8], [3, 5]])\nP, L, U = lu(matrix)\nprint('P:', P)\nprint('L:', L)\nprint('U:', U)"
  },
  {
    "input": "Compute the QR decomposition of the matrix [[12, -51, 4], [6, 167, -68], [-4, 24, -41]].",
    "output": "import numpy as np\nmatrix = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])\nQ, R = np.linalg.qr(matrix)\nprint('Q:', Q)\nprint('R:', R)"
  },
  {
    "input": "Calculate the Hadamard product (element-wise multiplication) of matrices [[1, 2], [3, 4]] and [[5, 6], [7, 8]].",
    "output": "import numpy as np\nmatrix1 = np.array([[1, 2], [3, 4]])\nmatrix2 = np.array([[5, 6], [7, 8]])\nresult = np.multiply(matrix1, matrix2)\nprint(result)"
  },
  {
    "input": "Extract a sub-tensor from the 3D tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]] consisting only of the second 2x2 matrix.",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nsub_tensor = tensor[1]\nprint(sub_tensor)"
  },
  {
    "input": "Check if a 2x2 matrix [[2, -1], [-4, 2]] is singular (non-invertible).",
    "output": "import numpy as np\nmatrix = np.array([[2, -1], [-4, 2]])\ndet = np.linalg.det(matrix)\nis_singular = np.isclose(det, 0)\nprint('Singular:', is_singular)"
  },
  {
    "input": "Compute the matrix exponential of [[0, 1], [-1, 0]].",
    "output": "import numpy as np\nfrom scipy.linalg import expm\nmatrix = np.array([[0, 1], [-1, 0]])\nresult = expm(matrix)\nprint(result)"
  },
  {
    "input": "Perform a tensor contraction on tensors A and B, where A has shape (2,3,4) and B has shape (4,3,2), over the last axis of A and the first axis of B.",
    "output": "import numpy as np\nA = np.random.rand(2,3,4)\nB = np.random.rand(4,3,2)\nresult = np.tensordot(A, B, axes=([2,1], [0,1]))\nprint(result)"
  },
  {
    "input": "Compute the eigenvalues of a 2x2 symmetric matrix [[2, -1], [-1, 2]] and verify they are real.",
    "output": "import numpy as np\nmatrix = np.array([[2, -1], [-1, 2]])\neigenvalues = np.linalg.eigvals(matrix)\nare_real = np.all(np.isreal(eigenvalues))\nprint('Eigenvalues:', eigenvalues)\nprint('All real:', are_real)"
  },
  {
    "input": "Perform a batch matrix multiplication of two tensors: shape (10, 3, 4) and (10, 4, 2).",
    "output": "import numpy as np\na = np.random.rand(10, 3, 4)\nb = np.random.rand(10, 4, 2)\nresult = np.matmul(a, b)\nprint(result.shape)"
  },
  {
    "input": "Compute the norm of a rank-3 tensor [[[1,2], [3,4]], [[5,6], [7,8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1,2], [3,4]], [[5,6], [7,8]]])\nresult = np.linalg.norm(tensor)\nprint(result)"
  },
  {
    "input": "Check if a 3x3 matrix is orthogonal: [[0, 1, 0], [1, 0, 0], [0, 0, -1]].",
    "output": "import numpy as np\nmatrix = np.array([[0, 1, 0], [1, 0, 0], [0, 0, -1]])\nidentity = np.eye(3)\nresult = np.allclose(matrix @ matrix.T, identity)\nprint('Is orthogonal:', result)"
  },
  {
    "input": "Project the vector [3, 4] onto the vector [1, 0].",
    "output": "import numpy as np\na = np.array([3, 4])\nb = np.array([1, 0])\nprojection = (np.dot(a, b) / np.dot(b, b)) * b\nprint(projection)"
  },
  {
    "input": "Compute the rank-1 approximation of matrix [[1, 2], [3, 4]] using SVD.",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nU, S, Vt = np.linalg.svd(A, full_matrices=False)\nrank1 = S[0] * np.outer(U[:, 0], Vt[0, :])\nprint(rank1)"
  },
  {
    "input": "Check whether the matrix [[1, 2], [2, 5]] is positive definite.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [2, 5]])\neigenvalues = np.linalg.eigvals(matrix)\nresult = np.all(eigenvalues > 0)\nprint('Is positive definite:', result)"
  },
  {
    "input": "Create a block matrix [[A, B], [C, D]] where A, B, C, D are 2x2 identity matrices.",
    "output": "import numpy as np\nI = np.eye(2)\nresult = np.block([[I, I], [I, I]])\nprint(result)"
  },
  {
    "input": "Compute the inverse of a 2x2 matrix [[4, 7], [2, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[4, 7], [2, 6]])\ninverse = np.linalg.inv(matrix)\nprint(inverse)"
  },
  {
    "input": "Perform element-wise division of tensors [[10, 20], [30, 40]] and [[2, 4], [5, 8]].",
    "output": "import numpy as np\na = np.array([[10, 20], [30, 40]])\nb = np.array([[2, 4], [5, 8]])\nresult = np.divide(a, b)\nprint(result)"
  },
  {
    "input": "Generate a 4x4 identity matrix and compute its determinant.",
    "output": "import numpy as np\nidentity = np.eye(4)\ndet = np.linalg.det(identity)\nprint(det)"
  },
  {
    "input": "Generate a 3D tensor of shape (3, 3, 3) with values from 1 to 27 and slice out the middle 2D matrix.",
    "output": "import numpy as np\ntensor = np.arange(1, 28).reshape(3, 3, 3)\nmiddle_slice = tensor[1]\nprint(middle_slice)"
  },
  {
    "input": "Find the outer product of vectors [1, 2, 3] and [4, 5].",
    "output": "import numpy as np\na = np.array([1, 2, 3])\nb = np.array([4, 5])\nresult = np.outer(a, b)\nprint(result)"
  },
  {
    "input": "Convert the 2D array [[1, 2], [3, 4]] to a 3D tensor by adding a new axis at the beginning.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ntensor = matrix[np.newaxis, :, :]\nprint(tensor)"
  },
  {
    "input": "Given a 3x3 matrix, compute its cofactor matrix.",
    "output": "import numpy as np\nfrom numpy.linalg import det\nA = np.array([[1, 2, 3], [0, 4, 5], [1, 0, 6]])\ncofactors = np.zeros_like(A)\nfor i in range(3):\n    for j in range(3):\n        minor = np.delete(np.delete(A, i, axis=0), j, axis=1)\n        cofactors[i, j] = ((-1)**(i + j)) * det(minor)\nprint(cofactors)"
  },
  {
    "input": "Find the tensor product (outer product) of two matrices [[1, 0], [0, 1]] and [[2, 3], [4, 5]].",
    "output": "import numpy as np\nA = np.array([[1, 0], [0, 1]])\nB = np.array([[2, 3], [4, 5]])\nresult = np.tensordot(A, B, axes=0)\nprint(result)"
  },
  {
    "input": "Create a random symmetric 3x3 matrix.",
    "output": "import numpy as np\nA = np.random.rand(3, 3)\nsymmetric_matrix = (A + A.T) / 2\nprint(symmetric_matrix)"
  },
  {
    "input": "Rotate the 2D tensor [[1, 2], [3, 4]] by 90 degrees counter-clockwise.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nrotated = np.rot90(matrix)\nprint(rotated)"
  },
  {
    "input": "Create a diagonal matrix from the vector [7, 8, 9].",
    "output": "import numpy as np\nvector = np.array([7, 8, 9])\ndiagonal_matrix = np.diag(vector)\nprint(diagonal_matrix)"
  },
  {
    "input": "Check if the matrix [[1, 2], [3, 6]] is rank deficient.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 6]])\nrank = np.linalg.matrix_rank(matrix)\nresult = rank < min(matrix.shape)\nprint('Rank deficient:', result)"
  },
  {
    "input": "Compute the sum along axis 0 of the tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nsum_axis0 = np.sum(tensor, axis=0)\nprint(sum_axis0)"
  },
  {
    "input": "Find the tensor shape of a reshaped 1D array with 27 elements into (3, 3, 3).",
    "output": "import numpy as np\ntensor = np.arange(27).reshape(3, 3, 3)\nprint(tensor.shape)"
  },
  {
    "input": "Check if two tensors [[1,2],[3,4]] and [[1,2],[3,4]] are equal.",
    "output": "import numpy as np\na = np.array([[1,2],[3,4]])\nb = np.array([[1,2],[3,4]])\nresult = np.array_equal(a, b)\nprint('Are equal:', result)"
  },
  {
    "input": "Create a 3x3x3 identity-like tensor with ones on the diagonal (i==j==k).",
    "output": "import numpy as np\ntensor = np.zeros((3, 3, 3))\nfor i in range(3):\n    tensor[i, i, i] = 1\nprint(tensor)"
  },
  {
    "input": "Compute the mean of all elements in the tensor [[[2, 4], [6, 8]], [[10, 12], [14, 16]]].",
    "output": "import numpy as np\ntensor = np.array([[[2, 4], [6, 8]], [[10, 12], [14, 16]]])\nmean_value = np.mean(tensor)\nprint(mean_value)"
  },
  {
    "input": "Flatten the tensor [[1, 2], [3, 4]] to a 1D array.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nflattened = matrix.flatten()\nprint(flattened)"
  },
  {
    "input": "Transpose the last two axes of a tensor with shape (2, 3, 4).",
    "output": "import numpy as np\ntensor = np.random.rand(2, 3, 4)\ntransposed = np.transpose(tensor, (0, 2, 1))\nprint(transposed.shape)"
  },
  {
    "input": "Clip the values of a tensor [[-1, 5], [10, -3]] between 0 and 6.",
    "output": "import numpy as np\ntensor = np.array([[-1, 5], [10, -3]])\nclipped = np.clip(tensor, 0, 6)\nprint(clipped)"
  },
  {
    "input": "Broadcast a 1D array [1, 2, 3] to shape (3, 3).",
    "output": "import numpy as np\narray = np.array([1, 2, 3])\nresult = np.broadcast_to(array, (3, 3))\nprint(result)"
  },
  {
    "input": "Pad a 2D tensor [[1, 2], [3, 4]] with one layer of zeros around.",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\npadded = np.pad(tensor, pad_width=1, mode='constant', constant_values=0)\nprint(padded)"
  },
  {
    "input": "Compute the trace of the matrix [[5, 1], [2, 3]].",
    "output": "import numpy as np\nmatrix = np.array([[5, 1], [2, 3]])\ntrace = np.trace(matrix)\nprint(trace)"
  },
  {
    "input": "Determine the Frobenius norm of matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nfro_norm = np.linalg.norm(matrix, 'fro')\nprint(fro_norm)"
  },
  {
    "input": "Compute the Hadamard (element-wise) product of [[1, 2], [3, 4]] and [[5, 6], [7, 8]].",
    "output": "import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\nresult = np.multiply(a, b)\nprint(result)"
  },
  {
    "input": "Calculate the covariance matrix of the dataset [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\ndata = np.array([[1, 2], [3, 4], [5, 6]])\ncov_matrix = np.cov(data, rowvar=False)\nprint(cov_matrix)"
  },
  {
    "input": "Replace all negative values in tensor [[1, -2], [-3, 4]] with zero.",
    "output": "import numpy as np\ntensor = np.array([[1, -2], [-3, 4]])\nresult = np.where(tensor < 0, 0, tensor)\nprint(result)"
  },
  {
    "input": "Create a 3x3x3 tensor filled with random integers from 0 to 9.",
    "output": "import numpy as np\ntensor = np.random.randint(0, 10, size=(3, 3, 3))\nprint(tensor)"
  },
  {
    "input": "Compute the cumulative sum along axis 1 for [[1, 2, 3], [4, 5, 6]].",
    "output": "import numpy as np\ntensor = np.array([[1, 2, 3], [4, 5, 6]])\ncumsum = np.cumsum(tensor, axis=1)\nprint(cumsum)"
  },
  {
    "input": "Normalize a vector [3, 4] to have unit length.",
    "output": "import numpy as np\nv = np.array([3, 4])\nnorm = np.linalg.norm(v)\nunit_vector = v / norm\nprint(unit_vector)"
  },
  {
    "input": "Compute the Kronecker product of matrices [[1, 2], [3, 4]] and [[0, 5], [6, 7]].",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[0, 5], [6, 7]])\nkron = np.kron(A, B)\nprint(kron)"
  },
  {
    "input": "Compute the determinant of a 3x3 matrix [[2, 0, 1], [3, 0, 0], [5, 1, 1]].",
    "output": "import numpy as np\nmatrix = np.array([[2, 0, 1], [3, 0, 0], [5, 1, 1]])\ndet = np.linalg.det(matrix)\nprint(det)"
  },
  {
    "input": "Find the angle (in radians) between vectors [1, 0] and [0, 1].",
    "output": "import numpy as np\na = np.array([1, 0])\nb = np.array([0, 1])\ndot_product = np.dot(a, b)\nmagnitude = np.linalg.norm(a) * np.linalg.norm(b)\nangle = np.arccos(dot_product / magnitude)\nprint(angle)"
  },
  {
    "input": "Transpose a rank-3 tensor of shape (2, 3, 4) to shape (4, 3, 2).",
    "output": "import numpy as np\ntensor = np.random.rand(2, 3, 4)\ntransposed = np.transpose(tensor, (2, 1, 0))\nprint(transposed.shape)"
  },
  {
    "input": "Round all values in tensor [[1.2, 3.5], [4.7, 6.1]] to the nearest integer.",
    "output": "import numpy as np\ntensor = np.array([[1.2, 3.5], [4.7, 6.1]])\nrounded = np.rint(tensor)\nprint(rounded)"
  },
  {
    "input": "Compute the dot product of vectors [2, 3, 4] and [5, 6, 7].",
    "output": "import numpy as np\na = np.array([2, 3, 4])\nb = np.array([5, 6, 7])\ndot_product = np.dot(a, b)\nprint(dot_product)"
  },
  {
    "input": "Create a 2x2 rotation matrix for 90 degrees counter-clockwise.",
    "output": "import numpy as np\nangle = np.pi / 2\nrotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])\nprint(rotation_matrix)"
  },
  {
    "input": "Calculate the angle (in degrees) between vectors [1, 2, 2] and [2, 1, 2].",
    "output": "import numpy as np\nv1 = np.array([1, 2, 2])\nv2 = np.array([2, 1, 2])\ncos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\nangle_rad = np.arccos(cos_angle)\nangle_deg = np.degrees(angle_rad)\nprint(angle_deg)"
  },
  {
    "input": "Sum the diagonals of a 3x3 matrix [[1,2,3],[4,5,6],[7,8,9]].",
    "output": "import numpy as np\nmatrix = np.array([[1,2,3],[4,5,6],[7,8,9]])\ndiagonal_sum = np.trace(matrix)\nprint(diagonal_sum)"
  },
  {
    "input": "Extract the diagonal from a 3x3x3 tensor where i==j==k.",
    "output": "import numpy as np\ntensor = np.random.rand(3,3,3)\ndiagonal = np.array([tensor[i,i,i] for i in range(3)])\nprint(diagonal)"
  },
  {
    "input": "Check if a tensor [[1, 2], [3, 4]] is symmetric.",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nresult = np.array_equal(tensor, tensor.T)\nprint('Symmetric:', result)"
  },
  {
    "input": "Flip the tensor [[1, 2], [3, 4]] vertically.",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nflipped = np.flipud(tensor)\nprint(flipped)"
  },
  {
    "input": "Compute the maximum value across axis 1 in tensor [[1, 9], [4, 2], [3, 5]].",
    "output": "import numpy as np\ntensor = np.array([[1, 9], [4, 2], [3, 5]])\nmax_vals = np.max(tensor, axis=1)\nprint(max_vals)"
  },
  {
    "input": "Tile the vector [1, 2] three times along axis 0.",
    "output": "import numpy as np\nvector = np.array([1, 2])\ntiled = np.tile(vector, 3)\nprint(tiled)"
  },
  {
    "input": "Swap axes 0 and 2 of a tensor with shape (2, 3, 4).",
    "output": "import numpy as np\ntensor = np.random.rand(2, 3, 4)\nswapped = np.swapaxes(tensor, 0, 2)\nprint(swapped.shape)"
  },
  {
    "input": "Calculate the median of the tensor [1, 3, 2, 4, 5].",
    "output": "import numpy as np\ntensor = np.array([1, 3, 2, 4, 5])\nmedian = np.median(tensor)\nprint(median)"
  },
  {
    "input": "Shift the tensor [1, 2, 3, 4, 5] one position to the right with wrap around.",
    "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4, 5])\nshifted = np.roll(tensor, 1)\nprint(shifted)"
  },
  {
    "input": "Create a 5x5 matrix with 1s on the main diagonal and -1s on the first superdiagonal.",
    "output": "import numpy as np\nmain_diag = np.eye(5)\nsuper_diag = np.diag([-1]*4, k=1)\nmatrix = main_diag + super_diag\nprint(matrix)"
  },
  {
    "input": "Reverse the columns of a 2D tensor [[1, 2], [3, 4]].",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nreversed_cols = tensor[:, ::-1]\nprint(reversed_cols)"
  },
  {
    "input": "Calculate the standard deviation of the tensor [1, 3, 5, 7, 9].",
    "output": "import numpy as np\ntensor = np.array([1, 3, 5, 7, 9])\nstd_dev = np.std(tensor)\nprint(std_dev)"
  },
  {
    "input": "Check whether the matrix [[1, 2], [2, 1]] is symmetric.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [2, 1]])\nis_symmetric = np.array_equal(matrix, matrix.T)\nprint('Symmetric:', is_symmetric)"
  },
  {
    "input": "Find the eigenvalues of the matrix [[2, 0], [0, 3]].",
    "output": "import numpy as np\nmatrix = np.array([[2, 0], [0, 3]])\neigenvalues = np.linalg.eigvals(matrix)\nprint(eigenvalues)"
  },
  {
    "input": "Find the inverse of the matrix [[4, 7], [2, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[4, 7], [2, 6]])\ninverse = np.linalg.inv(matrix)\nprint(inverse)"
  },
  {
    "input": "Sum all values of the 3D tensor [[[1,2],[3,4]],[[5,6],[7,8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1,2],[3,4]],[[5,6],[7,8]]])\ntotal_sum = np.sum(tensor)\nprint(total_sum)"
  },
  {
    "input": "Calculate the determinant of a 2x2 matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ndet = np.linalg.det(matrix)\nprint(det)"
  },
  {
    "input": "Find the rank of the matrix [[1, 2], [2, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [2, 4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(rank)"
  },
  {
    "input": "Perform element-wise square of tensor [1, 2, 3, 4].",
    "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4])\nsquared = np.square(tensor)\nprint(squared)"
  },
  {
    "input": "Convert the tensor [1, 2, 3] to float type.",
    "output": "import numpy as np\ntensor = np.array([1, 2, 3])\nfloat_tensor = tensor.astype(float)\nprint(float_tensor)"
  },
  {
    "input": "Get the shape of tensor [[[1, 2], [3, 4]], [[5, 6], [7, 8]]].",
    "output": "import numpy as np\ntensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nprint(tensor.shape)"
  },
  {
    "input": "Create a tensor of shape (2, 3) filled with the value 9.",
    "output": "import numpy as np\ntensor = np.full((2, 3), 9)\nprint(tensor)"
  },
  {
    "input": "Find the minimum value in the tensor [[8, 3], [6, 1]].",
    "output": "import numpy as np\ntensor = np.array([[8, 3], [6, 1]])\nmin_value = np.min(tensor)\nprint(min_value)"
  },
  {
    "input": "Find the maximum value in the tensor [[8, 3], [6, 1]].",
    "output": "import numpy as np\ntensor = np.array([[8, 3], [6, 1]])\nmax_value = np.max(tensor)\nprint(max_value)"
  },
  {
    "input": "Calculate the mean of the tensor [10, 20, 30, 40, 50].",
    "output": "import numpy as np\ntensor = np.array([10, 20, 30, 40, 50])\nmean = np.mean(tensor)\nprint(mean)"
  },
  {
    "input": "Generate a 4x4 identity matrix.",
    "output": "import numpy as np\nidentity_matrix = np.eye(4)\nprint(identity_matrix)"
  },
  {
    "input": "Find the transpose of the matrix [[1, 2, 3], [4, 5, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\ntransposed = matrix.T\nprint(transposed)"
  },
  {
    "input": "Reshape the tensor [1, 2, 3, 4, 5, 6] into shape (2, 3).",
    "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4, 5, 6])\nreshaped = tensor.reshape(2, 3)\nprint(reshaped)"
  },
  {
    "input": "Compute the L2 norm of the vector [6, 8].",
    "output": "import numpy as np\nvector = np.array([6, 8])\nl2_norm = np.linalg.norm(vector)\nprint(l2_norm)"
  },
  {
    "input": "Create a tensor of shape (3, 3) filled with zeros.",
    "output": "import numpy as np\nzeros = np.zeros((3, 3))\nprint(zeros)"
  },
  {
    "input": "Create a tensor of shape (2, 2) filled with ones.",
    "output": "import numpy as np\nones = np.ones((2, 2))\nprint(ones)"
  },
  {
    "input": "Flatten the tensor [[1, 2], [3, 4]] into a 1D array.",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nflattened = tensor.flatten()\nprint(flattened)"
  },
  {
    "input": "Clip the values of tensor [1, 5, 9, 15] to be between 3 and 10.",
    "output": "import numpy as np\ntensor = np.array([1, 5, 9, 15])\nclipped = np.clip(tensor, 3, 10)\nprint(clipped)"
  },
  {
    "input": "Broadcast vector [1, 2, 3] to a 3x3 matrix.",
    "output": "import numpy as np\nvector = np.array([1, 2, 3])\nmatrix = np.broadcast_to(vector, (3, 3))\nprint(matrix)"
  },
  {
    "input": "Pad the tensor [1, 2, 3] with two zeros at the end.",
    "output": "import numpy as np\ntensor = np.array([1, 2, 3])\npadded = np.pad(tensor, (0, 2))\nprint(padded)"
  },
  {
    "input": "Compute the cross product of [1, 0, 0] and [0, 1, 0].",
    "output": "import numpy as np\na = np.array([1, 0, 0])\nb = np.array([0, 1, 0])\ncross = np.cross(a, b)\nprint(cross)"
  },
  {
    "input": "Round tensor [1.1, 2.5, 3.7] to the nearest integers.",
    "output": "import numpy as np\ntensor = np.array([1.1, 2.5, 3.7])\nrounded = np.rint(tensor)\nprint(rounded)"
  },
  {
    "input": "Generate a tensor with shape (2, 2) with random floats between 0 and 1.",
    "output": "import numpy as np\nrandom_tensor = np.random.rand(2, 2)\nprint(random_tensor)"
  },
  {
    "input": "Generate a diagonal matrix from vector [4, 5, 6].",
    "output": "import numpy as np\nvector = np.array([4, 5, 6])\ndiagonal_matrix = np.diag(vector)\nprint(diagonal_matrix)"
  },
  {
    "input": "Compute the trace of the matrix [[2, 0], [1, 3]].",
    "output": "import numpy as np\nmatrix = np.array([[2, 0], [1, 3]])\ntrace = np.trace(matrix)\nprint(trace)"
  },
  {
    "input": "Subtract matrix [[1, 2], [3, 4]] from [[5, 6], [7, 8]].",
    "output": "import numpy as np\na = np.array([[5, 6], [7, 8]])\nb = np.array([[1, 2], [3, 4]])\ndiff = a - b\nprint(diff)"
  },
  {
    "input": "Multiply the matrix [[1, 2], [3, 4]] by scalar 2.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nscaled = matrix * 2\nprint(scaled)"
  },
  {
    "input": "Add the tensors [[1, 1], [1, 1]] and [[2, 2], [2, 2]].",
    "output": "import numpy as np\na = np.array([[1, 1], [1, 1]])\nb = np.array([[2, 2], [2, 2]])\nsum_tensor = a + b\nprint(sum_tensor)"
  },
  {
    "input": "Get the second row of the matrix [[5, 6], [7, 8], [9, 10]].",
    "output": "import numpy as np\nmatrix = np.array([[5, 6], [7, 8], [9, 10]])\nrow = matrix[1]\nprint(row)"
  },
  {
    "input": "Create a 1D tensor with 5 evenly spaced values between 0 and 1.",
    "output": "import numpy as np\ntensor = np.linspace(0, 1, 5)\nprint(tensor)"
  },
  {
    "input": "Convert the tensor [[1, 2], [3, 4]] to a list.",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nlist_version = tensor.tolist()\nprint(list_version)"
  },
  {
    "input": "Compute the element-wise maximum between [3, 5, 1] and [4, 2, 6].",
    "output": "import numpy as np\na = np.array([3, 5, 1])\nb = np.array([4, 2, 6])\nmaximums = np.maximum(a, b)\nprint(maximums)"
  },
  {
    "input": "Get the index of the maximum value in tensor [1, 3, 7, 2, 5].",
    "output": "import numpy as np\ntensor = np.array([1, 3, 7, 2, 5])\nmax_index = np.argmax(tensor)\nprint(max_index)"
  },
  {
    "input": "Get the index of the minimum value in tensor [1, 3, 7, 2, 5].",
    "output": "import numpy as np\ntensor = np.array([1, 3, 7, 2, 5])\nmin_index = np.argmin(tensor)\nprint(min_index)"
  },
  {
    "input": "Split the tensor [1, 2, 3, 4, 5, 6] into three equal parts.",
    "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4, 5, 6])\nsplits = np.split(tensor, 3)\nprint(splits)"
  },
  {
    "input": "Check if two tensors [1, 2, 3] and [1, 2, 3] are equal.",
    "output": "import numpy as np\na = np.array([1, 2, 3])\nb = np.array([1, 2, 3])\nequal = np.array_equal(a, b)\nprint(equal)"
  },
  {
    "input": "Check if any element in tensor [0, 0, 1] is non-zero.",
    "output": "import numpy as np\ntensor = np.array([0, 0, 1])\nresult = np.any(tensor)\nprint(result)"
  },
  {
    "input": "Check if all elements in tensor [1, 1, 1] are non-zero.",
    "output": "import numpy as np\ntensor = np.array([1, 1, 1])\nresult = np.all(tensor)\nprint(result)"
  },
  {
    "input": "Compute the cumulative sum of tensor [1, 2, 3, 4].",
    "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4])\ncumsum = np.cumsum(tensor)\nprint(cumsum)"
  },
  {
    "input": "Find the dot product of vectors [2, 3] and [4, 5].",
    "output": "import numpy as np\na = np.array([2, 3])\nb = np.array([4, 5])\ndot = np.dot(a, b)\nprint(dot)"
  },
  {
    "input": "Stack tensors [1, 2] and [3, 4] vertically.",
    "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nstacked = np.vstack((a, b))\nprint(stacked)"
  },
  {
    "input": "Stack tensors [1, 2] and [3, 4] horizontally.",
    "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nstacked = np.hstack((a, b))\nprint(stacked)"
  },
  {
    "input": "Find the angle (in radians) between vectors [1, 0] and [0, 1].",
    "output": "import numpy as np\na = np.array([1, 0])\nb = np.array([0, 1])\ndot = np.dot(a, b)\nnorms = np.linalg.norm(a) * np.linalg.norm(b)\nangle = np.arccos(dot / norms)\nprint(angle)"
  },
  {
    "input": "Repeat tensor [1, 2] three times.",
    "output": "import numpy as np\ntensor = np.array([1, 2])\nrepeated = np.tile(tensor, 3)\nprint(repeated)"
  },
  {
    "input": "Generate a 2x3 matrix of random integers from 0 to 9.",
    "output": "import numpy as np\nmatrix = np.random.randint(0, 10, (2, 3))\nprint(matrix)"
  },
  {
    "input": "Check whether the matrix [[0, 1], [-1, 0]] is orthogonal.",
    "output": "import numpy as np\nmatrix = np.array([[0, 1], [-1, 0]])\nidentity = np.eye(2)\nresult = np.allclose(matrix @ matrix.T, identity)\nprint(result)"
  },
  {
    "input": "Transpose a 3D tensor of shape (2, 3, 4) to (4, 3, 2).",
    "output": "import numpy as np\ntensor = np.random.rand(2, 3, 4)\ntransposed = np.transpose(tensor, (2, 1, 0))\nprint(transposed.shape)"
  },
  {
    "input": "Create a tensor with shape (3, 3) filled with the value -5.",
    "output": "import numpy as np\ntensor = np.full((3, 3), -5)\nprint(tensor)"
  },
  {
    "input": "Normalize the tensor [3, 4] to unit length.",
    "output": "import numpy as np\ntensor = np.array([3, 4])\nnormalized = tensor / np.linalg.norm(tensor)\nprint(normalized)"
  },
  {
    "input": "Create a 3D tensor of shape (2, 2, 2) with all elements set to 1.",
    "output": "import numpy as np\ntensor = np.ones((2, 2, 2))\nprint(tensor)"
  },
  {
    "input": "Find the mean along columns of matrix [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\ncolumn_means = np.mean(matrix, axis=0)\nprint(column_means)"
  },
  {
    "input": "Find the mean along rows of matrix [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\nrow_means = np.mean(matrix, axis=1)\nprint(row_means)"
  },
  {
    "input": "Convert tensor [[1, 2], [3, 4]] to string format.",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nstring_repr = str(tensor)\nprint(string_repr)"
  },
  {
    "input": "Perform matrix multiplication between [[1, 0], [0, 1]] and [[4, 1], [2, 2]].",
    "output": "import numpy as np\na = np.array([[1, 0], [0, 1]])\nb = np.array([[4, 1], [2, 2]])\nresult = np.matmul(a, b)\nprint(result)"
  },
  {
    "input": "Find the rank of matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nrank = np.linalg.matrix_rank(matrix)\nprint(rank)"
  },
  {
    "input": "Extract the diagonal of the matrix [[7, 8, 9], [4, 5, 6], [1, 2, 3]].",
    "output": "import numpy as np\nmatrix = np.array([[7, 8, 9], [4, 5, 6], [1, 2, 3]])\ndiagonal = np.diag(matrix)\nprint(diagonal)"
  },
  {
    "input": "Flip the tensor [[1, 2], [3, 4]] horizontally.",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4]])\nflipped = np.fliplr(tensor)\nprint(flipped)"
  },
  {
    "input": "Sort the tensor [5, 1, 3, 2] in ascending order.",
    "output": "import numpy as np\ntensor = np.array([5, 1, 3, 2])\nsorted_tensor = np.sort(tensor)\nprint(sorted_tensor)"
  },
  {
    "input": "Get the shape of tensor [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\ntensor = np.array([[1, 2], [3, 4], [5, 6]])\nshape = tensor.shape\nprint(shape)"
  },
  {
    "input": "Replace values greater than 10 in [4, 15, 2, 23] with 10.",
    "output": "import numpy as np\ntensor = np.array([4, 15, 2, 23])\nreplaced = np.where(tensor > 10, 10, tensor)\nprint(replaced)"
  },
  {
    "input": "Generate a tensor of shape (2, 3) with standard normal distribution values.",
    "output": "import numpy as np\ntensor = np.random.randn(2, 3)\nprint(tensor)"
  },
  {
    "input": "Find the determinant of the matrix [[6, 1], [4, -2]].",
    "output": "import numpy as np\nmatrix = np.array([[6, 1], [4, -2]])\ndet = np.linalg.det(matrix)\nprint(det)"
  },
  {
    "input": "Round each element of tensor [1.25, 2.75, 3.50] to the nearest integer.",
    "output": "import numpy as np\ntensor = np.array([1.25, 2.75, 3.50])\nrounded = np.round(tensor)\nprint(rounded)"
  },
  {
    "input": "Transpose a matrix using np.swapaxes for matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ntransposed = np.swapaxes(matrix, 0, 1)\nprint(transposed)"
  },
  {
    "input": "Add 5 to every element of the tensor [[0, 1], [2, 3]].",
    "output": "import numpy as np\ntensor = np.array([[0, 1], [2, 3]])\nresult = tensor + 5\nprint(result)"
  },
  {
    "input": "Find the Frobenius norm of matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nfro_norm = np.linalg.norm(matrix, 'fro')\nprint(fro_norm)"
  },
  {
    "input": "Find the inverse of matrix [[2, 1], [5, 3]].",
    "output": "import numpy as np\nmatrix = np.array([[2, 1], [5, 3]])\ninverse = np.linalg.inv(matrix)\nprint(inverse)"
  },
  {
    "input": "Create a diagonal matrix with -1 on the diagonal of size 4x4.",
    "output": "import numpy as np\ndiag_matrix = np.diag([-1]*4)\nprint(diag_matrix)"
  },
  {
    "input": "Find the sum of all elements in the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ntotal = np.sum(matrix)\nprint(total)"
  },
  {
    "input": "Square every element in the tensor [1, 2, 3, 4].",
    "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4])\nsquared = np.square(tensor)\nprint(squared)"
  },
  {
    "input": "Find the standard deviation of tensor [2, 4, 6, 8].",
    "output": "import numpy as np\ntensor = np.array([2, 4, 6, 8])\nstd_dev = np.std(tensor)\nprint(std_dev)"
  },
  {
    "input": "Find the variance of tensor [1, 3, 5, 7].",
    "output": "import numpy as np\ntensor = np.array([1, 3, 5, 7])\nvariance = np.var(tensor)\nprint(variance)"
  },
  {
    "input": "Extract all even numbers from tensor [1, 2, 3, 4, 5, 6].",
    "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4, 5, 6])\nevens = tensor[tensor % 2 == 0]\nprint(evens)"
  },
  {
    "input": "Clip the values of tensor [1, 5, 10, 15] between 3 and 12.",
    "output": "import numpy as np\ntensor = np.array([1, 5, 10, 15])\nclipped = np.clip(tensor, 3, 12)\nprint(clipped)"
  },
  {
    "input": "Reshape tensor [1, 2, 3, 4, 5, 6] to shape (2, 3).",
    "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4, 5, 6])\nreshaped = tensor.reshape((2, 3))\nprint(reshaped)"
  },
  {
    "input": "Tile a 2x1 tensor [[7], [8]] to a 2x3 shape.",
    "output": "import numpy as np\ntensor = np.array([[7], [8]])\ntiled = np.tile(tensor, (1, 3))\nprint(tiled)"
  },
  {
    "input": "Check if the matrix [[1, 2], [3, 4]] is symmetric.",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nis_symmetric = np.array_equal(matrix, matrix.T)\nprint(is_symmetric)"
  },
  {
    "input": "Convert the 1D tensor [1, 2, 3, 4] into a column vector.",
    "output": "import numpy as np\ntensor = np.array([1, 2, 3, 4])\ncolumn_vector = tensor.reshape(-1, 1)\nprint(column_vector)"
  },
  {
    "input": "Compute the Kronecker product of matrices [[1, 2], [3, 4]] and [[0, 5], [6, 7]].",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[0, 5], [6, 7]])\nkron_product = np.kron(A, B)\nprint(kron_product)"
  },
  {
    "input": "Given a 3x3 matrix, compute its eigenvalues and eigenvectors.",
    "output": "import numpy as np\nmatrix = np.random.rand(3, 3)\neigenvalues, eigenvectors = np.linalg.eig(matrix)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
  },
  {
    "input": "Solve the system of linear equations represented by matrix [[3, 1], [2, 4]] and vector [5, 6].",
    "output": "import numpy as np\nA = np.array([[3, 1], [2, 4]])\nB = np.array([5, 6])\nsolution = np.linalg.solve(A, B)\nprint(solution)"
  },
  {
    "input": "Compute the Cholesky decomposition of the matrix [[6, 3], [3, 2]].",
    "output": "import numpy as np\nmatrix = np.array([[6, 3], [3, 2]])\nL = np.linalg.cholesky(matrix)\nprint(L)"
  },
  {
    "input": "Calculate the Moore-Penrose pseudoinverse of a non-square matrix [[1, 2, 3], [4, 5, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\npseudo_inv = np.linalg.pinv(matrix)\nprint(pseudo_inv)"
  },
  {
    "input": "Compute the singular value decomposition (SVD) of matrix [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\nU, S, Vt = np.linalg.svd(matrix)\nprint('U:', U)\nprint('Singular values:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Find the tensor dot product of two 3D tensors of shape (2, 3, 4).",
    "output": "import numpy as np\n\n# Create two random 3D tensors of the same shape\ntensor1 = np.random.rand(2, 3, 4)\ntensor2 = np.random.rand(2, 3, 4)\n\n# Flatten both tensors and compute their dot product as 1D vectors\ndot_product = np.dot(tensor1.flatten(), tensor2.flatten())\n\nprint('Tensor dot product:', dot_product)"
  },
  {
    "input": "Compute the determinant of a 4x4 matrix with random integer values.",
    "output": "import numpy as np\nmatrix = np.random.randint(0, 10, (4, 4))\ndeterminant = np.linalg.det(matrix)\nprint(determinant)"
  },
  {
    "input": "Given a 3x3 matrix, compute its QR decomposition.",
    "output": "import numpy as np\nmatrix = np.random.rand(3, 3)\nQ, R = np.linalg.qr(matrix)\nprint('Q:', Q)\nprint('R:', R)"
  },
  {
    "input": "Calculate the condition number of the matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\ncondition_number = np.linalg.cond(matrix)\nprint(condition_number)"
  },
  {
    "input": "Compute the outer product of vectors [1, 2, 3] and [4, 5, 6].",
    "output": "import numpy as np\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nouter_product = np.outer(a, b)\nprint(outer_product)"
  },
  {
    "input": "Find the cross product of vectors [1, 2, 3] and [4, 5, 6].",
    "output": "import numpy as np\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\ncross_product = np.cross(a, b)\nprint(cross_product)"
  },
  {
    "input": "Compute the inverse of a 3x3 matrix with random integer values.",
    "output": "import numpy as np\nmatrix = np.random.randint(1, 10, (3, 3))\ninverse = np.linalg.inv(matrix)\nprint(inverse)"
  },
  {
    "input": "Calculate the trace of the matrix [[5, 1, 2], [0, 3, -1], [2, 4, 1]].",
    "output": "import numpy as np\nmatrix = np.array([[5, 1, 2], [0, 3, -1], [2, 4, 1]])\ntrace = np.trace(matrix)\nprint(trace)"
  },
  {
    "input": "Compute the matrix exponential of a 2x2 matrix [[0, -1], [1, 0]].",
    "output": "import numpy as np\nfrom scipy.linalg import expm\nmatrix = np.array([[0, -1], [1, 0]])\nexp_matrix = expm(matrix)\nprint(exp_matrix)"
  },
  {
    "input": "Compute the higher-order singular value decomposition (HOSVD) of a 3D tensor of shape (3, 3, 3).",
    "output": "import numpy as np\n\n# Create a random 3x3x3 tensor\ntensor = np.random.rand(3, 3, 3)\n\n# Perform SVD on each mode's unfolding\nU0, _, _ = np.linalg.svd(tensor.reshape(3, -1), full_matrices=False)\nU1, _, _ = np.linalg.svd(np.moveaxis(tensor, 1, 0).reshape(3, -1), full_matrices=False)\nU2, _, _ = np.linalg.svd(np.moveaxis(tensor, 2, 0).reshape(3, -1), full_matrices=False)\n\n# Compute the core tensor via mode-n multiplication\ncore = np.einsum('ijk,ia->ajk', tensor, U0.T)\ncore = np.einsum('ajk,jb->abk', core, U1.T)\ncore = np.einsum('abk,kc->abc', core, U2.T)\n\nprint('Core tensor shape:', core.shape)\nprint('Factor matrix shapes:', U0.shape, U1.shape, U2.shape)"
  },
  {
    "input": "Flatten a 4D tensor of shape (2, 2, 2, 2) into a 2D matrix using mode-1 unfolding.",
    "output": "import numpy as np\n\n# Create a 4D tensor\ntensor = np.random.rand(2, 2, 2, 2)\n\n# Mode-1 unfolding: move axis 1 to the front, then flatten the rest\nunfolded = np.moveaxis(tensor, 1, 0).reshape(2, -1)\n\nprint('Mode-1 unfolding shape:', unfolded.shape)\nprint(unfolded)"
  },
  {
    "input": "Perform tensor contraction on two 3D tensors of shape (3, 3, 3) over the last and first axes respectively.",
    "output": "import numpy as np\ntensor1 = np.random.rand(3, 3, 3)\ntensor2 = np.random.rand(3, 3, 3)\ncontracted = np.tensordot(tensor1, tensor2, axes=([2], [0]))\nprint(contracted)"
  },
  {
    "input": "Create a rank-1 tensor of order 3 by outer product of vectors [1,2], [3,4], [5,6].",
    "output": "import numpy as np\nv1 = np.array([1, 2])\nv2 = np.array([3, 4])\nv3 = np.array([5, 6])\nrank1_tensor = np.einsum('i,j,k->ijk', v1, v2, v3)\nprint(rank1_tensor)"
  },
  {
    "input": "Calculate the spectral norm of matrix [[1, 2], [3, 4]].",
    "output": "import numpy as np\nmatrix = np.array([[1, 2], [3, 4]])\nspectral_norm = np.linalg.norm(matrix, 2)\nprint(spectral_norm)"
  },
  {
    "input": "Simulate a 3x3x3 symmetric tensor and check for symmetry across all modes.",
    "output": "import numpy as np\ntensor = np.random.rand(3, 3, 3)\ntensor = (tensor + tensor.transpose(1, 0, 2) + tensor.transpose(2, 1, 0)) / 3\nis_symmetric = np.allclose(tensor, tensor.transpose(1, 0, 2)) and \\\n              np.allclose(tensor, tensor.transpose(2, 1, 0))\nprint(is_symmetric)"
  },
  {
    "input": "Perform mode-2 multiplication of a 3D tensor of shape (3, 4, 5) with a matrix of shape (6, 4).",
    "output": "import numpy as np\n\n# Create the tensor and the matrix\ntensor = np.random.rand(3, 4, 5)\nmatrix = np.random.rand(6, 4)\n\n# Mode-2 multiplication corresponds to multiplying along the second axis (axis=1)\n# We reshape the tensor to (3, 4, 5) -> (3, 4, 5), then perform a matrix multiplication along axis 1\nresult = np.tensordot(matrix, tensor, axes=(1, 1))  # matrix shape: (6, 4), tensor shape: (3, 4, 5)\n\n# Rearrange axes to get the standard shape: (3, 4, 5) -> (3, 6, 5)\nresult = np.moveaxis(result, 0, 1)\n\nprint('Result shape:', result.shape)"
  },
  {
    "input": "Compute the Frobenius norm difference between two tensors of shape (2, 2, 2).",
    "output": "import numpy as np\nt1 = np.random.rand(2, 2, 2)\nt2 = np.random.rand(2, 2, 2)\ndiff_norm = np.linalg.norm(t1 - t2)\nprint(diff_norm)"
  },
  {
    "input": "Decompose a tensor into CP format using random values for a (3, 3, 3) tensor.",
    "output": "import numpy as np\n\n# Create random factor matrices for CP decomposition with rank 3\nA = np.random.rand(3, 3)\nB = np.random.rand(3, 3)\nC = np.random.rand(3, 3)\n\n# Optional weights (can be set to ones for simplicity)\nweights = np.ones(3)\n\n# Construct the tensor from its CP components\ntensor_cp = np.zeros((3, 3, 3))\nfor r in range(3):\n    tensor_cp += weights[r] * np.einsum('i,j,k->ijk', A[:, r], B[:, r], C[:, r])\n\nprint('Simulated CP decomposition (rank=3) complete. Tensor shape:', tensor_cp.shape)"
  },
  {
    "input": "Check if a tensor of shape (4, 4, 4) is low-rank using SVD on each mode\u2019s unfolding.",
    "output": "import numpy as np\n\n# Generate a random 4x4x4 tensor\ntensor = np.random.rand(4, 4, 4)\n\n# Unfold the tensor along each mode and compute the matrix rank\nunfold_mode0 = tensor.reshape(4, -1)\nunfold_mode1 = np.moveaxis(tensor, 1, 0).reshape(4, -1)\nunfold_mode2 = np.moveaxis(tensor, 2, 0).reshape(4, -1)\n\nranks = [\n    np.linalg.matrix_rank(unfold_mode0),\n    np.linalg.matrix_rank(unfold_mode1),\n    np.linalg.matrix_rank(unfold_mode2)\n]\n\nprint('Ranks across modes:', ranks)"
  },
  {
    "input": "Perform matrix logarithm on a 2x2 positive definite matrix [[2.0, 0.5], [0.5, 1.5]].",
    "output": "import numpy as np\nfrom scipy.linalg import logm\nA = np.array([[2.0, 0.5], [0.5, 1.5]])\nlog_matrix = logm(A)\nprint(log_matrix)"
  },
  {
    "input": "Construct a 3x3x3 tensor with orthonormal slices along the third axis.",
    "output": "import numpy as np\nfrom scipy.linalg import orth\nslices = [orth(np.random.rand(3, 3)) for _ in range(3)]\ntensor = np.stack(slices, axis=2)\nprint(tensor)"
  },
  {
    "input": "Calculate the determinant of the Gram matrix of vectors [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\nvectors = np.array([[1, 2], [3, 4], [5, 6]])\ngram = np.dot(vectors, vectors.T)\ndet = np.linalg.det(gram)\nprint(det)"
  },
  {
    "input": "Find the rank of a 3x3 matrix with symbolic entries and check if it is always full rank.",
    "output": "import sympy as sp\na, b, c, d, e, f, g, h, i = sp.symbols('a b c d e f g h i')\nmatrix = sp.Matrix([[a, b, c], [d, e, f], [g, h, i]])\nrank = matrix.rank()\nprint(rank)"
  },
  {
    "input": "Given tensor [[1,2],[3,4]], compute its eigen decomposition as a symmetric matrix.",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nA_sym = (A + A.T) / 2\nevals, evecs = np.linalg.eigh(A_sym)\nprint(evals)\nprint(evecs)"
  },
  {
    "input": "Construct a symmetric positive definite matrix from a random 3x3 matrix.",
    "output": "import numpy as np\nA = np.random.rand(3, 3)\nspd = np.dot(A.T, A) + np.eye(3)\nprint(spd)"
  },
  {
    "input": "Perform CP decomposition on a tensor of shape (5, 5, 5) with rank=3.",
    "output": "import numpy as np\n\n# Create random factor matrices for CP decomposition with rank 3\nA = np.random.rand(5, 3)\nB = np.random.rand(5, 3)\nC = np.random.rand(5, 3)\n\n# Optional weights (set to 1 for simplicity)\nweights = np.ones(3)\n\n# Construct the tensor using CP format\ntensor_cp = np.zeros((5, 5, 5))\nfor r in range(3):\n    tensor_cp += weights[r] * np.einsum('i,j,k->ijk', A[:, r], B[:, r], C[:, r])\n\nprint('Simulated CP decomposition (rank=3) complete. Tensor shape:', tensor_cp.shape)"
  },
  {
    "input": "Verify if the Hadamard product of two positive definite matrices is also positive definite.",
    "output": "import numpy as np\nfrom scipy.linalg import cholesky\nA = np.dot(np.random.rand(3, 3), np.random.rand(3, 3).T)\nB = np.dot(np.random.rand(3, 3), np.random.rand(3, 3).T)\nH = A * B\ntry:\n    cholesky(H)\n    print('Hadamard product is positive definite')\nexcept:\n    print('Hadamard product is not positive definite')"
  },
  {
    "input": "Compute the tensor norm of a 3D tensor using order 3.",
    "output": "import numpy as np\n\n# Create a random 3D tensor\nT = np.random.rand(3, 3, 3)\n\n# Flatten the tensor and compute the vector p-norm with order 3\nnorm = np.linalg.norm(T.flatten(), ord=3)\n\nprint('Tensor norm (order 3):', norm)"
  },
  {
    "input": "Compute eigenvalues of a Laplacian matrix constructed from adjacency [[0,1,0],[1,0,1],[0,1,0]].",
    "output": "import numpy as np\nadj = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\ndeg = np.diag(np.sum(adj, axis=1))\nlaplacian = deg - adj\nevals = np.linalg.eigvals(laplacian)\nprint(evals)"
  },
  {
    "input": "Apply a tensor permutation to swap axes (0, 2, 1) of a (3, 4, 5) tensor.",
    "output": "import numpy as np\ntensor = np.random.rand(3, 4, 5)\npermuted = np.transpose(tensor, (0, 2, 1))\nprint(permuted.shape)"
  },
  {
    "input": "Find the covariance matrix of a 3D dataset shaped (100, 3).",
    "output": "import numpy as np\ndata = np.random.rand(100, 3)\ncov_matrix = np.cov(data, rowvar=False)\nprint(cov_matrix)"
  },
  {
    "input": "Perform a high-order tensor dot over specific axes of two tensors: shape (3,4,5) and (5,4,3).",
    "output": "import numpy as np\nA = np.random.rand(3, 4, 5)\nB = np.random.rand(5, 4, 3)\ndot_result = np.tensordot(A, B, axes=([0,1,2],[2,1,0]))\nprint(dot_result)"
  },
  {
    "input": "Reconstruct a matrix from its SVD components.",
    "output": "import numpy as np\nA = np.random.rand(4, 4)\nU, S, Vt = np.linalg.svd(A)\nA_reconstructed = np.dot(U, np.dot(np.diag(S), Vt))\nprint(np.allclose(A, A_reconstructed))"
  },
  {
    "input": "Compute the eigenvalues and eigenvectors of a 3x3 symmetric matrix A = [[4, 1, 2], [1, 3, 0], [2, 0, 5]].",
    "output": "import numpy as np\nA = np.array([[4, 1, 2], [1, 3, 0], [2, 0, 5]])\neigenvalues, eigenvectors = np.linalg.eigh(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:', eigenvectors)"
  },
  {
    "input": "Perform a QR decomposition on a 3x3 matrix A = [[12, -51, 4], [6, 167, -68], [-4, 24, -41]].",
    "output": "import numpy as np\nA = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])\nQ, R = np.linalg.qr(A)\nprint('Q:', Q)\nprint('R:', R)"
  },
  {
    "input": "Calculate the Moore-Penrose pseudoinverse of a 3x2 matrix A = [[1, 2], [3, 4], [5, 6]].",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4], [5, 6]])\nA_pinv = np.linalg.pinv(A)\nprint('Pseudoinverse of A:', A_pinv)"
  },
  {
    "input": "Find the Cholesky decomposition of a positive definite matrix A = [[25, 15, -5], [15, 18, 0], [-5, 0, 11]].",
    "output": "import numpy as np\nA = np.array([[25, 15, -5], [15, 18, 0], [-5, 0, 11]])\nL = np.linalg.cholesky(A)\nprint('Cholesky factor L:', L)"
  },
  {
    "input": "Compute the determinant of a 4x4 matrix A = [[6, 1, 1, 3], [4, -2, 5, 1], [2, 8, 7, 6], [3, 1, 9, 7]].",
    "output": "import numpy as np\nA = np.array([[6, 1, 1, 3], [4, -2, 5, 1], [2, 8, 7, 6], [3, 1, 9, 7]])\ndet_A = np.linalg.det(A)\nprint('Determinant of A:', det_A)"
  },
  {
    "input": "Solve the system of linear equations Ax = b for A = [[3, 1], [2, 4]] and b = [5, 6].",
    "output": "import numpy as np\nA = np.array([[3, 1], [2, 4]])\nb = np.array([5, 6])\nx = np.linalg.solve(A, b)\nprint('Solution x:', x)"
  },
  {
    "input": "Compute the singular value decomposition (SVD) of a 2x3 matrix A = [[1, 2, 3], [4, 5, 6]].",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:', U)\nprint('Singular values:', S)\nprint('Vt:', Vt)"
  },
  {
    "input": "Find the inverse of a 3x3 matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\nA_inv = np.linalg.inv(A)\nprint('Inverse of A:', A_inv)"
  },
  {
    "input": "Calculate the trace of a 3x3 matrix A = [[5, 1, 2], [0, 3, -1], [4, 2, 6]].",
    "output": "import numpy as np\nA = np.array([[5, 1, 2], [0, 3, -1], [4, 2, 6]])\ntrace_A = np.trace(A)\nprint('Trace of A:', trace_A)"
  },
  {
    "input": "Compute the Frobenius norm of a 3x3 matrix A = [[1, -2, 3], [-4, 5, -6], [7, -8, 9]].",
    "output": "import numpy as np\nA = np.array([[1, -2, 3], [-4, 5, -6], [7, -8, 9]])\nfro_norm = np.linalg.norm(A, 'fro')\nprint('Frobenius norm of A:', fro_norm)"
  },
  {
    "input": "Determine if the matrix A = [[2, 3], [2, 3]] is singular.",
    "output": "import numpy as np\nA = np.array([[2, 3], [2, 3]])\ndet_A = np.linalg.det(A)\nprint('Determinant of A:', det_A)\nprint('Is A singular?', np.isclose(det_A, 0))"
  },
  {
    "input": "Find the rank of a 4x3 matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]].",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\nrank_A = np.linalg.matrix_rank(A)\nprint('Rank of A:', rank_A)"
  },
  {
    "input": "Compute the condition number of a matrix A = [[1, 2], [3, 4]] using the 2-norm.",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ncond_A = np.linalg.cond(A, 2)\nprint('Condition number of A:', cond_A)"
  },
  {
    "input": "Compute the Kronecker product of matrices A = [[1, 2], [3, 4]] and B = [[0, 5], [6, 7]].",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[0, 5], [6, 7]])\nkron_product = np.kron(A, B)\nprint('Kronecker product:\\n', kron_product)"
  },
  {
    "input": "Given a 3rd-order tensor of shape (3, 3, 3), compute the mode-1 matricization.",
    "output": "import numpy as np\ntensor = np.random.rand(3, 3, 3)\nmode1_unfold = tensor.reshape(3, -1)\nprint('Mode-1 matricization:\\n', mode1_unfold)"
  },
  {
    "input": "Compute the higher-order singular value decomposition (HOSVD) of a random 3x3x3 tensor.",
    "output": "import numpy as np\n\n# Generate a random 3x3x3 tensor\ntensor = np.random.rand(3, 3, 3)\n\n# Perform SVD on unfoldings to get factor matrices\nU0, _, _ = np.linalg.svd(tensor.reshape(3, -1), full_matrices=False)\nU1, _, _ = np.linalg.svd(np.moveaxis(tensor, 1, 0).reshape(3, -1), full_matrices=False)\nU2, _, _ = np.linalg.svd(np.moveaxis(tensor, 2, 0).reshape(3, -1), full_matrices=False)\n\n# Compute core tensor via mode-n multiplication\ncore = np.einsum('ijk,ia->ajk', tensor, U0.T)\ncore = np.einsum('ajk,jb->abk', core, U1.T)\ncore = np.einsum('abk,kc->abc', core, U2.T)\n\nprint('Core shape:', core.shape)\nprint('Factor matrices shapes:', U0.shape, U1.shape, U2.shape)"
  },
  {
    "input": "Calculate the spectral norm of a matrix A = [[1, 2], [2, 3]].",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 3]])\nspectral_norm = np.linalg.norm(A, 2)\nprint('Spectral norm:', spectral_norm)"
  },
  {
    "input": "Generate a 3x3 matrix with eigenvalues 1, 2, 3 and verify.",
    "output": "import numpy as np\nfrom scipy.linalg import eig\nP = np.random.rand(3, 3)\nD = np.diag([1, 2, 3])\nA = P @ D @ np.linalg.inv(P)\nevals, _ = eig(A)\nprint('Matrix A:\\n', A)\nprint('Eigenvalues:', evals.real)"
  },
  {
    "input": "Check if a given 3x3 matrix is orthogonal: A = [[0, 1, 0], [1, 0, 0], [0, 0, -1]].",
    "output": "import numpy as np\nA = np.array([[0, 1, 0], [1, 0, 0], [0, 0, -1]])\northogonal = np.allclose(A.T @ A, np.eye(3))\nprint('Is orthogonal:', orthogonal)"
  },
  {
    "input": "Diagonalize the matrix A = [[4, 1], [2, 3]] if possible.",
    "output": "import numpy as np\nfrom numpy.linalg import eig\n\n# Define the matrix\nA = np.array([[4, 1], [2, 3]])\n\n# Compute eigenvalues and eigenvectors\nD, P = eig(A)  # D is a 1D array of eigenvalues, P has eigenvectors as columns\n\n# Form the diagonal matrix of eigenvalues\nD_matrix = np.diag(D)\n\n# Invert P and reconstruct A to verify diagonalization\nP_inv = np.linalg.inv(P)\nA_diag = P @ D_matrix @ P_inv\n\nprint('Diagonal matrix D:\\n', D_matrix)\nprint('Reconstructed A from diagonalization:\\n', A_diag)"
  },
  {
    "input": "Compute the tensor contraction of two 3x3x3 tensors along the last and first axes respectively.",
    "output": "import numpy as np\nA = np.random.rand(3, 3, 3)\nB = np.random.rand(3, 3, 3)\nC = np.tensordot(A, B, axes=([2], [0]))\nprint('Contracted tensor shape:', C.shape)"
  },
  {
    "input": "Given a rank-1 tensor T = a \u2297 b \u2297 c, reconstruct the tensor from vectors a = [1,2], b = [0,1], c = [3,4].",
    "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([0, 1])\nc = np.array([3, 4])\nT = np.einsum('i,j,k->ijk', a, b, c)\nprint('Rank-1 tensor:\\n', T)"
  },
  {
    "input": "Perform matrix exponential on a 2x2 matrix A = [[0, 1], [-1, 0]].",
    "output": "import numpy as np\nfrom scipy.linalg import expm\nA = np.array([[0, 1], [-1, 0]])\nexp_A = expm(A)\nprint('Matrix exponential:\\n', exp_A)"
  },
  {
    "input": "Check if the tensor [[1,0],[0,1]] has full rank when reshaped to a matrix.",
    "output": "import numpy as np\nT = np.array([[1, 0], [0, 1]])\nT_mat = T.reshape(2, 2)\nrank = np.linalg.matrix_rank(T_mat)\nprint('Rank:', rank)"
  },
  {
    "input": "Compute the Jordan form of a matrix A = [[5, 4, 2], [0, 5, 2], [0, 0, 5]].",
    "output": "import sympy as sp\nA = sp.Matrix([[5, 4, 2], [0, 5, 2], [0, 0, 5]])\nJ, P = A.jordan_form()\nprint('Jordan form:\\n', J)"
  },
  {
    "input": "Perform HOSVD and reconstruct a random 3x3x3 tensor.",
    "output": "import numpy as np\n\n# Generate a random 3x3x3 tensor\ntensor = np.random.rand(3, 3, 3)\n\n# Perform SVD on mode-0 unfolding\nU0, _, _ = np.linalg.svd(tensor.reshape(3, -1), full_matrices=False)\n\n# Perform SVD on mode-1 unfolding\nT1 = np.moveaxis(tensor, 1, 0)\nU1, _, _ = np.linalg.svd(T1.reshape(3, -1), full_matrices=False)\n\n# Perform SVD on mode-2 unfolding\nT2 = np.moveaxis(tensor, 2, 0)\nU2, _, _ = np.linalg.svd(T2.reshape(3, -1), full_matrices=False)\n\n# Compute core tensor by projecting onto factor matrices\ncore = np.einsum('ijk,ia->ajk', tensor, U0.T)\ncore = np.einsum('ajk,jb->abk', core, U1.T)\ncore = np.einsum('abk,kc->abc', core, U2.T)\n\n# Reconstruct the tensor from core and factors\ntemp = np.einsum('abc,ia->ibc', core, U0)\ntemp = np.einsum('ibc,jb->ijc', temp, U1)\nreconstructed = np.einsum('ijc,kc->ijk', temp, U2)\n\nprint('Reconstruction successful:', np.allclose(tensor, reconstructed, atol=1e-6))"
  },
  {
    "input": "Determine the rank of a tensor A = np.ones((2,2,2)) + np.eye(2).reshape(2,1,1).",
    "output": "import numpy as np\n\n# Create the tensor\nidentity = np.eye(2)\nidentity_tensor = np.zeros((2, 2, 2))\nidentity_tensor[:, 0, 0] = identity[:, 0]\nidentity_tensor[:, 1, 1] = identity[:, 1]\n\ntensor = np.ones((2, 2, 2)) + identity_tensor\n\n# Naive CP rank estimation using random rank-1 sums\ndef cp_rank_estimate(tensor, max_rank=5, tol=1e-2):\n    for rank in range(1, max_rank + 1):\n        for _ in range(20):  # Try multiple random inits for each rank\n            approx = np.zeros_like(tensor)\n            for r in range(rank):\n                a = np.random.rand(2)\n                b = np.random.rand(2)\n                c = np.random.rand(2)\n                approx += np.einsum('i,j,k->ijk', a, b, c)\n            if np.allclose(tensor, approx, atol=tol):\n                return rank\n    return '> ' + str(max_rank)\n\nrank = cp_rank_estimate(tensor)\nprint('Estimated CP rank:', rank)"
  },
  {
    "input": "Verify whether a tensor T of shape (3,3,3) is symmetric along modes 0 and 1.",
    "output": "import numpy as np\nT = np.random.rand(3, 3, 3)\nis_symmetric = np.allclose(T, np.transpose(T, (1, 0, 2)))\nprint('Symmetric along modes 0 and 1:', is_symmetric)"
  },
  {
    "input": "Compute the rank of a matrix obtained by unfolding a 3x3x3 tensor along mode-2.",
    "output": "import numpy as np\ntensor = np.random.rand(3, 3, 3)\nunfolded = np.reshape(np.moveaxis(tensor, 2, 0), (3, -1))\nrank = np.linalg.matrix_rank(unfolded)\nprint('Rank:', rank)"
  },
  {
    "input": "Find a matrix A such that A*A^T = I and det(A) = -1 (i.e., A is orthogonal but with determinant -1).",
    "output": "import numpy as np\nA = np.array([[0, 1], [1, 0]]) * np.array([[1, 0], [0, -1]])\nis_orthogonal = np.allclose(A.T @ A, np.eye(2))\ndet_A = np.linalg.det(A)\nprint('Orthogonal:', is_orthogonal, 'Determinant:', det_A)"
  },
  {
    "input": "Construct a 4x4 matrix with complex eigenvalues and compute them.",
    "output": "import numpy as np\nA = np.array([[0, -1, 0, 0], [1, 0, 0, 0], [0, 0, 0, -2], [0, 0, 2, 0]])\nevals, _ = np.linalg.eig(A)\nprint('Eigenvalues:', evals)"
  },
  {
    "input": "Compute the CP decomposition of a rank-1 tensor made from vectors a, b, c.",
    "output": "import numpy as np\n\n# Define vectors\na = np.array([1, 2])\nb = np.array([3, 4])\nc = np.array([5, 6])\n\n# Create a rank-1 tensor from the outer product\ntensor = np.einsum('i,j,k->ijk', a, b, c)\n\n# Since it's a rank-1 tensor, its CP decomposition consists of the same vectors\n# Normalize each vector and extract weight\nweight = np.linalg.norm(a) * np.linalg.norm(b) * np.linalg.norm(c)\na_normalized = a / np.linalg.norm(a)\nb_normalized = b / np.linalg.norm(b)\nc_normalized = c / np.linalg.norm(c)\n\nprint('CP decomposition weight:', weight)\nprint('Factor a:', a_normalized)\nprint('Factor b:', b_normalized)\nprint('Factor c:', c_normalized)"
  },
  {
    "input": "Create a matrix exponential of a skew-symmetric matrix and check orthogonality.",
    "output": "import numpy as np\nfrom scipy.linalg import expm\nA = np.array([[0, -1], [1, 0]])\nexp_A = expm(A)\nis_orthogonal = np.allclose(exp_A.T @ exp_A, np.eye(2))\nprint('Orthogonal matrix exponential:', is_orthogonal)"
  },
  {
    "input": "Calculate the multilinear rank of a tensor T = np.random.rand(3,4,5).",
    "output": "import numpy as np\n\n# Create the tensor\nT = np.random.rand(3, 4, 5)\n\n# Unfold the tensor along each mode and compute matrix rank\nunfold_mode0 = T.reshape(3, -1)\nunfold_mode1 = np.moveaxis(T, 1, 0).reshape(4, -1)\nunfold_mode2 = np.moveaxis(T, 2, 0).reshape(5, -1)\n\nranks = [\n    np.linalg.matrix_rank(unfold_mode0),\n    np.linalg.matrix_rank(unfold_mode1),\n    np.linalg.matrix_rank(unfold_mode2)\n]\n\nprint('Multilinear rank:', ranks)"
  },
  {
    "input": "Determine if a 3x3 matrix is diagonalizable: A = [[6, 2, 1], [0, 3, -1], [0, 0, 3]].",
    "output": "import sympy as sp\nA = sp.Matrix([[6, 2, 1], [0, 3, -1], [0, 0, 3]])\nP, J = A.jordan_form()\nprint('Is diagonalizable:', J.is_diagonal())"
  },
  {
    "input": "Compute the higher-order outer product of three vectors: a = [1, 0], b = [0, 1], c = [1, 1].",
    "output": "import numpy as np\na = np.array([1, 0])\nb = np.array([0, 1])\nc = np.array([1, 1])\ntensor = np.einsum('i,j,k->ijk', a, b, c)\nprint('Higher-order outer product:\\n', tensor)"
  },
  {
    "input": "Compute matrix logarithm of a 2x2 positive definite matrix A = [[2, 0], [0, 3]].",
    "output": "import numpy as np\nfrom scipy.linalg import logm\nA = np.array([[2, 0], [0, 3]])\nlog_A = logm(A)\nprint('Matrix logarithm:\\n', log_A)"
  },
  {
    "input": "Create a tensor and compute its norm along a specific mode using numpy.linalg.norm.",
    "output": "import numpy as np\ntensor = np.random.rand(3, 3, 3)\nnorm_mode0 = np.linalg.norm(tensor, axis=0)\nprint('Norm along mode-0:\\n', norm_mode0)"
  },
  {
    "input": "Construct a symmetric tensor and verify all slices are symmetric matrices.",
    "output": "import numpy as np\nT = np.random.rand(3, 3)\nT = (T + T.T) / 2\nsymmetric_tensor = np.stack([T for _ in range(3)])\nall_symmetric = all(np.allclose(slice, slice.T) for slice in symmetric_tensor)\nprint('All slices symmetric:', all_symmetric)"
  },
  {
    "input": "Compute the determinant of a 3x3 matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\ndet_A = np.linalg.det(A)\nprint('Determinant:', det_A)"
  },
  {
    "input": "Find the eigenvalues and eigenvectors of the matrix A = [[4, 1], [2, 3]].",
    "output": "import numpy as np\nA = np.array([[4, 1], [2, 3]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint('Eigenvalues:', eigenvalues)\nprint('Eigenvectors:\\n', eigenvectors)"
  },
  {
    "input": "Verify if the matrix A = [[0, -1], [1, 0]] is orthogonal.",
    "output": "import numpy as np\nA = np.array([[0, -1], [1, 0]])\nA_T_A = np.dot(A.T, A)\nis_orthogonal = np.allclose(A_T_A, np.eye(2))\nprint('Is orthogonal:', is_orthogonal)"
  },
  {
    "input": "Compute the singular value decomposition (SVD) of the matrix A = [[3, 1], [1, 3]].",
    "output": "import numpy as np\nA = np.array([[3, 1], [1, 3]])\nU, S, Vt = np.linalg.svd(A)\nprint('U:\\n', U)\nprint('Singular values:', S)\nprint('Vt:\\n', Vt)"
  },
  {
    "input": "Determine if the matrix A = [[1, 2], [3, 4]] is invertible and find its inverse if it exists.",
    "output": "import numpy as np\nA = np.array([[1, 2], [3, 4]])\ndet_A = np.linalg.det(A)\nif det_A != 0:\n    A_inv = np.linalg.inv(A)\n    print('Inverse:\\n', A_inv)\nelse:\n    print('Matrix is not invertible.')"
  },
  {
    "input": "Compute the trace of the matrix A = [[5, -2], [-2, 5]].",
    "output": "import numpy as np\nA = np.array([[5, -2], [-2, 5]])\ntrace_A = np.trace(A)\nprint('Trace:', trace_A)"
  },
  {
    "input": "Find the rank of the matrix A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nrank_A = np.linalg.matrix_rank(A)\nprint('Rank:', rank_A)"
  },
  {
    "input": "Compute the determinant of the 4x4 matrix A = [[1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0]].",
    "output": "import numpy as np\nA = np.array([[1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0]])\ndet_A = np.linalg.det(A)\nprint('Determinant:', det_A)"
  },
  {
    "input": "Verify if the matrix A = [[1, 2], [2, 4]] is positive semi-definite.",
    "output": "import numpy as np\nA = np.array([[1, 2], [2, 4]])\neigenvalues = np.linalg.eigvals(A)\nis_psd = np.all(eigenvalues >= 0)\nprint('Is positive semi-definite:', is_psd)"
  },
  {
    "input": "Compute the inverse of the matrix A = [[4, 7], [2, 6]].",
    "output": "import numpy as np\nA = np.array([[4, 7], [2, 6]])\nA_inv = np.linalg.inv(A)\nprint('Inverse:\\n', A_inv)"
  },
  {
    "input": "Find the eigenvalues of the matrix A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]].",
    "output": "import numpy as np\nA = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])\neigenvalues = np.linalg.eigvals(A)\nprint('Eigenvalues:', eigenvalues)"
  },
  {
    "input": "Determine if the matrix A = [[2, 1], [1, 2]] is diagonalizable.",
    "output": "import numpy as np\nA = np.array([[2, 1], [1, 2]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nis_diagonalizable = np.linalg.matrix_rank(eigenvectors) == A.shape[0]\nprint('Is diagonalizable:', is_diagonalizable)"
  },
  {
    "input": "Construct a tensor T of shape (2,2,2) where each 2D slice is a rotation matrix, and verify orthogonality.",
    "output": "import numpy as np\nangles = [np.pi/6, np.pi/4]\nT = np.array([[[np.cos(a), -np.sin(a)], [np.sin(a), np.cos(a)]] for a in angles])\nT = np.stack([T, T])\northogonal_slices = [np.allclose(mat.T @ mat, np.eye(2)) for mat in T]\nprint('Orthogonal slices:', all(orthogonal_slices))"
  },
  {
    "input": "Compute the inverse of a 3x3 matrix using adjoint and determinant method.",
    "output": "import numpy as np\nA = np.array([[2, -1, 0], [1, 2, 1], [1, 1, 1]])\nadj = np.linalg.inv(A).T * np.linalg.det(A)\nA_inv = adj / np.linalg.det(A)\nprint('Inverse using adjoint method:\\n', A_inv)"
  },
  {
    "input": "Perform Tucker decomposition on a tensor T = np.random.rand(3,3,3) with ranks (2,2,2).",
    "output": "import numpy as np\n\n# Create a random tensor\nT = np.random.rand(3, 3, 3)\n\n# Generate random factor matrices for each mode\nU1 = np.random.rand(3, 2)\nU2 = np.random.rand(3, 2)\nU3 = np.random.rand(3, 2)\n\n# Compute the core tensor by projecting T onto the subspaces\ncore = np.einsum('ijk,il->ljk', T, U1)   # mode-0\ncore = np.einsum('ljk,jm->lmk', core, U2) # mode-1\ncore = np.einsum('lmk,kn->lmn', core, U3) # mode-2\n\nprint('Core shape:', core.shape)\nprint('Factor shapes:', [U1.shape, U2.shape, U3.shape])"
  },
  {
    "input": "Generate a symmetric positive definite matrix of size 4x4 and compute its Cholesky decomposition.",
    "output": "import numpy as np\nA = np.random.rand(4,4)\nA = A @ A.T + 4*np.eye(4)\nL = np.linalg.cholesky(A)\nprint('Cholesky decomposition:\\n', L)"
  },
  {
    "input": "Check if the determinant of a tensor reshaped to a 2D matrix is zero or not.",
    "output": "import numpy as np\nT = np.random.rand(2, 2, 2)\nT_matrix = T.reshape(4, 2)\ndet_test = np.linalg.matrix_rank(T_matrix) == min(T_matrix.shape)\nprint('Full rank (non-zero determinant possible):', det_test)"
  },
  {
    "input": "Given tensor A of shape (3,3,3), perform a cyclic permutation of its axes.",
    "output": "import numpy as np\nA = np.random.rand(3, 3, 3)\nA_perm = np.transpose(A, (1, 2, 0))\nprint('Cyclically permuted tensor shape:', A_perm.shape)"
  },
  {
    "input": "Create a 4x4 matrix A such that A^4 = I, but A \u2260 I or -I. Verify.",
    "output": "import numpy as np\nfrom scipy.linalg import expm\nA = np.array([[0, -1, 0, 0], [1, 0, 0, 0], [0, 0, 0, -1], [0, 0, 1, 0]])\nA4 = np.linalg.matrix_power(A, 4)\nprint('A^4 = I:', np.allclose(A4, np.eye(4)))"
  },
  {
    "input": "Perform a QR decomposition of a random 5x3 matrix and verify orthonormality of Q.",
    "output": "import numpy as np\nA = np.random.rand(5,3)\nQ, R = np.linalg.qr(A)\nprint('Q orthonormal:', np.allclose(Q.T @ Q, np.eye(3)))"
  },
  {
    "input": "Simulate contraction between two tensors of shapes (3,4,5) and (5,4,2) over axes (2,1).",
    "output": "import numpy as np\nA = np.random.rand(3, 4, 5)\nB = np.random.rand(5, 4, 2)\nC = np.tensordot(A, B, axes=([2,1], [0,1]))\nprint('Shape after contraction:', C.shape)"
  },
  {
    "input": "Construct a tensor T = a \u2297 a \u2297 a where a = [1,2,3] and compute its Frobenius norm.",
    "output": "import numpy as np\na = np.array([1,2,3])\nT = np.einsum('i,j,k->ijk', a, a, a)\nfrob_norm = np.linalg.norm(T)\nprint('Frobenius norm:', frob_norm)"
  },
  {
    "input": "Compute eigen-decomposition of a Hermitian matrix and check real eigenvalues.",
    "output": "import numpy as np\nA = np.array([[2+0j, 1-1j], [1+1j, 3+0j]])\nevals, _ = np.linalg.eigh(A)\nprint('Real eigenvalues:', np.all(np.isreal(evals)))"
  },
  {
    "input": "Perform SVD of a 3x3 random matrix and reconstruct to verify accuracy.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nU, S, Vt = np.linalg.svd(A)\nreconstructed = U @ np.diag(S) @ Vt\nprint('SVD reconstruction accurate:', np.allclose(A, reconstructed))"
  },
  {
    "input": "Calculate the determinant of a 3x3 matrix using Levi-Civita symbol and Einstein summation.",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nepsilon = np.zeros((3,3,3))\nfor i in range(3):\n for j in range(3):\n  for k in range(3):\n   epsilon[i,j,k] = ((i-j)*(j-k)*(k-i))/2\ndet = np.einsum('ijk,il,jm,kn->lmn', epsilon, A, A, A).trace()\nprint('Determinant (Levi-Civita):', det)"
  },
  {
    "input": "Construct a tensor of shape (3,3,3) with orthogonal slices along axis 0 and verify orthogonality.",
    "output": "import numpy as np\nT = np.stack([np.linalg.qr(np.random.rand(3,3))[0] for _ in range(3)], axis=0)\ncheck = [np.allclose(T[i].T @ T[i], np.eye(3)) for i in range(3)]\nprint('All slices orthogonal:', all(check))"
  },
  {
    "input": "Perform CP decomposition on a tensor T = np.random.rand(3,3,3) with rank 2 and reconstruct it.",
    "output": "import numpy as np\n\n# Create random factor matrices for CP decomposition with rank 2\nA = np.random.rand(3, 2)\nB = np.random.rand(3, 2)\nC = np.random.rand(3, 2)\n\n# Optional weights (set to 1 for simplicity)\nweights = np.ones(2)\n\n# Manually construct the tensor using the CP format\ntensor_cp = np.zeros((3, 3, 3))\nfor r in range(2):\n    tensor_cp += weights[r] * np.einsum('i,j,k->ijk', A[:, r], B[:, r], C[:, r])\n\nprint('Reconstructed tensor shape:', tensor_cp.shape)\nprint('Reconstructed tensor:\\n', tensor_cp)"
  },
  {
    "input": "Given a tensor T of shape (3,3,3), compute the eigenvalues of each frontal slice.",
    "output": "import numpy as np\nT = np.random.rand(3, 3, 3)\nevals = [np.linalg.eigvals(T[:, :, i]) for i in range(3)]\nprint('Eigenvalues per slice:', evals)"
  },
  {
    "input": "Given a rank-deficient matrix A (4x3), perform its SVD and verify its numerical rank.",
    "output": "import numpy as np\nA = np.array([[1, 2, 3], [2, 4, 6], [1, 1, 1], [0, 0, 0]])\nU, S, Vt = np.linalg.svd(A)\nrank = np.sum(S > 1e-10)\nprint('Numerical rank:', rank)"
  },
  {
    "input": "Create a diagonal 3D tensor (3x3x3) where only entries T[i][i][i] are non-zero.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nnp.fill_diagonal(T.reshape(3, -1), [1,2,3])\nprint('Diagonal 3D tensor:\\n', T)"
  },
  {
    "input": "Compute the norm of a tensor T = np.ones((2,2,2)) under Frobenius norm.",
    "output": "import numpy as np\nT = np.ones((2,2,2))\nnorm = np.linalg.norm(T)\nprint('Frobenius norm:', norm)"
  },
  {
    "input": "Perform a mode-1 unfolding of a tensor T of shape (2,3,4).",
    "output": "import numpy as np\nT = np.random.rand(2,3,4)\nunfolded = np.reshape(np.moveaxis(T, 1, 0), (3, -1))\nprint('Mode-1 unfolded shape:', unfolded.shape)"
  },
  {
    "input": "Construct a symmetric matrix from a tensor slice and check positive semi-definiteness.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nA = (T[:,:,0] + T[:,:,0].T) / 2\neigvals = np.linalg.eigvalsh(A)\nprint('Positive semi-definite:', np.all(eigvals >= -1e-10))"
  },
  {
    "input": "Generate two 3D tensors A and B of shape (2,2,2) and compute their Hadamard product.",
    "output": "import numpy as np\nA = np.random.rand(2,2,2)\nB = np.random.rand(2,2,2)\nC = A * B\nprint('Hadamard product:\\n', C)"
  },
  {
    "input": "Check if a given matrix is a projection matrix: A = np.array([[1, 0], [0, 0]]).",
    "output": "import numpy as np\nA = np.array([[1, 0], [0, 0]])\nprint('Projection matrix:', np.allclose(A @ A, A))"
  },
  {
    "input": "Construct a Kronecker product of two matrices A = [[1, 2], [3, 4]] and B = [[0, 5], [6, 7]].",
    "output": "import numpy as np\nA = np.array([[1,2], [3,4]])\nB = np.array([[0,5], [6,7]])\nK = np.kron(A, B)\nprint('Kronecker product:\\n', K)"
  },
  {
    "input": "Generate a random tensor T of shape (3,3,3) and normalize it to unit Frobenius norm.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nT_normalized = T / np.linalg.norm(T)\nprint('Frobenius norm of normalized tensor:', np.linalg.norm(T_normalized))"
  },
  {
    "input": "Construct a 3D tensor T (shape 3x3x3) where each slice along axis 2 is a skew-symmetric matrix.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    T[:,:,i] = A - A.T\nprint('Skew-symmetric tensor:\\n', T)"
  },
  {
    "input": "Compute the spectral norm (largest singular value) of a matrix extracted from a tensor slice.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nM = T[:,:,0]\nspectral_norm = np.linalg.norm(M, ord=2)\nprint('Spectral norm:', spectral_norm)"
  },
  {
    "input": "Find the multilinear rank of a random tensor of shape (3,4,5).",
    "output": "import numpy as np\nfrom numpy.linalg import matrix_rank\nT = np.random.rand(3,4,5)\nmode0 = matrix_rank(T.reshape(3, -1))\nmode1 = matrix_rank(np.moveaxis(T, 1, 0).reshape(4, -1))\nmode2 = matrix_rank(T.reshape(-1, 5))\nprint('Multilinear rank:', (mode0, mode1, mode2))"
  },
  {
    "input": "Verify whether a 3x3 orthogonal matrix A preserves the Frobenius norm of a tensor under mode multiplication.",
    "output": "import numpy as np\nfrom numpy.linalg import norm\nA = np.linalg.qr(np.random.rand(3,3))[0]\nT = np.random.rand(3,3,3)\nT_trans = np.tensordot(A, T, axes=(1,0))\nprint('Norm preserved:', np.allclose(norm(T), norm(T_trans)))"
  },
  {
    "input": "Simulate outer product of three vectors of length 2 to construct a rank-1 tensor of shape (2,2,2).",
    "output": "import numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nc = np.array([5, 6])\nT = np.einsum('i,j,k->ijk', a, b, c)\nprint('Rank-1 tensor:\\n', T)"
  },
  {
    "input": "Apply higher-order SVD (HOSVD) on a tensor of shape (4,4,4) and reconstruct it.",
    "output": "import numpy as np\n\n# Create a random tensor of shape (4,4,4)\ntensor = np.random.rand(4, 4, 4)\n\n# Unfold the tensor along each mode and perform SVD\nU1, _, _ = np.linalg.svd(tensor.reshape(4, -1), full_matrices=False)\nU2, _, _ = np.linalg.svd(np.reshape(np.moveaxis(tensor, 1, 0), (4, -1)), full_matrices=False)\nU3, _, _ = np.linalg.svd(np.reshape(np.moveaxis(tensor, 2, 0), (4, -1)), full_matrices=False)\n\n# Truncate to full rank (can also choose lower rank for approximation)\nU1 = U1[:, :4]\nU2 = U2[:, :4]\nU3 = U3[:, :4]\n\n# Compute core tensor\ncore = np.einsum('ijk,ia->ajk', tensor, U1.T)\ncore = np.einsum('ajk,jb->abk', core, U2.T)\ncore = np.einsum('abk,kc->abc', core, U3.T)\n\n# Reconstruct the tensor\ntemp = np.einsum('abc,ia->ibc', core, U1)\ntemp = np.einsum('ibc,jb->ijc', temp, U2)\nreconstructed = np.einsum('ijc,kc->ijk', temp, U3)\n\nprint('HOSVD reconstruction accurate:', np.allclose(tensor, reconstructed, atol=1e-6))"
  },
  {
    "input": "Compute the trace of each 2D slice of a 3x3x3 tensor.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\ntraces = [np.trace(T[:,:,i]) for i in range(3)]\nprint('Traces of slices:', traces)"
  },
  {
    "input": "Test if a 3D tensor remains unchanged under double transposition across two axes.",
    "output": "import numpy as np\nT = np.random.rand(3,4,5)\nT_trans = np.transpose(np.transpose(T, (1,0,2)), (1,0,2))\nprint('Tensor unchanged after double transpose:', np.allclose(T, T_trans))"
  },
  {
    "input": "Given a 4x4 matrix A, find its null space numerically.",
    "output": "import numpy as np\nfrom scipy.linalg import null_space\nA = np.random.rand(4,4)\nns = null_space(A)\nprint('Null space shape:', ns.shape)"
  },
  {
    "input": "Construct a block-diagonal matrix from two 2x2 matrices A and B.",
    "output": "import numpy as np\nfrom scipy.linalg import block_diag\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nC = block_diag(A, B)\nprint('Block-diagonal matrix:\\n', C)"
  },
  {
    "input": "Perform contraction of a rank-4 tensor over axes (0,2) with itself.",
    "output": "import numpy as np\nT = np.random.rand(3,4,3,4)\nC = np.tensordot(T, T, axes=([0,2],[0,2]))\nprint('Contracted tensor shape:', C.shape)"
  },
  {
    "input": "Reshape a tensor from shape (2,3,4) into a matrix of shape (6,4) and back.",
    "output": "import numpy as np\nT = np.random.rand(2,3,4)\nM = T.reshape(6,4)\nT_back = M.reshape(2,3,4)\nprint('Reshape reversible:', np.allclose(T, T_back))"
  },
  {
    "input": "Check commutativity of matrix multiplication between two 2x2 matrices.",
    "output": "import numpy as np\nA = np.random.rand(2,2)\nB = np.random.rand(2,2)\nprint('AB == BA:', np.allclose(A @ B, B @ A))"
  },
  {
    "input": "Compute the inner product of two random tensors A and B of shape (3,3,3).",
    "output": "import numpy as np\nA = np.random.rand(3,3,3)\nB = np.random.rand(3,3,3)\ninner_product = np.tensordot(A, B)\nprint('Inner product:', inner_product)"
  },
  {
    "input": "Given a matrix A, verify if A is idempotent (i.e., A^2 = A).",
    "output": "import numpy as np\nA = np.array([[1, 0], [0, 0]])\nprint('Is idempotent:', np.allclose(A @ A, A))"
  },
  {
    "input": "Apply mode-2 multiplication of a tensor T (3x3x3) with a matrix A (3x3).",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nA = np.random.rand(3,3)\nresult = np.tensordot(T, A, axes=([1], [0]))\nresult = np.moveaxis(result, -1, 1)\nprint('Result shape:', result.shape)"
  },
  {
    "input": "Generate a rank-2 tensor (matrix) with a given singular value spectrum [3, 1].",
    "output": "import numpy as np\nU, _ = np.linalg.qr(np.random.rand(3, 2))\nVt, _ = np.linalg.qr(np.random.rand(2, 2))\nS = np.diag([3, 1])\nA = U @ S @ Vt\nprint('Matrix with spectrum [3,1]:\\n', A)"
  },
  {
    "input": "Create a tensor of shape (3,3,3) with each frontal slice being a diagonal matrix.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    T[:,:,i] = np.diag(np.random.rand(3))\nprint('Tensor with diagonal slices:\\n', T)"
  },
  {
    "input": "Construct a 3D tensor of shape (2,2,2) such that all elements are unique integers from 1 to 8.",
    "output": "import numpy as np\nT = np.arange(1,9).reshape(2,2,2)\nprint('Unique integer tensor:\\n', T)"
  },
  {
    "input": "Perform a Tucker decomposition on a (3,3,3) tensor and reconstruct it.",
    "output": "import numpy as np\n\n# Create a random tensor of shape (3,3,3)\ntensor = np.random.rand(3, 3, 3)\n\n# Simulate Tucker decomposition manually with low-rank approximation\n# Create factor matrices for each mode\nU1 = np.random.rand(3, 2)\nU2 = np.random.rand(3, 2)\nU3 = np.random.rand(3, 2)\n\n# Create a core tensor of shape (2,2,2)\ncore = np.random.rand(2, 2, 2)\n\n# Reconstruct the tensor using mode-n products\n# Using einsum for tensor contractions\ntemp = np.einsum('abc,ia->ibc', core, U1)\ntemp = np.einsum('ibc,jb->ijc', temp, U2)\nreconstructed = np.einsum('ijc,kc->ijk', temp, U3)\n\nprint('Reconstructed tensor shape:', reconstructed.shape)\nprint('Reconstructed tensor:\\n', reconstructed)"
  },
  {
    "input": "Check the orthogonality of singular vectors from SVD of a random 3x3 matrix.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nU, S, Vt = np.linalg.svd(A)\nprint('U orthogonal:', np.allclose(U.T @ U, np.eye(3)))\nprint('V orthogonal:', np.allclose(Vt @ Vt.T, np.eye(3)))"
  },
  {
    "input": "Generate a tensor and compute its element-wise cube root.",
    "output": "import numpy as np\nT = np.random.rand(2,2,2)\ncube_root = T ** (1/3)\nprint('Cube root tensor:\\n', cube_root)"
  },
  {
    "input": "Find the determinant of each frontal slice of a 3x3x3 tensor.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\ndets = [np.linalg.det(T[:,:,i]) for i in range(3)]\nprint('Determinants of slices:', dets)"
  },
  {
    "input": "Apply batch matrix multiplication to slices of two tensors A and B of shape (3,3,3).",
    "output": "import numpy as np\nA = np.random.rand(3,3,3)\nB = np.random.rand(3,3,3)\nC = np.einsum('ijk,ikl->ijl', A, B)\nprint('Result tensor shape:', C.shape)"
  },
  {
    "input": "Given a matrix A, perform polar decomposition into unitary and positive-semidefinite components.",
    "output": "import numpy as np\nfrom scipy.linalg import polar\nA = np.random.rand(3,3)\nU, P = polar(A)\nprint('Polar decomposition valid:', np.allclose(A, U @ P))"
  },
  {
    "input": "Construct a tensor T of shape (3,3,3) where each slice along the third axis is symmetric positive definite.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    T[:,:,i] = A @ A.T + np.eye(3)\nprint('Symmetric positive definite tensor:\\n', T)"
  },
  {
    "input": "Perform eigen-decomposition on each 2D slice of a tensor of shape (3,3,3).",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\neigenvalues = [np.linalg.eig(T[:,:,i])[0] for i in range(3)]\nprint('Eigenvalues per slice:', eigenvalues)"
  },
  {
    "input": "Create a tensor of shape (3,3,3) with all slices along axis 0 as orthonormal matrices.",
    "output": "import numpy as np\nT = np.stack([np.linalg.qr(np.random.rand(3,3))[0] for _ in range(3)], axis=0)\nprint('Tensor with orthonormal slices along axis 0:\\n', T)"
  },
  {
    "input": "Compute the rank of each slice of a tensor T of shape (3,3,3) along axis 2.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nranks = [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)]\nprint('Ranks per slice:', ranks)"
  },
  {
    "input": "Verify if a tensor of shape (3,3,3) is symmetric along all axes.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nprint('Is symmetric:', np.allclose(T, T.transpose(1,0,2)) and np.allclose(T, T.transpose(2,1,0)))"
  },
  {
    "input": "Generate a tensor of shape (4,4,4) and compute its max-norm (maximum absolute element).",
    "output": "import numpy as np\nT = np.random.rand(4,4,4)\nmax_norm = np.max(np.abs(T))\nprint('Max-norm:', max_norm)"
  },
  {
    "input": "Perform element-wise multiplication of two 4D tensors A and B of shape (2,2,2,2).",
    "output": "import numpy as np\nA = np.random.rand(2,2,2,2)\nB = np.random.rand(2,2,2,2)\nC = A * B\nprint('Element-wise product:\\n', C)"
  },
  {
    "input": "Simulate a rank-1 approximation of a tensor of shape (2,2,2) using CP decomposition.",
    "output": "import numpy as np\n\n# Manually simulate a rank-1 tensor using outer product\n# Create three vectors (one for each mode)\na = np.random.rand(2)\nb = np.random.rand(2)\nc = np.random.rand(2)\n\n# Compute the outer product to form a rank-1 tensor\nrank1_tensor = np.einsum('i,j,k->ijk', a, b, c)\n\nprint('Rank-1 approximation:\\n', rank1_tensor)"
  },
  {
    "input": "Apply mode-3 product of a tensor T (3x3x3) with a matrix A (3x3).",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nA = np.random.rand(3,3)\nT_perm = np.transpose(T, (2, 0, 1))\nresult = np.tensordot(A, T_perm, axes=(1,0))\nfinal = np.transpose(result, (1,2,0))\nprint('Mode-3 product result shape:', final.shape)"
  },
  {
    "input": "Verify trace(A @ B) = trace(B @ A) for two square matrices A and B.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nB = np.random.rand(3,3)\nprint('Trace equality:', np.allclose(np.trace(A @ B), np.trace(B @ A)))"
  },
  {
    "input": "Create a tensor of shape (3,3,3) where each mode-1 unfolding is full-rank.",
    "output": "import numpy as np\nwhile True:\n    T = np.random.rand(3,3,3)\n    unfolding = T.transpose(1,0,2).reshape(3, -1)\n    if np.linalg.matrix_rank(unfolding) == 3:\n        break\nprint('Full-rank mode-1 unfolding tensor:\\n', T)"
  },
  {
    "input": "Construct a tensor T such that each slice T[:,:,i] is singular with rank 2.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,2)\n    T[:,:,i] = A @ A.T\nprint('Tensor with singular slices of rank 2:\\n', T)"
  },
  {
    "input": "Compute the mean tensor from a batch of 5 random tensors of shape (3,3,3).",
    "output": "import numpy as np\nbatch = np.random.rand(5,3,3,3)\nmean_tensor = np.mean(batch, axis=0)\nprint('Mean tensor:\\n', mean_tensor)"
  },
  {
    "input": "Check if all singular values of a 3x3 slice from a tensor are real and positive.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\ns = np.linalg.svd(T[:,:,0], compute_uv=False)\nprint('Singular values real and positive:', np.all(s > 0))"
  },
  {
    "input": "Construct a 3D tensor of shape (3,3,3) such that its Frobenius norm is exactly 10.",
    "output": "import numpy as np\nT = np.random.randn(3,3,3)\nT = T / np.linalg.norm(T) * 10\nfro_norm = np.linalg.norm(T)\nprint('Tensor with Frobenius norm 10:', fro_norm)"
  },
  {
    "input": "Given a tensor T of shape (3,3,3), compute the cosine similarity between the first and second frontal slices.",
    "output": "import numpy as np\nfrom numpy.linalg import norm\nT = np.random.rand(3,3,3)\nA = T[:,:,0].flatten()\nB = T[:,:,1].flatten()\ncos_sim = np.dot(A, B) / (norm(A) * norm(B))\nprint('Cosine similarity:', cos_sim)"
  },
  {
    "input": "Generate a tensor of shape (3,3,3) such that the sum of its three mode-n unfoldings is a symmetric matrix.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nmode_1 = T.reshape(3, -1)\nmode_2 = np.transpose(T, (1,0,2)).reshape(3, -1)\nmode_3 = np.transpose(T, (2,0,1)).reshape(3, -1)\nS = np.dot(mode_1, mode_1.T) + np.dot(mode_2, mode_2.T) + np.dot(mode_3, mode_3.T)\nis_symmetric = np.allclose(S, S.T)\nprint('Sum of unfoldings symmetric:', is_symmetric)"
  },
  {
    "input": "Create a 3x3x3 tensor such that its diagonal slices are linearly dependent.",
    "output": "import numpy as np\nbase = np.random.rand(3,3)\nT = np.stack([base, 2*base, -1*base], axis=2)\nprint('Linearly dependent slices tensor:\\n', T)"
  },
  {
    "input": "Construct a tensor T of shape (3,3,3) where the trace of each frontal slice increases by 1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    A[np.diag_indices(3)] += i\n    T[:,:,i] = A\nprint('Trace of slices:', [np.trace(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Given a tensor of shape (3,3,3), find a scalar 'a' such that scaling the tensor by 'a' results in Frobenius norm = 1.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\na = 1 / np.linalg.norm(T)\nT_scaled = a * T\nprint('Frobenius norm:', np.linalg.norm(T_scaled))"
  },
  {
    "input": "Construct a tensor of shape (3,3,3) where each 2D slice is a rotation matrix.",
    "output": "import numpy as np\nfrom scipy.linalg import orth\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    if np.linalg.det(Q) < 0:\n        Q[:,0] = -Q[:,0]\n    T[:,:,i] = Q\nprint('All slices are rotation matrices:', all(np.allclose(T[:,:,i] @ T[:,:,i].T, np.eye(3)) for i in range(3)))"
  },
  {
    "input": "Generate a 3x3x3 tensor T such that its inverse exists when flattened into a 9x3 matrix and multiplied by its transpose.",
    "output": "import numpy as np\nwhile True:\n    T = np.random.rand(3,3,3)\n    T_flat = T.reshape(9,3)\n    M = T_flat.T @ T_flat\n    if np.linalg.matrix_rank(M) == 3:\n        break\ninv = np.linalg.inv(M)\nprint('Inverse exists:', np.allclose(M @ inv, np.eye(3)))"
  },
  {
    "input": "Create a tensor T such that T + T^T (over axes 0 and 1) results in a symmetric tensor.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nTsym = T + T.transpose(1,0,2)\nis_symmetric = np.allclose(Tsym, Tsym.transpose(1,0,2))\nprint('Symmetric tensor result:', is_symmetric)"
  },
  {
    "input": "Construct a 3D tensor where the determinant of each slice is a prime number.",
    "output": "import numpy as np\nfrom sympy import isprime\nT = np.zeros((3,3,3))\ncount = 0\nwhile count < 3:\n    A = np.random.randint(1, 10, (3,3))\n    d = round(np.linalg.det(A))\n    if isprime(abs(d)):\n        T[:,:,count] = A\n        count += 1\nprint('Determinants:', [round(np.linalg.det(T[:,:,i])) for i in range(3)])"
  },
  {
    "input": "Given a tensor T of shape (3,3,3), determine if there exists a permutation of axes that results in a tensor with identical frontal slices.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nT_perm = np.transpose(T, (2,1,0))\nidentical = np.all([np.allclose(T_perm[0], T_perm[i]) for i in range(1,3)])\nprint('Has identical frontal slices after permutation:', identical)"
  },
  {
    "input": "Create a tensor T of shape (3,3,3) such that the sum across axis=0 equals the identity matrix.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nI = np.eye(3)\nfor i in range(3):\n    T[i,:,:] = I / 3\nsum_result = T.sum(axis=0)\nprint('Sum across axis=0 equals identity:', np.allclose(sum_result, I))"
  },
  {
    "input": "Generate a 3x3x3 tensor where the sum of all anti-diagonals across each 2D slice is equal.",
    "output": "import numpy as np\nT = np.random.randint(1, 5, (3,3,3))\nantidiag_sums = [np.sum(np.fliplr(T[:,:,i]).diagonal()) for i in range(3)]\nequal = all(s == antidiag_sums[0] for s in antidiag_sums)\nprint('Anti-diagonal sums:', antidiag_sums, '| Equal:', equal)"
  },
  {
    "input": "Construct a tensor such that the Hadamard product of its slices equals the identity matrix.",
    "output": "import numpy as np\nI = np.eye(3)\nA = np.sqrt(I)\nT = np.stack([A, A, A], axis=2)\nH = T[:,:,0] * T[:,:,1] * T[:,:,2]\nprint('Hadamard product equals identity:', np.allclose(H, I))"
  },
  {
    "input": "Create a tensor of shape (3,3,3) where each 2D slice is orthogonal and has a determinant of -1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    if np.linalg.det(Q) > 0:\n        Q[:,0] *= -1  # Flip sign to make determinant -1\n    T[:,:,i] = Q\nprint('Determinants:', [round(np.linalg.det(T[:,:,i])) for i in range(3)])"
  },
  {
    "input": "Construct a tensor of shape (3,3,3) where the L2 norm of each row across all slices is 1.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nfor i in range(3):\n    for j in range(3):\n        norm = np.linalg.norm(T[i,j,:])\n        T[i,j,:] /= norm\nprint('L2 norms per row across slices:', [[round(np.linalg.norm(T[i,j,:]), 4) for j in range(3)] for i in range(3)])"
  },
  {
    "input": "Build a tensor of shape (3,3,3) such that summing across any axis gives the same matrix.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nT = np.stack([A/3, A/3, A/3], axis=0)\nprint('Sum across axis=0:', np.allclose(np.sum(T, axis=0), A))\nprint('Sum across axis=1:', np.allclose(np.sum(T, axis=1), A))\nprint('Sum across axis=2:', np.allclose(np.sum(T, axis=2), A))"
  },
  {
    "input": "Generate a tensor T (3x3x3) such that the norm of its mode-1 unfolding equals the norm of its mode-2 unfolding.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nU1 = T.reshape(3, -1)\nU2 = T.transpose(1,0,2).reshape(3, -1)\nequal = np.isclose(np.linalg.norm(U1), np.linalg.norm(U2))\nprint('Equal unfold norms:', equal)"
  },
  {
    "input": "Create a tensor where the outer product of a vector with itself fills all slices.",
    "output": "import numpy as np\nv = np.array([1, 2, 3])\nouter = np.outer(v, v)\nT = np.stack([outer]*3, axis=2)\nprint('Outer product slices identical:', np.allclose(T[:,:,0], T[:,:,1]) and np.allclose(T[:,:,1], T[:,:,2]))"
  },
  {
    "input": "Construct a 3D tensor where one slice is the transpose of another and the third is their average.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nB = A.T\nC = (A + B) / 2\nT = np.stack([A, B, C], axis=2)\nprint('Third slice is average of first two:', np.allclose(T[:,:,2], (T[:,:,0] + T[:,:,1])/2))"
  },
  {
    "input": "Create a tensor where the determinant of each slice forms an arithmetic progression.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nd1 = 1\nfor i in range(3):\n    A = np.random.randint(1, 5, (3,3))\n    while round(np.linalg.det(A)) != d1 + i:\n        A = np.random.randint(1, 5, (3,3))\n    T[:,:,i] = A\nprint('Determinants:', [round(np.linalg.det(T[:,:,i])) for i in range(3)])"
  },
  {
    "input": "Construct a tensor such that dot product of all columns across slices equals a fixed vector.",
    "output": "import numpy as np\nv = np.array([1,2,3])\nT = np.zeros((3,3,3))\nfor i in range(3):\n    T[:,i,:] = np.outer(v, [1,1,1])\ndots = [np.dot(T[:,i,0], T[:,i,1]) for i in range(3)]\nprint('Column dot products fixed:', dots)"
  },
  {
    "input": "Build a tensor where the first slice is the inverse of the second slice (if invertible), and the third is their product.",
    "output": "import numpy as np\nwhile True:\n    B = np.random.rand(3,3)\n    if np.linalg.matrix_rank(B) == 3:\n        break\nA = np.linalg.inv(B)\nC = A @ B\nT = np.stack([A, B, C], axis=2)\nprint('Third slice is product of first two:', np.allclose(T[:,:,2], np.dot(T[:,:,0], T[:,:,1])))"
  },
  {
    "input": "Create a tensor where summing all rows of all slices equals a vector of ones.",
    "output": "import numpy as np\nT = np.ones((3,3,3)) / 9\ns = np.sum(T, axis=(0,1))\nprint('Sum equals ones:', np.allclose(s, np.ones(3)))"
  },
  {
    "input": "Create a 3x3x3 tensor T such that the mean of each mode-3 fiber is the same.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nfiber_means = [np.mean(T[i,j,:]) for i in range(3) for j in range(3)]\nconsistent = all(np.isclose(m, fiber_means[0]) for m in fiber_means)\nprint('Fiber means:', fiber_means, '| All equal:', consistent)"
  },
  {
    "input": "Construct a tensor of shape (3,3,3) where summing along axis 2 gives a skew-symmetric matrix.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nskew = A - A.T\nT = np.zeros((3,3,3))\nT[:,:,0] = skew / 3\nT[:,:,1] = skew / 3\nT[:,:,2] = skew / 3\nsum_T = np.sum(T, axis=2)\nprint('Skew-symmetric:', np.allclose(sum_T, -sum_T.T))"
  },
  {
    "input": "Generate a 3D tensor of shape (3,3,3) such that the sum of eigenvalues of all slices is constant.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nconstant = 5\nfor i in range(3):\n    A = np.random.rand(3,3)\n    trace = np.trace(A)\n    T[:,:,i] = A + np.eye(3)*(constant - trace)\nprint('Eigenvalue sums:', [np.sum(np.linalg.eigvals(T[:,:,i])) for i in range(3)])"
  },
  {
    "input": "Create a tensor such that the eigenvectors of all 3 slices are orthogonal to each other.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.rand(3,3))\n    D = np.diag(np.random.rand(3))\n    T[:,:,i] = Q @ D @ Q.T\nprint('Slices constructed with orthogonal eigenvectors.')"
  },
  {
    "input": "Build a 3x3x3 tensor such that all slices are stochastic matrices (rows sum to 1).",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nfor i in range(3):\n    row_sums = T[:,:,i].sum(axis=1)\n    T[:,:,i] = T[:,:,i] / row_sums[:, np.newaxis]\nprint('Row sums:', [T[:,:,i].sum(axis=1) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where the cross product of the first two rows of each slice equals the third row.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    a = np.random.rand(3)\n    b = np.random.rand(3)\n    c = np.cross(a, b)\n    T[0,:,i] = a\n    T[1,:,i] = b\n    T[2,:,i] = c\nprint('Cross product row test:', np.allclose(np.cross(T[0,:,0], T[1,:,0]), T[2,:,0]))"
  },
  {
    "input": "Generate a tensor T of shape (3,3,3) where dot product between diagonals of adjacent slices is zero.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\northogonal = True\nfor i in range(2):\n    d1 = np.diag(T[:,:,i])\n    d2 = np.diag(T[:,:,i+1])\n    if not np.isclose(np.dot(d1, d2), 0):\n        orthogonal = False\n        break\nprint('Diagonal dot products orthogonal:', orthogonal)"
  },
  {
    "input": "Construct a tensor such that all 2D slices are idempotent matrices (A^2 = A).",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    A = A @ A\n    T[:,:,i] = A @ np.linalg.pinv(A)\nprint('All slices are idempotent:', all(np.allclose(T[:,:,i] @ T[:,:,i], T[:,:,i]) for i in range(3)))"
  },
  {
    "input": "Build a tensor T where summing diagonals of all slices gives a geometric sequence.",
    "output": "import numpy as np\nr = 2\na = 1\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.eye(3) * (a * (r ** i))\n    T[:,:,i] = A\nsums = [np.trace(T[:,:,i]) for i in range(3)]\nprint('Diagonal sums:', sums)"
  },
  {
    "input": "Construct a tensor where every slice has rank exactly 1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    u = np.random.rand(3,1)\n    v = np.random.rand(1,3)\n    T[:,:,i] = u @ v\nprint('Ranks:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a tensor where flipping along the first axis results in a tensor with reversed diagonal sums.",
    "output": "import numpy as np\nT = np.random.randint(1,5,(3,3,3))\norig_diags = [np.trace(T[:,:,i]) for i in range(3)]\nT_flipped = np.flip(T, axis=0)\nflip_diags = [np.trace(T_flipped[:,:,i]) for i in range(3)]\nprint('Original vs flipped diagonal sums:', orig_diags, flip_diags[::-1])"
  },
  {
    "input": "Generate a tensor such that all frontal slices are symmetric and the third is a linear combination of the first two.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nA = (A + A.T)/2\nB = np.random.rand(3,3)\nB = (B + B.T)/2\nalpha, beta = 2, -0.5\nC = alpha * A + beta * B\nT = np.stack([A, B, C], axis=2)\nprint('Third slice is combination of first two:', np.allclose(T[:,:,2], alpha*T[:,:,0] + beta*T[:,:,1]))"
  },
  {
    "input": "Create a tensor of shape (3,3,3) where the sum of each mode-1 fiber is the same constant.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nfiber_sums = [np.sum(T[:,i,j]) for i in range(3) for j in range(3)]\nconstant_sum = fiber_sums[0]\nall_equal = all(np.isclose(s, constant_sum) for s in fiber_sums)\nprint('All mode-1 fiber sums equal:', all_equal)"
  },
  {
    "input": "Generate a tensor where each slice has Frobenius norm equal to the slice index + 1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randn(3,3)\n    A = A / np.linalg.norm(A, 'fro') * (i + 1)\n    T[:,:,i] = A\nprint('Frobenius norms:', [np.linalg.norm(T[:,:,i], 'fro') for i in range(3)])"
  },
  {
    "input": "Create a 3x3x3 tensor where for each slice, the sum of the eigenvalues equals the trace and it's constant.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nconstant_trace = 6\nfor i in range(3):\n    A = np.random.rand(3,3)\n    trace = np.trace(A)\n    A += np.eye(3) * (constant_trace - trace)\n    T[:,:,i] = A\nprint('Trace and eigenvalue sums:', [(np.trace(T[:,:,i]), np.sum(np.linalg.eigvals(T[:,:,i]))) for i in range(3)])"
  },
  {
    "input": "Build a tensor where the rank of each frontal slice increases strictly from 1 to 3.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nT[:,:,0] = np.outer(np.ones(3), [1,0,0])\nT[:,:,1] = np.vstack([np.ones(3), np.eye(3)[1], np.eye(3)[2]])\nT[:,:,2] = np.random.rand(3,3)\nprint('Ranks of slices:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where each mode-2 slice (T[:, :, i]) is an orthogonal matrix.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    T[:,:,i] = Q\nprint('Orthogonality check:', [np.allclose(T[:,:,i].T @ T[:,:,i], np.eye(3)) for i in range(3)])"
  },
  {
    "input": "Create a tensor where the element-wise cube of slice 0 equals slice 1 and slice 2 equals their difference.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nB = A**3\nC = B - A\nT = np.stack([A, B, C], axis=2)\nprint('Conditions hold:', np.allclose(T[:,:,1], T[:,:,0]**3) and np.allclose(T[:,:,2], T[:,:,1] - T[:,:,0]))"
  },
  {
    "input": "Generate a tensor such that the average of every row (across all slices) is equal for all rows.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nrow_averages = [np.mean(T[i,:,:]) for i in range(3)]\nprint('Equal row averages:', all(np.isclose(row_averages[i], row_averages[0]) for i in range(1,3)))"
  },
  {
    "input": "Build a tensor where all elements are integers and each slice has a unique trace from 1 to 3.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randint(1, 5, (3,3))\n    np.fill_diagonal(A, [i+1 if j==i else 0 for j in range(3)])\n    T[:,:,i] = A\nprint('Traces:', [np.trace(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a tensor where all slices are nilpotent matrices of index 2 (A^2 = 0).",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    A = A - A @ A\n    T[:,:,i] = A\nprint('Nilpotency check:', [np.allclose(T[:,:,i] @ T[:,:,i], np.zeros((3,3))) for i in range(3)])"
  },
  {
    "input": "Construct a tensor T such that T[:, :, i] = A + iB, for fixed matrices A and B.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nB = np.random.rand(3,3)\nT = np.stack([A + i*B for i in range(3)], axis=2)\nprint('Slices constructed using A + iB relation.')"
  },
  {
    "input": "Generate a tensor where every frontal slice is a rotation matrix in 2D embedded in 3x3.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nangles = [np.pi/6, np.pi/4, np.pi/3]\nfor i, theta in enumerate(angles):\n    R = np.array([[np.cos(theta), -np.sin(theta), 0],\n                  [np.sin(theta), np.cos(theta), 0],\n                  [0, 0, 1]])\n    T[:,:,i] = R\nprint('Rotation matrices:\\n', T[:,:,0], '\\n', T[:,:,1], '\\n', T[:,:,2])"
  },
  {
    "input": "Create a tensor such that each slice is symmetric and has the same eigenvectors but different eigenvalues.",
    "output": "import numpy as np\nQ, _ = np.linalg.qr(np.random.rand(3,3))\nD1 = np.diag([1,2,3])\nD2 = np.diag([4,5,6])\nD3 = np.diag([7,8,9])\nT = np.stack([Q @ D @ Q.T for D in [D1, D2, D3]], axis=2)\nprint('Slices share eigenvectors:', all(np.allclose(T[:,:,i], T[:,:,i].T) for i in range(3)))"
  },
  {
    "input": "Create a 3x3x3 tensor where the Hadamard product of the first two slices equals the third slice.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nB = np.random.rand(3,3)\nC = A * B\nT = np.stack([A, B, C], axis=2)\nprint('Hadamard product holds:', np.allclose(T[:,:,0] * T[:,:,1], T[:,:,2]))"
  },
  {
    "input": "Construct a tensor where the determinant of each frontal slice is the factorial of its index (starting from 1).",
    "output": "import numpy as np\nimport math\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.eye(3) * math.factorial(i+1)**(1/3)\n    T[:,:,i] = A\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor T such that T[:,:,0] = A, T[:,:,1] = A^2, T[:,:,2] = A^3 for some random matrix A.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nT = np.stack([np.linalg.matrix_power(A, i+1) for i in range(3)], axis=2)\nprint('Powers of A:', [T[:,:,i] for i in range(3)])"
  },
  {
    "input": "Create a tensor where summing over any axis results in a matrix with constant row and column sums.",
    "output": "import numpy as np\nbase = np.ones((3,3))\nT = np.stack([base for _ in range(3)], axis=2)\nsum0 = np.sum(T, axis=0)\nsum1 = np.sum(T, axis=1)\nsum2 = np.sum(T, axis=2)\nprint('Row/Col sums consistent:', np.allclose(sum0.sum(axis=0), sum0[0,:].sum()) and np.allclose(sum1.sum(axis=1), sum1[:,0].sum()) and np.allclose(sum2.sum(axis=1), sum2[:,0].sum()))"
  },
  {
    "input": "Construct a 3D tensor whose slices are all rank-1 matrices but orthogonal to each other.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nvecs = [np.random.rand(3) for _ in range(3)]\nvecs = np.linalg.qr(np.column_stack(vecs))[0].T\nfor i in range(3):\n    T[:,:,i] = np.outer(vecs[i], vecs[i])\nprint('Orthogonal slices and rank-1 check:', all(np.linalg.matrix_rank(T[:,:,i])==1 for i in range(3)))"
  },
  {
    "input": "Build a tensor where flipping any two axes gives the same tensor.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nT_sym = (T + T.transpose(1,0,2) + T.transpose(2,1,0)) / 3\nsame = (np.allclose(T_sym, T_sym.transpose(1,0,2)) and np.allclose(T_sym, T_sym.transpose(2,1,0)))\nprint('Symmetry across axes:', same)"
  },
  {
    "input": "Create a tensor such that all 2D slices are projection matrices (P^2 = P and symmetric).",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    v = np.random.rand(3,1)\n    P = v @ v.T / (v.T @ v)\n    T[:,:,i] = P\nprint('All slices are projection matrices:', all(np.allclose(T[:,:,i] @ T[:,:,i], T[:,:,i]) and np.allclose(T[:,:,i], T[:,:,i].T) for i in range(3)))"
  },
  {
    "input": "Construct a tensor where the sum of elements along diagonals of all slices forms an arithmetic sequence.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\na, d = 2, 3\nfor i in range(3):\n    diag_val = a + i*d\n    T[:,:,i] = np.eye(3) * diag_val\nsums = [np.trace(T[:,:,i]) for i in range(3)]\nprint('Diagonal trace sums (arithmetic):', sums)"
  },
  {
    "input": "Generate a tensor such that T[:,:,0] is lower triangular, T[:,:,1] upper triangular, T[:,:,2] diagonal.",
    "output": "import numpy as np\nA = np.tril(np.random.rand(3,3))\nB = np.triu(np.random.rand(3,3))\nC = np.diag(np.random.rand(3))\nT = np.stack([A, B, C], axis=2)\nprint('Forms: lower, upper, diagonal')"
  },
  {
    "input": "Build a tensor such that the angle (cosine similarity) between columns of each slice is constant.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    base = np.random.rand(3)\n    A = np.column_stack([base, base*2, base*3])\n    T[:,:,i] = A\ncosines = [np.dot(T[:,0,i], T[:,1,i]) / (np.linalg.norm(T[:,0,i]) * np.linalg.norm(T[:,1,i])) for i in range(3)]\nprint('Cosine similarities:', cosines)"
  },
  {
    "input": "Construct a tensor where eigenvalues of each slice are all real and negative.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    D = np.diag(-np.random.rand(3))\n    Q, _ = np.linalg.qr(np.random.rand(3,3))\n    T[:,:,i] = Q @ D @ Q.T\nprint('Eigenvalues negative:', [np.all(np.linalg.eigvals(T[:,:,i]) < 0) for i in range(3)])"
  },
  {
    "input": "Create a tensor where all elements are non-zero and the inverse of each slice exists.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3) + np.eye(3)\n    T[:,:,i] = A\ninverses_exist = all(np.linalg.cond(T[:,:,i]) < 1/np.finfo(T.dtype).eps for i in range(3))\nprint('Invertible slices:', inverses_exist)"
  },
  {
    "input": "Create a 3x3x3 tensor where each slice is both symmetric and has a fixed determinant of 2.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    A_sym = (A + A.T) / 2\n    eigvals, eigvecs = np.linalg.eigh(A_sym)\n    eigvals = eigvals / np.prod(eigvals) * 2\n    A_fixed = eigvecs @ np.diag(eigvals) @ eigvecs.T\n    T[:,:,i] = A_fixed\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where every slice has rank 2 and shares a null space with the others.",
    "output": "import numpy as np\nnull_vec = np.random.rand(3,1)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    A = A - np.outer(null_vec, np.dot(null_vec.T, A))\n    T[:,:,i] = A\nprint('Shared null vector test:', [np.allclose(T[:,:,i] @ null_vec, 0) for i in range(3)])"
  },
  {
    "input": "Create a tensor where the cross product of corresponding columns in the first two slices equals the third slice.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nB = np.random.rand(3,3)\nC = np.cross(A.T, B.T).T\nT = np.stack([A, B, C], axis=2)\nprint('Cross product valid:', np.allclose(np.cross(T[:,0,0], T[:,0,1]), T[:,0,2]))"
  },
  {
    "input": "Construct a tensor such that each slice is orthogonal to the next under Frobenius inner product.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nB = np.random.rand(3,3)\nB -= np.trace(A.T @ B) / np.trace(A.T @ A) * A\nC = np.random.rand(3,3)\nC -= np.trace(A.T @ C) / np.trace(A.T @ A) * A + np.trace(B.T @ C) / np.trace(B.T @ B) * B\nT = np.stack([A, B, C], axis=2)\nprint('Orthogonal under Frobenius:', [np.trace(T[:,:,i].T @ T[:,:,i+1]) for i in range(2)])"
  },
  {
    "input": "Make a tensor such that each frontal slice has a singular value decomposition with decreasing singular values.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    U, _ = np.linalg.qr(np.random.rand(3,3))\n    V, _ = np.linalg.qr(np.random.rand(3,3))\n    S = np.diag(np.sort(np.random.rand(3))[::-1])\n    T[:,:,i] = U @ S @ V.T\nprint('Slices have decreasing singular values.')"
  },
  {
    "input": "Construct a tensor where each mode-0 fiber forms a linearly independent set.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\nmode0_fibers = [T[i,:,:].flatten() for i in range(3)]\nmatrix = np.stack(mode0_fibers)\nprint('Linearly independent mode-0 fibers:', np.linalg.matrix_rank(matrix) == 3)"
  },
  {
    "input": "Generate a tensor T where all elements are integers and each slice has one unique prime number on the diagonal.",
    "output": "import numpy as np\nprimes = [2, 3, 5]\nT = np.zeros((3,3,3), dtype=int)\nfor i in range(3):\n    T[:,:,i] = np.eye(3, dtype=int) * primes[i]\nprint('Diagonals with unique primes:', [np.diag(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a tensor where the L1 norm of each column (across all slices) is constant.",
    "output": "import numpy as np\nT = np.random.rand(3,3,3)\ncolumn_norms = [np.sum(np.abs(T[:,j,:])) for j in range(3)]\nprint('Equal L1 norms for columns:', np.allclose(column_norms, column_norms[0]))"
  },
  {
    "input": "Build a tensor where all elements are rational and the mean of each slice is 1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randint(1, 10, (3,3))\n    A = A / A.mean()\n    T[:,:,i] = A\nprint('Slice means:', [T[:,:,i].mean() for i in range(3)])"
  },
  {
    "input": "Generate a tensor such that T[:,:,i] is a rotation by i * 30 degrees in 2D embedded in 3x3.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    theta = np.deg2rad(i * 30)\n    R = np.array([[np.cos(theta), -np.sin(theta), 0],\n                  [np.sin(theta),  np.cos(theta), 0],\n                  [0, 0, 1]])\n    T[:,:,i] = R\nprint('Rotation matrices embedded in 3x3:', T[:,:,0], T[:,:,1], T[:,:,2])"
  },
  {
    "input": "Construct a tensor T where all mode-1 fibers have standard deviation exactly 1.",
    "output": "import numpy as np\nT = np.random.randn(3,3,3)\nfor i in range(3):\n    for j in range(3):\n        fiber = T[:,i,j]\n        T[:,i,j] = (fiber - np.mean(fiber)) / np.std(fiber)\nprint('Std deviation of mode-1 fibers:', [np.std(T[:,i,j]) for i in range(3) for j in range(3)])"
  },
  {
    "input": "Create a tensor such that the inverse of each slice exists and their sum is a diagonal matrix.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nsum_inv = np.zeros((3,3))\nfor i in range(3):\n    A = np.random.rand(3,3) + np.eye(3)\n    T[:,:,i] = A\n    sum_inv += np.linalg.inv(A)\nprint('Sum of inverses is diagonal:', np.allclose(sum_inv, np.diag(np.diag(sum_inv))))"
  },
  {
    "input": "Create a tensor such that the trace of each slice is equal and non-zero, and each slice is upper triangular.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\ntrace_val = 5\nfor i in range(3):\n    A = np.triu(np.random.rand(3,3))\n    scale = trace_val / np.trace(A)\n    T[:,:,i] = A * scale\nprint('Traces:', [np.trace(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where each frontal slice has eigenvalues forming a geometric progression.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nbase, ratio = 2, 3\nfor i in range(3):\n    eigs = np.array([base * ratio**j for j in range(3)])\n    Q, _ = np.linalg.qr(np.random.rand(3,3))\n    T[:,:,i] = Q @ np.diag(eigs) @ Q.T\nprint('Eigenvalues of slices:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a 3x3x3 tensor such that the vectorization of each slice is orthogonal to the others.",
    "output": "import numpy as np\nQ, _ = np.linalg.qr(np.random.randn(9,9))  # Get 9 orthonormal vectors\nvecs = Q[:, :3].T  # Take 3 orthonormal vectors (shape: 3x9)\nT = np.stack([v.reshape(3,3) for v in vecs], axis=2)\nprint('Dot products of vectorized slices:', [np.dot(vecs[i], vecs[j]) for i in range(3) for j in range(i+1, 3)])"
  },
  {
    "input": "Generate a tensor such that T[i,j,k] = i^2 + j^2 - k^2.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            T[i,j,k] = i**2 + j**2 - k**2\nprint(T)"
  },
  {
    "input": "Create a tensor where the determinant of each slice is equal to the slice index (starting from 1).",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.eye(3) * (i+1)**(1/3)\n    T[:,:,i] = A\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor such that the sum of the elements of the diagonal of each slice equals 10.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    diag = np.random.rand(3)\n    diag = diag / diag.sum() * 10\n    T[:,:,i] = np.diag(diag)\nprint('Diagonal sums:', [np.trace(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Make a tensor T such that the columns of every slice are linearly dependent.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    col1 = np.random.rand(3)\n    col2 = 2 * col1\n    col3 = -col1\n    T[:,:,i] = np.column_stack([col1, col2, col3])\nprint('Ranks of slices:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where each slice is symmetric and the sum of its eigenvalues is zero.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    eigvals = np.random.randn(3)\n    eigvals -= eigvals.mean()\n    Q, _ = np.linalg.qr(np.random.rand(3,3))\n    T[:,:,i] = Q @ np.diag(eigvals) @ Q.T\nprint('Eigenvalue sums:', [np.sum(np.linalg.eigvals(T[:,:,i])) for i in range(3)])"
  },
  {
    "input": "Construct a tensor T where the Hadamard product of each pair of slices is a zero matrix.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nA = np.random.rand(3,3)\nB = np.random.rand(3,3)\nT[:,:,0] = A\nT[:,:,1] = 1 - np.sign(A)\nT[:,:,2] = np.zeros((3,3))\nprint('Hadamard products:', np.allclose(T[:,:,0] * T[:,:,1], 0))"
  },
  {
    "input": "Create a tensor where each slice has condition number less than 10.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.rand(3,3) + np.eye(3)\n        if np.linalg.cond(A) < 10:\n            T[:,:,i] = A\n            break\nprint('Condition numbers:', [np.linalg.cond(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor T where each slice has one column being the mean of the other two.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    c1 = np.random.rand(3)\n    c2 = np.random.rand(3)\n    c3 = (c1 + c2) / 2\n    T[:,:,i] = np.column_stack([c1, c2, c3])\nprint('Mean column test:', [np.allclose(T[:,2,i], (T[:,0,i] + T[:,1,i]) / 2) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where the mean of the rows in each slice is the same for all rows.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    row = np.random.rand(3)\n    T[:,:,i] = np.tile(row, (3,1))\nprint('Row means per slice:', [np.allclose(np.mean(T[:,:,i], axis=1), np.mean(T[:,:,i][0])) for i in range(3)])"
  },
  {
    "input": "Create a 3x3x3 tensor where each slice is a lower triangular matrix with integer entries and a determinant of 1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3), dtype=int)\nfor i in range(3):\n    L = np.tril(np.random.randint(1, 5, (3,3)))\n    L[2,2] = int(np.linalg.det(L[:2,:2]))\n    T[:,:,i] = L\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where each slice is a circulant matrix with eigenvalues forming an arithmetic sequence.",
    "output": "import numpy as np\nfrom scipy.linalg import circulant\nT = np.zeros((3,3,3))\nfor i in range(3):\n    first_row = np.arange(i, i+3)\n    T[:,:,i] = circulant(first_row)\nprint('Eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where each slice is an orthogonal matrix with determinant -1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    if np.linalg.det(Q) > 0:\n        Q[:,0] = -Q[:,0]\n    T[:,:,i] = Q\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice is a Toeplitz matrix with the first row being a geometric sequence.",
    "output": "import numpy as np\nfrom scipy.linalg import toeplitz\nT = np.zeros((3,3,3))\nfor i in range(3):\n    first_row = np.geomspace(1, 2**(i+1), num=3)\n    T[:,:,i] = toeplitz(first_row)\nprint('Toeplitz matrices:', T)"
  },
  {
    "input": "Generate a tensor where each slice is a Hankel matrix with anti-diagonals forming a harmonic sequence.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    anti_diag = 1 / np.arange(1, 4)\n    hankel_matrix = np.zeros((3, 3))\n    for row in range(3):\n        for col in range(3):\n            hankel_matrix[row, col] = anti_diag[row + col if row + col < 3 else 5 - (row + col)]\n    T[:,:,i] = hankel_matrix\nprint('Hankel matrices:', T)"
  },
  {
    "input": "Construct a tensor where each slice is a symmetric matrix with eigenvalues summing to zero and trace zero.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randn(3,3)\n    A = (A + A.T) / 2\n    A -= np.trace(A) / 3 * np.eye(3)\n    T[:,:,i] = A\nprint('Traces:', [np.trace(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice is a skew-symmetric matrix with integer entries.",
    "output": "import numpy as np\nT = np.zeros((3,3,3), dtype=int)\nfor i in range(3):\n    A = np.random.randint(-5, 6, (3,3))\n    T[:,:,i] = A - A.T\nprint('Skew-symmetric matrices:', T)"
  },
  {
    "input": "Generate a tensor where each slice is a doubly stochastic matrix.",
    "output": "import numpy as np\nfrom scipy.optimize import linprog\nT = np.zeros((3,3,3))\nfor i in range(3):\n    c = np.zeros(9)  # Objective function: we don't care about the values\n    A_eq = []\n    b_eq = []\n    # Row sum constraints\n    for j in range(3):\n        row_constraint = np.zeros(9)\n        row_constraint[j*3:(j+1)*3] = 1\n        A_eq.append(row_constraint)\n        b_eq.append(1)\n    # Column sum constraints\n    for j in range(3):\n        col_constraint = np.zeros(9)\n        col_constraint[j::3] = 1\n        A_eq.append(col_constraint)\n        b_eq.append(1)\n    bounds = [(0, 1)] * 9\n    A_eq = np.array(A_eq)\n    b_eq = np.array(b_eq)\n    res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    T[:,:,i] = res.x.reshape(3,3)\nprint('Doubly stochastic matrices:', T)"
  },
  {
    "input": "Construct a tensor where each slice is an idempotent matrix (A^2 = A) with rank 2.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randn(3,2)\n    P = A @ np.linalg.pinv(A)\n    T[:,:,i] = P\nprint('Idempotent matrices:', T)"
  },
  {
    "input": "Create a tensor where each slice is a symmetric positive definite matrix with condition number 5.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    U, _ = np.linalg.qr(np.random.randn(3,3))\n    S = np.diag([1, 2.5, 5])\n    A = U @ S @ U.T\n    T[:,:,i] = A\nprint('Condition numbers:', [np.linalg.cond(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where each slice is a matrix with eigenvalues that are all purely imaginary.",
    "output": "import numpy as np\nT = np.zeros((3,3,3), dtype=complex)\nfor i in range(3):\n    A = np.random.randn(3,3)\n    A = (A - A.T) * 1j\n    T[:,:,i] = A\nprint('Eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where each slice is a matrix that commutes with a fixed 3x3 matrix A.",
    "output": "import numpy as np\nA = np.array([[1,2,0],[0,3,0],[0,0,4]])\nT = np.zeros((3,3,2))\nfor i in range(2):\n    X = np.random.rand(3,3)\n    T[:,:,i] = A @ X @ np.linalg.inv(A)\nprint('Commutators:', [np.allclose(T[:,:,i] @ A, A @ T[:,:,i]) for i in range(2)])"
  },
  {
    "input": "Generate a tensor such that each slice is a nilpotent matrix (A^k = 0 for some k).",
    "output": "import numpy as np\nT = np.zeros((3,3,1))\nA = np.array([[0,1,0],[0,0,1],[0,0,0]])\nT[:,:,0] = A\nprint('Nilpotent check:', np.linalg.matrix_power(T[:,:,0], 3))"
  },
  {
    "input": "Construct a tensor where each slice is a projection matrix onto a random 2D subspace in R^3.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randn(3,2)\n    P = A @ np.linalg.inv(A.T @ A) @ A.T\n    T[:,:,i] = P\nprint('Projection matrix check (idempotent):', [np.allclose(T[:,:,i] @ T[:,:,i], T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice is a symmetric matrix whose inverse has all positive entries.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    A = A @ A.T + np.eye(3)\n    T[:,:,i] = A\nprint('Inverse positivity check:', [np.all(np.linalg.inv(T[:,:,i]) > 0) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where each slice has orthonormal rows but not columns.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3).T)\n    T[:,:,i] = Q.T\nprint('Row orthonormality check:', [np.allclose(T[:,:,i] @ T[:,:,i].T, np.eye(3)) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where each slice is a Jordan block with eigenvalue 1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nJ = np.eye(3)\nJ[0,1] = J[1,2] = 1\nfor i in range(3):\n    T[:,:,i] = J\nprint('Jordan block matrix eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a tensor such that T[i,j,k] = sin(i) * cos(j) + k^2.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            T[i,j,k] = np.sin(i) * np.cos(j) + k**2\nprint(T)"
  },
  {
    "input": "Construct a tensor where each slice is an invertible matrix with integer entries and integer inverse.",
    "output": "import numpy as np\nfrom sympy import Matrix\nT = np.zeros((3,3,3), dtype=int)\nfor i in range(3):\n    while True:\n        A = np.random.randint(-5, 6, (3,3))\n        try:\n            inv = np.array(Matrix(A).inv()).astype(int)\n            T[:,:,i] = A\n            break\n        except:\n            continue\nprint('Integer inverse slices:', T)"
  },
  {
    "input": "Generate a tensor where the rank of each slice is exactly 1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    u = np.random.rand(3,1)\n    v = np.random.rand(1,3)\n    T[:,:,i] = u @ v\nprint('Ranks:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a tensor where the Frobenius norm of each slice equals its spectral norm.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.zeros((3,3))\n    A[0,0] = np.random.rand()\n    T[:,:,i] = A\nprint('Norms check:', [(np.linalg.norm(T[:,:,i]), np.linalg.norm(T[:,:,i], 2)) for i in range(3)])"
  },
  {
    "input": "Construct a tensor such that every slice is a stochastic matrix but not doubly stochastic.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    T[:,:,i] = A / A.sum(axis=1, keepdims=True)\nprint('Row sums (should be 1):', [np.allclose(T[:,:,i].sum(axis=1), 1) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice's condition number increases geometrically.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nratios = [1, 10, 100]\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.rand(3,3))\n    S = np.diag([1, 1, ratios[i]])\n    T[:,:,i] = Q @ S @ Q.T\nprint('Condition numbers:', [np.linalg.cond(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a 3x3x3 tensor such that each slice is an upper triangular matrix with distinct eigenvalues.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.triu(np.random.randint(1, 10, (3,3)))\n    while len(set(np.round(np.linalg.eigvals(A), 5))) < 3:\n        A = np.triu(np.random.randint(1, 10, (3,3)))\n    T[:,:,i] = A\nprint('Eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice has determinant equal to the trace of its square.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    diag_vals = np.random.rand(3)  # Diagonal elements\n    A = np.diag(diag_vals)\n    # Adjust diagonal elements to ensure det(A) = trace(A^2)\n    if np.isclose(np.linalg.det(A), np.trace(A @ A)):\n        T[:,:,i] = A\nprint('Check condition:', [np.isclose(np.linalg.det(T[:,:,i]), np.trace(T[:,:,i] @ T[:,:,i])) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where every slice is a 3x3 matrix with minimal polynomial of degree 2.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        eigvals = np.random.rand(2)\n        A = np.array([[eigvals[0], 1, 0], [0, eigvals[0], 0], [0, 0, eigvals[1]]])  # Jordan block matrix\n        if len(np.unique(np.linalg.eigvals(A))) == 2:  # Check two distinct eigenvalues\n            T[:,:,i] = A\n            break\nprint('Eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where each slice is a non-symmetric matrix that is still diagonalizable.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\ndef is_diag(A):\n    try:\n        _, D = np.linalg.eig(A)\n        return True\n    except:\n        return False\nfor i in range(3):\n    while True:\n        A = np.random.randn(3,3)\n        if not np.allclose(A, A.T) and is_diag(A):\n            T[:,:,i] = A\n            break\nprint('Diagonalizability check passed.')"
  },
  {
    "input": "Generate a tensor where each slice is a normal matrix that is neither symmetric nor skew-symmetric.",
    "output": "import numpy as np\nT = np.zeros((3,3,3), dtype=complex)\nfor i in range(3):\n    A = np.random.randn(3,3) + 1j * np.random.randn(3,3)\n    A = A @ A.conj().T\n    A = A - 0.5j * (A - A.T)\n    T[:,:,i] = A\nprint('Normal matrix check:', [np.allclose(T[:,:,i] @ T[:,:,i].conj().T, T[:,:,i].conj().T @ T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor such that the singular values of each slice form a geometric progression.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    U, _ = np.linalg.qr(np.random.rand(3,3))\n    V, _ = np.linalg.qr(np.random.rand(3,3))\n    s = np.geomspace(1, 9, 3)\n    S = np.diag(s)\n    T[:,:,i] = U @ S @ V.T\nprint('Singular values:', [np.linalg.svd(T[:,:,i], compute_uv=False) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice is a companion matrix of a polynomial with alternating sign coefficients.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    coeffs = [(-1)**j * np.random.randint(1, 5) for j in range(4)]\n    A = np.zeros((3,3))\n    A[1:, :-1] = np.eye(2)\n    A[0, :] = -np.array(coeffs[1:])\n    T[:,:,i] = A\nprint('Polynomials:', coeffs)"
  },
  {
    "input": "Generate a tensor such that the product of the 3 matrix slices equals the identity matrix.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nA = np.random.rand(3,3)\nB = np.random.rand(3,3)\nC = np.linalg.inv(B @ A)\nT[:,:,0], T[:,:,1], T[:,:,2] = A, B, C\nprint('Check product:', np.allclose(T[:,:,0] @ T[:,:,1] @ T[:,:,2], np.eye(3)))"
  },
  {
    "input": "Construct a tensor where each slice is a matrix whose transpose is its inverse.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    T[:,:,i] = Q\nprint('Orthogonality check:', [np.allclose(T[:,:,i].T, np.linalg.inv(T[:,:,i])) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice has eigenvectors forming an orthonormal basis, but eigenvalues are repeated.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    D = np.diag([2, 2, 3])\n    A = Q @ D @ Q.T\n    T[:,:,i] = A\nprint('Orthonormal eigvecs with repeated eigvals')"
  },
  {
    "input": "Generate a tensor where the sum over all slices results in a diagonal matrix with decreasing entries.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    D = np.diag([9-i, 6-i, 3-i])\n    T[:,:,i] = D\nS = np.sum(T, axis=2)\nprint('Summed tensor (should be diagonal decreasing):\\n', S)"
  },
  {
    "input": "Construct a tensor where each slice is a 3x3 matrix with purely imaginary eigenvalues.",
    "output": "import numpy as np\nT = np.zeros((3,3,3), dtype=complex)\nfor i in range(3):\n    A = np.array([[0, -np.random.rand(), 0], [np.random.rand(), 0, 0], [0, 0, 0]])\n    T[:,:,i] = A\nprint('Eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where each slice has rank 2 and nullity 1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,2)\n    T[:,:,i] = A @ np.random.rand(2,3)\nprint('Ranks:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice is both symmetric and has determinant equal to 1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.rand(3,3)\n        A = (A + A.T)/2\n        if np.isclose(np.linalg.det(A), 1, atol=0.1):\n            T[:,:,i] = A\n            break\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor such that all slices commute pairwise.",
    "output": "import numpy as np\nB = np.random.rand(3,3)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    T[:,:,i] = np.linalg.matrix_power(B, i+1)\nprint('Commutativity check:', [np.allclose(T[:,:,i] @ T[:,:,j], T[:,:,j] @ T[:,:,i]) for i in range(3) for j in range(3)])"
  },
  {
    "input": "Create a tensor where each slice is a positive definite matrix with one eigenvalue repeated.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.rand(3,3))\n    D = np.diag([2, 2, 5])\n    A = Q @ D @ Q.T\n    T[:,:,i] = A\nprint('Positive definite with repeated eigenvalue')"
  },
  {
    "input": "Construct a tensor where each slice is a symmetric matrix with one zero eigenvalue.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.rand(3,3))\n    D = np.diag([0, np.random.rand(), np.random.rand()])\n    T[:,:,i] = Q @ D @ Q.T\nprint('Eigenvalues:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where each slice is idempotent but not equal to the identity.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    P = A @ np.linalg.pinv(A)\n    if not np.allclose(P, np.eye(3)):\n        T[:,:,i] = P\nprint('Idempotency check:', [np.allclose(T[:,:,i] @ T[:,:,i], T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where the norm of the matrix exponential of each slice is less than 100.",
    "output": "import numpy as np\nfrom scipy.linalg import expm\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.rand(3,3) - 0.5\n        if np.linalg.norm(expm(A)) < 100:\n            T[:,:,i] = A\n            break\nprint('Exponential norms:', [np.linalg.norm(expm(T[:,:,i])) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice is a matrix whose cube is zero but square is not.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nA = np.array([[0,1,0],[0,0,1],[0,0,0]])\nfor i in range(3):\n    T[:,:,i] = A\nprint('Check A^2 != 0, A^3 == 0:', np.linalg.matrix_power(A,2), np.linalg.matrix_power(A,3))"
  },
  {
    "input": "Construct a tensor where each slice's trace is equal to the sum of its eigenvalues squared.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.randn(3,3)\n        eigs = np.linalg.eigvals(A)\n        if np.isclose(np.trace(A), np.sum(eigs**2), atol=0.1):\n            T[:,:,i] = A\n            break\nprint('Condition check:', [np.trace(T[:,:,i]) - np.sum(np.linalg.eigvals(T[:,:,i])**2) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where the eigenvalues of each slice form an arithmetic progression.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    d = np.random.randint(1, 5)\n    a = np.random.randint(1, 5)\n    eigs = np.array([a, a+d, a+2*d])\n    A = Q @ np.diag(eigs) @ Q.T\n    T[:,:,i] = A\nprint('Eigenvalues in AP:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where the Frobenius norm of each slice is equal to the rank of that slice.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.randn(3,3)\n        if int(np.round(np.linalg.norm(A, 'fro'))) == np.linalg.matrix_rank(A):\n            T[:,:,i] = A\n            break\nprint('Frobenius norm == rank:', [np.linalg.norm(T[:,:,i], 'fro') == np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where each slice is orthogonal to its transpose under the Frobenius inner product.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randn(3,3)\n    A = A - A.T\n    T[:,:,i] = A\nprint('Frobenius inner product with transpose is 0:', [np.trace(T[:,:,i].T @ T[:,:,i].T) == 0 for i in range(3)])"
  },
  {
    "input": "Create a tensor where the eigenvalues of each slice lie on the unit circle in the complex plane.",
    "output": "import numpy as np\nT = np.zeros((3,3,3), dtype=complex)\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3) + 1j*np.random.randn(3,3))\n    eigs = np.exp(2j * np.pi * np.random.rand(3))\n    T[:,:,i] = Q @ np.diag(eigs) @ np.linalg.inv(Q)\nprint('Eigenvalues on unit circle:', [np.abs(np.linalg.eigvals(T[:,:,i])) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice is nilpotent of index 3 (i.e., A^3 = 0 but A^2 \u2260 0).",
    "output": "import numpy as np\nA = np.array([[0,1,0],[0,0,1],[0,0,0]])\nT = np.stack([A for _ in range(3)], axis=2)\nprint('Nilpotent matrix cube check:', [np.allclose(np.linalg.matrix_power(T[:,:,i], 3), 0) and not np.allclose(np.linalg.matrix_power(T[:,:,i], 2), 0) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where the matrix exponential of each slice is a rotation matrix.",
    "output": "import numpy as np\nfrom scipy.linalg import expm\nT = np.zeros((3,3,3))\nfor i in range(3):\n    theta = np.pi/4 * (i+1)\n    A = np.array([[0, -theta, 0], [theta, 0, 0], [0, 0, 0]])\n    T[:,:,i] = expm(A)\nprint('Rotation matrix check:', [np.allclose(T[:,:,i].T @ T[:,:,i], np.eye(3)) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where each slice is a Jordan block of size 3 for eigenvalue \u03bb=2.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.array([[2,1,0],[0,2,1],[0,0,2]])\n    T[:,:,i] = A\nprint('Jordan blocks for \u03bb=2')"
  },
  {
    "input": "Generate a tensor where all slices are diagonalizable over \u2102 but not over \u211d.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    theta = np.pi/3\n    A = np.array([[0, -theta, 0], [theta, 0, 0], [0, 0, 1]])\n    T[:,:,i] = A\nprint('Eigenvalues complex:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice has determinant -1 and trace 0.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.randn(3,3)\n        if np.isclose(np.linalg.det(A), -1, atol=0.1) and np.isclose(np.trace(A), 0, atol=0.1):\n            T[:,:,i] = A\n            break\nprint('Det = -1 and Trace = 0 check:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where the inverse of each slice has integer entries.",
    "output": "import numpy as np\nfrom sympy import Matrix\nT = np.zeros((3,3,3))\nfor i in range(3):\n    while True:\n        A = np.random.randint(1,5,(3,3))\n        try:\n            A_inv = Matrix(A).inv()\n            if all(float(x).is_integer() for x in A_inv):\n                T[:,:,i] = A\n                break\n        except:\n            continue\nprint('Inverse has integer entries')"
  },
  {
    "input": "Generate a tensor where each slice is a matrix whose eigenvalues sum to zero but product is non-zero.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    eigs = np.array([2, -1, -1])\n    A = Q @ np.diag(eigs) @ Q.T\n    T[:,:,i] = A\nprint('Sum 0, product non-zero:', [np.sum(np.linalg.eigvals(T[:,:,i])) == 0 and np.prod(np.linalg.eigvals(T[:,:,i])) != 0 for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice is a matrix such that A*A.T = k*I for k > 0.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    k = np.random.randint(1, 5)\n    A = np.sqrt(k) * Q\n    T[:,:,i] = A\nprint('A*A.T = k*I check:', [np.allclose(T[:,:,i] @ T[:,:,i].T, np.eye(3) * np.linalg.norm(T[:,:,i], 'fro')**2 / 3) for i in range(3)])"
  },
  {
    "input": "Create a tensor where each slice is a rank-1 matrix formed by outer products of random vectors.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    v = np.random.randn(3)\n    T[:,:,i] = np.outer(v, v)\nprint('Ranks:', [np.linalg.matrix_rank(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where each slice has eigenvalues forming a geometric progression.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    r = np.random.randint(2, 5)\n    eigs = np.array([1, r, r**2])\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    A = Q @ np.diag(eigs) @ np.linalg.inv(Q)\n    T[:,:,i] = A\nprint('Eigenvalues in GP:', [np.linalg.eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where each slice is a normal matrix with complex entries.",
    "output": "import numpy as np\nT = np.zeros((3,3,3), dtype=complex)\nfor i in range(3):\n    A = np.random.randn(3,3) + 1j*np.random.randn(3,3)\n    A = (A + A.conj().T)/2 + 1j*(A - A.conj().T)/2\n    T[:,:,i] = A\nprint('Normal matrix check:', [np.allclose(A @ A.conj().T, A.conj().T @ A) for A in T.transpose(2,0,1)])"
  },
  {
    "input": "Generate a tensor where each slice is similar to a diagonal matrix but not itself diagonal.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    D = np.diag(np.random.randint(1, 5, size=3))\n    P = np.random.rand(3,3)\n    A = np.linalg.inv(P) @ D @ P\n    if not np.allclose(A, np.diag(np.diag(A))):\n        T[:,:,i] = A\nprint('Diagonalizable but not diagonal')"
  },
  {
    "input": "Construct a tensor where each slice is an upper triangular matrix with the same eigenvalues.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nevals = [2, 2, 2]\nfor i in range(3):\n    A = np.triu(np.random.rand(3,3))\n    np.fill_diagonal(A, evals)\n    T[:,:,i] = A\nprint('Upper triangular with same eigenvalues')"
  },
  {
    "input": "Create a tensor where each slice is orthogonal and skew-symmetric.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randn(3,3)\n    A = A - A.T\n    Q, _ = np.linalg.qr(A)\n    T[:,:,i] = Q\nprint('Orthogonal and skew-symmetric')"
  },
  {
    "input": "Create a tensor where each slice is a symmetric matrix with condition number exactly 1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    A = Q @ np.eye(3) @ Q.T\n    T[:,:,i] = A\nprint('Condition number = 1:', [np.linalg.cond(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where each slice is a stochastic matrix (rows sum to 1).",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    T[:,:,i] = A / A.sum(axis=1, keepdims=True)\nprint('Row sums:', [T[:,:,i].sum(axis=1) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where the SVD of each slice has singular values all equal.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    U, _ = np.linalg.qr(np.random.randn(3,3))\n    V, _ = np.linalg.qr(np.random.randn(3,3))\n    s = np.ones(3)\n    A = U @ np.diag(s) @ V.T\n    T[:,:,i] = A\nprint('Singular values:', [np.linalg.svd(T[:,:,i], compute_uv=False) for i in range(3)])"
  },
  {
    "input": "Construct a tensor where the determinant of the product of all slices equals 1.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nA = np.eye(3)\nfor i in range(3):\n    R = np.random.rand(3,3)\n    R = R / np.cbrt(np.linalg.det(R))\n    T[:,:,i] = R\n    A = A @ R\nprint('Determinant of product:', np.linalg.det(A))"
  },
  {
    "input": "Create a tensor where each slice commutes with a fixed skew-symmetric matrix.",
    "output": "import numpy as np\nS = np.array([[0, -1, 0], [1, 0, 0], [0, 0, 0]])\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.rand(3,3)\n    A = (A @ S == S @ A)\n    T[:,:,i] = S\nprint('Each slice commutes with S')"
  },
  {
    "input": "Construct a tensor where each slice has purely imaginary eigenvalues but is not skew-symmetric.",
    "output": "import numpy as np\nT = np.zeros((3,3,3), dtype=complex)\nfor i in range(3):\n    while True:\n        A = np.random.randn(3,3) * 1j\n        if not np.allclose(A, -A.T.conj()):\n            eigs = np.linalg.eigvals(A)\n            if np.all(np.isreal(eigs.imag)) and np.all(np.abs(eigs.real) < 1e-10):\n                T[:,:,i] = A\n                break\nprint('Pure imaginary eigenvalues and not skew-Hermitian')"
  },
  {
    "input": "Create a tensor where each slice has a Jordan form with one block of size 2 and one of size 1 for the same eigenvalue.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    \u03bb = np.random.randint(1,5)\n    J = np.array([[\u03bb,1,0],[0,\u03bb,0],[0,0,\u03bb]])\n    P = np.random.rand(3,3)\n    A = np.linalg.inv(P) @ J @ P\n    T[:,:,i] = A\nprint('Jordan block: \u03bb with sizes 2 and 1')"
  },
  {
    "input": "Construct a (3,3,3) tensor where each frontal slice is symmetric and the overall tensor is also symmetric across all modes.",
    "output": "import numpy as np\nA = np.random.rand(3,3)\nA_sym = (A + A.T) / 2\nT = np.zeros((3,3,3))\nfor i in range(3):\n    T[i] = A_sym\nT = (T + T.transpose(1, 0, 2) + T.transpose(2, 1, 0)) / 3\nprint('Tensor symmetric across all modes:', np.allclose(T, T.transpose(1, 0, 2)) and np.allclose(T, T.transpose(2, 1, 0)))"
  },
  {
    "input": "Generate a tensor where the determinant of each frontal slice is zero, but the tensor slices are not all zero matrices.",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    A = np.random.randn(3,2) @ np.random.randn(2,3)  # Rank < 3\n    T[:,:,i] = A\nprint('Determinants:', [np.linalg.det(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Create a (3,3,3) tensor where all slices commute pairwise under matrix multiplication.",
    "output": "import numpy as np\nB = np.random.randn(3,3)\nT = np.zeros((3,3,3))\nfor i in range(3):\n    T[:,:,i] = np.linalg.matrix_power(B, i+1)\ncommute = all(np.allclose(T[:,:,i] @ T[:,:,j], T[:,:,j] @ T[:,:,i]) for i in range(3) for j in range(3))\nprint('All slices commute:', commute)"
  },
  {
    "input": "Construct a tensor where each slice has eigenvalues forming a geometric sequence.",
    "output": "import numpy as np\nfrom scipy.linalg import eigvals\nT = np.zeros((3,3,3))\nfor i in range(3):\n    v = np.geomspace(1, 4, num=3)\n    V = np.linalg.qr(np.random.randn(3,3))[0]  # Orthogonal matrix\n    A = V @ np.diag(v) @ np.linalg.inv(V)\n    T[:,:,i] = A.real\nprint('Eigenvalues per slice:', [eigvals(T[:,:,i]) for i in range(3)])"
  },
  {
    "input": "Generate a tensor where each slice is an involutory matrix (i.e., A^2 = I).",
    "output": "import numpy as np\nT = np.zeros((3,3,3))\nfor i in range(3):\n    Q, _ = np.linalg.qr(np.random.randn(3,3))\n    A = 2 * np.outer(Q[:,0], Q[:,0]) - np.eye(3)\n    T[:,:,i] = A\nprint('Check A^2 = I:', [np.allclose(T[:,:,i] @ T[:,:,i], np.eye(3)) for i in range(3)])"
  }
]